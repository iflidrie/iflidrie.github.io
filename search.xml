<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《趣学算法》——第二章（贪心算法）</title>
      <link href="/posts/87ab2347.html"/>
      <url>/posts/87ab2347.html</url>
      
        <content type="html"><![CDATA[<h3 id="第二章-贪心算法">第二章　贪心算法</h3><p>从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相还不满足，还要求做皇帝。蛇此时终于明白了，人的贪心是永无止境的，于是一口就把这个人吞掉了。</p><p>所以，蛇吞掉的是宰相，而不是大象。故此，留下了“人心不足蛇吞相”的典故。</p><h3 id="2-1-人之初，性本贪">2.1　人之初，性本贪</h3><p>我们小时候背诵《三字经》，“人之初，性本善，性相近，习相远。”其实我觉得很多时候“人之初，性本贪”。小孩子吃糖果，总是想要多多的；吃水果，想要最大的；买玩具，总是想要最好的，这些东西并不是大人教的，而是与生俱来的。对美好事物的趋优性，就像植物的趋光性，“良禽择木而栖，贤臣择主而事”“窈窕淑女，君子好逑”，我们似乎永远在追求美而优的东西。现实中的很多事情，正是因为趋优性使我们的生活一步一步走向美好。例如，我们竭尽所能买了一套房子，然后就想要添置一些新的家具，再就想着可能还需要一辆车子……</p><p>凡事都有两面性，一把刀可以做出美味佳肴，也可以变成杀人凶器。在这里，我们只谈好的“贪心”。</p><h3 id="2-1-1-贪心本质">2.1.1　贪心本质</h3><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。</p><p>——《算法导论》</p><p>我们经常会听到这些话：“人要活在当下”“看清楚眼前”……贪心算法正是“活在当下，看清楚眼前”的办法，从问题的初始解开始，一步一歩地做出当前最好的选择，逐步逼近问题的目标，尽可能地得到最优解，即使达不到最优解，也可以得到最优解的近似解。</p><p>贪心算法在解决问题的策略上“目光短浅”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。贪心算法能得到许多问题的整体最优解或整体最优解的近似解。因此，贪心算法在实际中得到大量的应用。</p><p>在贪心算法中，我们需要注意以下几个问题。</p><p>（1）没有后悔药。一旦做出选择，不可以反悔。</p><p>（2）有可能得到的不是最优解，而是最优解的近似解。</p><p>（3）选择什么样的贪心策略，直接决定算法的好坏。</p><p>那么，贪心算法需要遵循什么样的原则呢？</p><h3 id="2-1-2-贪亦有道">2.1.2　贪亦有道</h3><p>“君子爱财，取之有道”，我们在贪心算法中“贪亦有道”。通常我们在遇到具体问题时，往往分不清哪些问题该用贪心策略求解，哪些问题不能使用贪心策略。经过实践我们发现，利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。如果满足这两个性质就可以使用贪心算法了。</p><p>（1）贪心选择</p><p>所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前最佳的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。运用贪心策略解决的问题在程序的运行过程中无回溯过程。关于贪心选择性质，读者可在后续的贪心策略状态空间图中得到深刻的体会。</p><p>（2）最优子结构</p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。例如原问题S={a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">i</sub>，…，a<sub class="my_markdown">n</sub>}，通过贪心选择选出一个当前最优解{a<sub class="my_markdown">i</sub>}之后，转化为求解子问题S−{a<sub class="my_markdown">i</sub>}，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质，如图2-1所示。</p><p><img src="https://source.drie.cn/qxsf-images/27.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-1　原问题和子问题</b></center><h3 id="2-1-3-贪心算法秘籍">2.1.3　贪心算法秘籍</h3><p>武林中有武功秘籍，算法中也有贪心秘籍。上面我们已经知道了具有贪心选择和最优子结构性质就可以使用贪心算法，那么如何使用呢？下面介绍贪心算法秘籍。</p><p>（1）贪心策略</p><p>首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大的，作为局部最优解，贪心策略就是选择当前最大的苹果；如果你认为最红的苹果是最好的，那你每次都从苹果堆中拿一个最红的，贪心策略就是选择当前最红的苹果。因此根据求解目标不同，贪心策略也会不同。</p><p>（2）局部最优解</p><p>根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为a<sub class="my_markdown">1</sub>，第二次再从剩下的苹果堆中选择一个最大的苹果放起来，记为a<sub>2</sub>，以此类推。</p><p>（3）全局最优解</p><p>把所有的局部最优解合成为原来问题的一个最优解（a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…）。</p><blockquote><p>怎么有点儿像冒泡排序啊？</p></blockquote><p>“不是六郎似荷花，而是荷花似六郎”！不是贪心算法像冒泡排序，而是冒泡排序使用了贪心算法，它的贪心策略就是每一次从剩下的序列中选一个最大的数，把这些选出来的数放在一起，就得到了从大到小的排序结果，如图2-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/28.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-2　冒泡排序</b></center><h3 id="2-2-加勒比海盗船——最优装载问题">2.2　加勒比海盗船——最优装载问题</h3><p>在北美洲东南部，有一片神秘的海域，那里碧海蓝天、阳光明媚，这正是传说中海盗最活跃的加勒比海（Caribbean Sea）。17世纪时，这里更是欧洲大陆的商旅舰队到达美洲的必经之地，所以当时的海盗活动非常猖獗，海盗不仅攻击过往商人，甚至攻击英国皇家舰……</p><p>有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值。虽然海盗船足够大，但载重量为C，每件古董的重量为w<sub class="my_markdown">i</sub>，海盗们该如何把尽可能多数量的宝贝装上海盗船呢？</p><p><img src="https://source.drie.cn/qxsf-images/29.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-3　加勒比海盗</b></center><h3 id="2-2-1-问题分析">2.2.1　问题分析</h3><p>根据问题描述可知这是一个可以用贪心算法求解的最优装载问题，要求装载的物品的数量尽可能多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。采用重量最轻者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。</p><h3 id="2-2-2-算法设计">2.2.2　算法设计</h3><p>（1）当载重量为定值c时，w<sub class="my_markdown">i</sub>越小时，可装载的古董数量n越大。只要依次选择最小重量古董，直到不能再装为止。</p><p>（2）把n个古董的重量从小到大（非递减）排序，然后根据贪心策略尽可能多地选出前i个古董，直到不能继续装为止，此时达到最优。</p><h3 id="2-2-3-完美图解">2.2.3　完美图解</h3><p>我们现在假设这批古董如图2-4所示。</p><p><img src="https://source.drie.cn/qxsf-images/30.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-4　古董图片</b></center><p>每个古董的重量如表2-1所示，海盗船的载重量c为30，那么在不能打碎古董又不超过载重的情况下，怎么装入最多的古董？</p><center class="my_markdown"><b class="my_markdown">表2-1　古董重量清单</b></center><p>| 重量w[i] | 4 | 10 | 7 | 11 | 3 | 5 | 14 | 2 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p><p>（1）因为贪心策略是每次选择重量最小的古董装入海盗船，因此可以按照古董重量非递减排序，排序后如表2-2所示。</p><center class="my_markdown"><b class="my_markdown">表2-2　按重量排序后古董清单</b></center><p>| 重量w[i] | 2 | 3 | 4 | 5 | 7 | 10 | 11 | 14 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p><p>（2）按照贪心策略，每次选择重量最小的古董放入（tmp 代表古董的重量，ans 代表已装裁的古董个数）。</p><p>i=0，选择排序后的第1个，装入重量tmp=2，不超过载重量30，ans =1。</p><p>i=1，选择排序后的第2个，装入重量tmp=2+3=5，不超过载重量30，ans =2。</p><p>i=2，选择排序后的第3个，装入重量tmp=5+4=9，不超过载重量30，ans =3。</p><p>i=3，选择排序后的第4个，装入重量tmp=9+5=14，不超过载重量30，ans =4。</p><p>i=4，选择排序后的第5个，装入重量tmp=14+7=21，不超过载重量30，ans =5。</p><p>i=5，选择排序后的第6个，装入重量tmp=21+10=31，超过载重量30，算法结束。</p><p>即放入古董的个数为ans=5个。</p><h3 id="2-2-4-伪代码详解">2.2.4　伪代码详解</h3><p>（1）数据结构定义</p><p>根据算法设计描述，我们用一维数组存储古董的重量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> w[N];  <span class="comment">//一维数组存储古董的重量</span></span><br></pre></td></tr></table></figure><p>（2）按重量排序</p><p>可以利用C++中的排序函数sort（见附录B），对古董的重量进行从小到大（非递减）排序。要使用此函数需引入头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>语法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">//参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                <span class="comment">//sort函数默认为升序</span></span><br></pre></td></tr></table></figure><p>在本例中只需要调用sort函数对古董的重量进行从小到大排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(w, w+n); <span class="comment">//按古董重量升序排序</span></span><br></pre></td></tr></table></figure><p>（3）按照贪心策略找最优解</p><p>首先用变量ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量，两个变量都初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果小于等于载重量c，则令ans ++；否则，退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = <span class="number">0</span>;  <span class="comment">//tmp代表装载到船上的古董的重量，ans记录已经装载的古董个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">     ans ++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-实战演练">2.2.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> w[N]; <span class="comment">//古董的重量数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入载重量c及古董个数n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个古董的重量，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]; <span class="comment">//输入每个物品重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(w,w+n); <span class="comment">//按古董重量升序排序</span></span><br><span class="line">    <span class="type">double</span> temp=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>; <span class="comment">// tmp为已装载到船上的古董重量，ans为已装载的古董个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp+=w[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">           ans ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;能装入的古董最大数量为Ans=&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入载重量c及古董个数n：</span><br><span class="line"><span class="number">30</span> <span class="number">8</span>   <span class="comment">//载重量c及古董的个数n </span></span><br><span class="line">请输入每个古董的重量，用空格分开：</span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">7</span> <span class="number">11</span> <span class="number">3</span> <span class="number">5</span> <span class="number">14</span> <span class="number">2</span>  <span class="comment">//每个古董的重量，用空格隔开</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能装入的古董最大数量为Ans=<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-算法解析及优化拓展">2.2.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析">1．算法复杂度分析</h4><p>（1）时间复杂度：首先需要按古董重量排序，调用sort函数，其平均时间复杂度为O(nlogn)，输入和贪心策略求解的两个for语句时间复杂度均为O(n)，因此时间复杂度为O(n + nlog(n))。</p><p>（2）空间复杂度：程序中变量tmp、ans等占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为O(1)。</p><h4 id="2．优化拓展">2．优化拓展</h4><p>（1）这一个问题为什么在没有装满的情况下，仍然是最优解？算法要求装入最多数量，假如c为5，4个物品重量分别为1、3、5、7。排序后，可以装入1和3，最多装入两个。分析发现是最优的，如果装大的物品，最多装一个或者装不下，所以选最小的先装才能装入最多的数量，得到解是最优的。</p><p>（2）在伪代码详解的第3步“按照贪心策略找最优解”，如果把代码替换成下面代码，有什么不同？</p><p>首先用变量ans记录已经装载的古董个数，初始化为n；tmp代表装载到船上的古董的重量，初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果tmp大于等于载重量c，则判断是否正好等于载重量c，并令ans=i+1；否则ans = i，退出。如果tmp小于载重量c，i++，继续下一个循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = n;  <span class="comment">//ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&gt;=c)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(tmp==c) <span class="comment">//假如刚好，最后一个可以放</span></span><br><span class="line">        ans = i+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        ans = i; <span class="comment">//如果满了，最后一个不能放</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果想知道装入了哪些古董，需要添加什么程序来实现呢？请大家动手试一试吧！</p><p>那么，还有没有更好的算法来解决这个问题呢？</p><h3 id="2-3-阿里巴巴与四十大盗——背包问题">2.3　阿里巴巴与四十大盗——背包问题</h3><p>有一天，阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时，远处突然出现一股烟尘，弥漫着直向上空飞扬，朝他这儿卷过来，而且越来越近。靠近以后，他才看清原来是一支马队，他们共有四十人，一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋，从丛林中一直来到那个大石头跟前，喃喃地说道：“芝麻，开门吧！”随着那个头目的喊声，大石头前突然出现一道宽阔的门路，于是强盗们鱼贯而入。阿里巴巴待在树上观察他们，直到他们走得无影无踪之后，才从树上下来。他大声喊道：“芝麻，开门吧！”他的喊声刚落，洞门立刻打开了。他小心翼翼地走了进去，一下子惊呆了，洞中堆满了财物，还有多得无法计数的金银珠宝，有的散堆在地上，有的盛在皮袋中。突然看见这么多的金银财富，阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界，见识一下这些宝物，他想一种宝物只拿一个，如果太重就用锤子凿开，但毛驴的运载能力是有限的，怎么才能用驴子运走最大价值的财宝分给穷人呢？</p><p>阿里巴巴陷入沉思中……</p><p><img src="https://source.drie.cn/qxsf-images/31.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-5　阿里巴巴与四十大盗</b></center><h3 id="2-3-1-问题分析">2.3.1　问题分析</h3><p>假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？</p><p>我们可以尝试贪心策略：</p><p>（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？</p><p>（2）每次挑选重量最小的宝物装入，能否得到最优解？</p><p>（3）每次选取单位重量价值最大的宝物，能否使价值最高？</p><p>思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第1种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第2种策略舍弃；而第3种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大。</p><p>因此采用第3种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。</p><h3 id="2-3-2-算法设计">2.3.2　算法设计</h3><p>（1）数据结构及初始化。将n种宝物的重量和价值存储在结构体three（包含重量、价值、性价比3个成员）中，同时求出每种宝物的性价比也存储在对应的结构体three中，将其按照性价比从高到低排序。采用sum来存储毛驴能够运走的最大价值，初始化为0。</p><p>（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于m（毛驴运载能力），如果小于m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m减去放入宝物的重量；如果不小于m，则取该宝物的一部分m * p[i]，m=0，程序结束。m减少到0，则sum得到最大值。</p><h3 id="2-3-3-完美图解">2.3.3　完美图解</h3><p>假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入最大价值的物品？</p><center class="my_markdown"><b class="my_markdown">表2-3　宝物清单</b></center><p>| 宝物i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 4 | 2 | 9 | 5 | 5 | 8 | 5 | 4 | 5 | 5 |<br>| 价值v[i] | 3 | 8 | 18 | 6 | 8 | 20 | 5 | 6 | 7 | 15 |</p><p>（1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，可以按照性价比降序排序，排序后如表2-4所示。</p><center class="my_markdown"><b class="my_markdown">表2-4　排序后宝物清单</b></center><p>| 宝物i | 2 | 10 | 6 | 3 | 5 | 8 | 9 | 4 | 7 | 1 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 2 | 5 | 8 | 9 | 5 | 4 | 5 | 5 | 5 | 4 |<br>| 价值v[i] | 8 | 15 | 20 | 18 | 8 | 6 | 7 | 6 | 5 | 3 |<br>| 性价比p[i] | 4 | 3 | 2.5 | 2 | 1.6 | 1.5 | 1.4 | 1.2 | 1 | 0.75 |</p><p>（2）按照贪心策略，每次选择性价比高的宝物放入：</p><p>第1次选择宝物2，剩余容量30−2=28，目前装入最大价值为8。</p><p>第2次选择宝物10，剩余容量28−5=23，目前装入最大价值为8+15=23。</p><p>第3次选择宝物6，剩余容量23−8=15，目前装入最大价值为23+20=43。</p><p>第4次选择宝物3，剩余容量15−9=6，目前装入最大价值为43+18=61。</p><p>第5次选择宝物5，剩余容量6−5=1，目前装入最大价值为61+8=69。</p><p>第6次选择宝物8，发现上次处理完时剩余容量为1，而8号宝物重量为4，无法全部放入，那么可以采用部分装入的形式，装入1个重量单位，因为8号宝物的单位重量价值为1.5，因此放入价值1×1.5=1.5，你也可以认为装入了8号宝物的1/4，目前装入最大价值为69+1.5=70.5，剩余容量为0。</p><p>（3）构造最优解</p><p>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了8号财宝的1/4），能够装入宝物的最大价值为70.5。</p><h3 id="2-3-4-伪代码详解">2.3.4　伪代码详解</h3><p>（1）数据结构定义</p><p>根据算法设计中的数据结构，我们首先定义一个结构体three：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w; <span class="comment">//每种宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v; <span class="comment">//每种宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p; <span class="comment">//每种宝物的性价比（价值/重量）</span></span><br><span class="line">     ｝</span><br></pre></td></tr></table></figure><p>（2）性价比排序</p><p>我们可以利用C++中的排序函数sort（见附录B），对宝物的性价比从大到小（非递增）排序。要使用此函数需引入头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>语法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">// 参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br></pre></td></tr></table></figure><p>在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不使用自定义比较函数，那么sort函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span><span class="comment">//比较函数按照宝物性价比降序排列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p &gt; b.p; <span class="comment">//指明按照宝物性价比降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(s, s+n, cmp); <span class="comment">//前两个参数分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                   <span class="comment">//最后一个参数compare表示比较的类型</span></span><br></pre></td></tr></table></figure><p>（3）贪心算法求解</p><p>在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入宝物的最大价值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="comment">//按照排好的顺序，执行贪心策略</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>( m &gt; s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量</span></span><br><span class="line">     &#123;</span><br><span class="line">        m -= s[i].w;</span><br><span class="line">        sum += s[i].v;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">      &#123;</span><br><span class="line">         sum += m乘以s[i].p;  <span class="comment">//进行宝物切割，切割一部分(m重量)，正好达到驴子承重</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-实战演练">2.3.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w;<span class="comment">//每个宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v;<span class="comment">//每个宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p;<span class="comment">//性价比</span></span><br><span class="line">&#125;s[M];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a.p&gt;b.p;<span class="comment">//根据宝物的单位价值从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;<span class="comment">//n 表示有n个宝物</span></span><br><span class="line">     <span class="type">double</span> m ;<span class="comment">//m 表示毛驴的承载能力</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入宝物数量n及毛驴的承载能力m ：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个宝物的重量和价值，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s[i].w&gt;&gt;s[i].v;</span><br><span class="line">         s[i].p=s[i].v/s[i].w;<span class="comment">//每个宝物单位价值</span></span><br><span class="line">     &#125;</span><br><span class="line">     sort(s,s+n,cmp);</span><br><span class="line">     <span class="type">double</span> sum=<span class="number">0.0</span>;<span class="comment">// sum表示贪心记录运走宝物的价值之和</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//按照排好的顺序贪心</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>( m&gt;s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              m-=s[i].w;</span><br><span class="line">              sum+=s[i].v;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              sum+=m*s[i].p;<span class="comment">//部分装入</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入宝物的最大价值Maximum value=&quot;</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">19</span> <span class="comment">//宝物数量，驴子的承载重量</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span> <span class="comment">//第1个宝物的重量和价值</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="comment">//第2个宝物的重量和价值</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maxinum value=<span class="number">24.6</span></span><br></pre></td></tr></table></figure><h3 id="2-3-6-算法解析及优化拓展">2.3.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4><p>（1）时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为O(nlogn)。</p><p>（2）空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为O(n)。</p><p>为了使 m 重量里的所有物品的价值最大，利用贪心思想，每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得到的价值更大，因此采用贪心策略能得到最优解。</p><h4 id="2．算法优化拓展">2．算法优化拓展</h4><p>那么想一想，如果宝物不可分割，贪心算法是否能得到最优解？</p><p>下面我们看一个简单的例子。</p><p>假定物品的重量和价值已知，如表2-5所示，最大运载能力为10。采用贪心算法会得到怎样的结果？</p><center class="my_markdown"><b class="my_markdown">表2-5　物品清单</b></center><p>| 物品i | 1 | 2 | 3 | 4 | 5 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 3 | 4 | 6 | 10 | 7 |<br>| 价值v[i] | 15 | 16 | 18 | 25 | 14 |<br>| 性价比p[i] | 5 | 4 | 3 | 2.5 | 2 |</p><p>如果我们采用贪心算法，先装性价比高的物品，且物品不能分割，剩余容量如果无法再装入剩余的物品，不管还有没有运载能力，算法都会结束。那么我们选择的物品为 1和2，总价值为 31，而实际上还有 3 个剩余容量，但不足以装下剩余其他物品，因此得到的最大价值为31。但实际上我们如果选择物品2和3，正好达到运载能力，得到的最大价值为34。也就是说，在物品不可分割、没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。</p><p>想一想，为什么会这样呢？</p><p>物品可分割的装载问题我们称为 <strong>背包问题</strong> ，物品不可分割的装载问题我们称之为 <strong>0-1背包问题</strong> 。</p><p>在物品不可分割的情况下，即0-1背包问题，已经不具有贪心选择性质，原问题的整体最优解无法通过一系列局部最优的选择得到，因此这类问题得到的是近似解。如果一个问题不要求得到最优解，而只需要一个最优解的近似解，则不管该问题有没有贪心选择性质都可以使用贪心算法。</p><p>想一想，2.3节中加勒比海盗船问题为什么在没有装满的情况下，仍然是最优解，而0-1背包问题在没装满的情况下有可能只是最优解的近似解？</p><h3 id="2-4-高级钟点秘书——会议安排">2.4　高级钟点秘书——会议安排</h3><p>所谓“钟点秘书”，是指年轻白领女性利用工余时间为客户提供秘书服务，并按钟点收取酬金。</p><p>“钟点秘书”为客户提供有偿服务的方式一般是：采用电话、电传、上网等“遥控”式服务，或亲自到客户公司处理部分业务。其服务对象主要有三类：一是外地前来考察商务经营、项目投资的商人或政要人员，他们由于初来乍到，急需有经验和熟悉本地情况的秘书帮忙；二是前来开展短暂商务活动，或召开小型资讯发布会的国外客商；三是本地一些请不起长期秘书的企、事业单位。这些客户普遍认为：请“钟点秘书”，一则可免去专门租楼请人的大笔开销；二则可根据开展的商务活动请有某方面专长的可用人才；三则由于对方是临时雇用关系，工作效率往往比固定的秘书更高。据调查，在上海“钟点秘书”的行情日趋看好。对此，业内人士认为：为了便于管理，各大城市有必要组建若干家“钟点秘书服务公司”，通过会员制的形式，为众多客户提供规范、优良、全面的服务，这也是建设国际化大都市所必需的。</p><p>某跨国公司总裁正分身无术，为一大堆会议时间表焦头烂额，希望高级钟点秘书能做出合理的安排，能在有限的时间内召开更多的会议。</p><p><img src="https://source.drie.cn/qxsf-images/32.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-6　高级钟点秘书</b></center><h3 id="2-4-1-问题分析">2.4.1　问题分析</h3><p>这是一个典型的会议安排问题，会议安排的目的是能在有限的时间内召开更多的会议（任何两个会议不能同时进行）。在会议安排中，每个会议i都有起始时间b<sub class="my_markdown">i</sub>和结束时间e<sub class="my_markdown">i</sub>，且b<sub class="my_markdown">i</sub>&lt;e<sub class="my_markdown">i</sub>，即一个会议进行的时间为半开区间[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）。如果[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）与[b<sub class="my_markdown">j</sub>，e<sub class="my_markdown">j</sub>）均在“有限的时间内”，且不相交，则称会议i与会议j相容的。也就是说，当b<sub class="my_markdown">i</sub>≥e<sub class="my_markdown">j</sub>或b<sub class="my_markdown">j</sub>≥e<sub class="my_markdown">i</sub>时，会议i与会议j相容。会议安排问题要求在所给的会议集合中选出最大的相容活动子集，即尽可能在有限的时间内召开更多的会议。</p><p>在这个问题中，“有限的时间内（这段时间应该是连续的）”是其中的一个限制条件，也应该是有一个起始时间和一个结束时间（简单化，起始时间可以是会议最早开始的时间，结束时间可以是会议最晚结束的时间），任务就是实现召开更多的满足在这个“有限的时间内”等待安排的会议，会议时间表如表2-6所示。</p><center class="my_markdown"><b class="my_markdown">表2-6　会议时间表</b></center><p>| 会议i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间b<sub class="my_markdown">i</sub> | 8 | 9 | 10 | 11 | 13 | 14 | 15 | 17 | 18 | 16 |<br>| 结束时间e<sub class="my_markdown">i</sub> | 10 | 11 | 15 | 14 | 16 | 17 | 17 | 18 | 20 | 19 |</p><p>会议安排的时间段如图2-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/33.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-7　会议安排时间段</b></center><p>从图2-7中可以看出，{会议1，会议4，会议6，会议8，会议9}，{会议2，会议4，会议7，会议8，会议9}都是能安排最多的会议集合。</p><p>要让会议数最多，我们需要选择最多的不相交时间段。我们可以尝试贪心策略：</p><p>（1）每次从剩下未安排的会议中选择会议 <strong>具有最早开始时间且与已安排的会议相容</strong> 的会议安排，以增大时间资源的利用率。</p><p>（2）每次从剩下未安排的会议中选择 <strong>持续时间最短且与已安排的会议相容</strong> 的会议安排，这样可以安排更多一些的会议。</p><p>（3）每次从剩下未安排的会议中选择 <strong>具有最早结束时间且与已安排的会议相容</strong> 的会议安排，这样可以尽快安排下一个会议。</p><p>思考一下，如果选择最早开始时间，则如果会议持续时间很长，例如8点开始，却要持续12个小时，这样一天就只能安排一个会议；如果选择持续时间最短，则可能开始时间很晚，例如19点开始，20点结束，这样也只能安排一个会议，所以我们最好选择那些开始时间要早，而且持续时间短的会议，即最早开始时间+持续时间最短，就是 <strong>最早结束</strong> 时间。</p><p>因此采用第（3）种 <strong>贪心策略，每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排</strong> 。</p><h3 id="2-4-2-算法设计">2.4.2　算法设计</h3><p>（1）初始化：将n个会议的开始时间、结束时间存放在结构体数组中（想一想，为什么不用两个一维数组分别存储？），如果需要知道选中了哪些会议，还需要在结构体中增加会议编号，然后按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）；</p><p>（2）根据贪心策略就是选择第一个具有最早结束时间的会议，用last记录刚选中会议的结束时间；</p><p>（3）选择第一个会议之后，依次 <strong>从剩下未安排的会议中选择</strong> ，如果会议i开始时间大于等于最后一个选中的会议的结束时间last，那么会议i与已选中的会议相容，可以安排，更新last为刚选中会议的结束时间；否则，舍弃会议i，检查下一个会议是否可以安排。</p><h3 id="2-4-3-完美图解">2.4.3　完美图解</h3><h4 id="1．原始的会议时间表（见表2-7）：">1．原始的会议时间表（见表2-7）：</h4><center class="my_markdown"><b class="my_markdown">表2-7　原始会议时间表</b></center><p>| 会议num | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间beg | 3 | 1 | 5 | 2 | 5 | 3 | 8 | 6 | 8 | 12 |<br>| 结束时间end | 6 | 4 | 7 | 5 | 9 | 8 | 11 | 10 | 12 | 14 |</p><h4 id="2．排序后的会议时间表（见表2-8）：">2．排序后的会议时间表（见表2-8）：</h4><center class="my_markdown"><b class="my_markdown">表2-8　排序后的会议时间表</b></center><p>| 会议num | 2 | 4 | 1 | 3 | 6 | 5 | 8 | 7 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间beg | 1 | 2 | 3 | 5 | 3 | 5 | 6 | 8 | 8 | 12 |<br>| 结束时间end | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 14 |</p><h4 id="3．贪心选择过程">3．贪心选择过程</h4><p>（1）首先选择排序后的第一个会议即最早结束的会议（编号为2），用last记录最后一个被选中会议的结束时间，last=4。</p><p>（2）检查余下的会议，找到第一个开始时间大于等于 last（last=4）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-9所示。</p><center class="my_markdown"><b class="my_markdown">表2-9　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/34.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为3)，更新last为刚选中会议的结束时间last=7。</p><p>（3）检查余下的会议，找到第一个开始时间大于等于last（last=7）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-10所示。</p><center class="my_markdown"><b class="my_markdown">表2-10　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/35.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为 7)，更新 last 为刚选中会议的结束时间last=11。</p><p>（4）检查余下的会议，找到第一个开始时间大于等于last（last=11）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-11所示。</p><center class="my_markdown"><b class="my_markdown">表2-11　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/36.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为10)，更新last为刚选中会议的结束时间last=14；所有会议检查完毕，算法结束。如表2-12所示。</p><h4 id="4．构造最优解">4．构造最优解</h4><p>从贪心选择的结果，可以看出，被选中的会议编号为{2，3，7，10}，可以安排的会议数量最多为4，如表2-12所示。</p><center class="my_markdown"><b class="my_markdown">表2-12　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/37.jpg" alt="code"></p><h3 id="2-4-4-伪代码详解">2.4.4　伪代码详解</h3><p>（1）数据结构定义</p><p>以下C++程序代码中，结构体meet中定义了beg表示会议的开始时间，end表示会议的结束时间，会议meet的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">&#125; meet[<span class="number">1000</span>]；</span><br></pre></td></tr></table></figure><p>（2）对会议按照结束时间非递减排序</p><p>我们采用C++中自带的sort函数，自定义比较函数的办法，实现会议排序，按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.end==y.end)  <span class="comment">//结束时间相等时 </span></span><br><span class="line">        <span class="keyword">return</span> x.beg&gt;y.beg; <span class="comment">//按开始时间从大到小排序</span></span><br><span class="line">     <span class="keyword">return</span> x.end&lt;y.end; <span class="comment">//按结束时间从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(meet,meet+n,cmp);</span><br></pre></td></tr></table></figure><p>（3）会议安排问题的贪心算法求解</p><p>在会议按结束时间非递减排序的基础上，首先选中第一个会议，用last变量记录刚刚被选中会议的结束时间。下一个会议的开始时间与last比较，如果大于等于last，则选中。每次选中一个会议，更新last为最后一个被选中会议的结束时间，被选中的会议数ans加1；如果会议的开始时间不大于等于last，继续考查下一个会议，直到所有会议考查完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;     <span class="comment">//用来记录可以安排会议的个数，初始时选中了第一个会议</span></span><br><span class="line"><span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//last记录第一个会议的结束时间</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n; i++)   <span class="comment">//依次检查每个会议</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(meet[i].beg &gt; =last) </span><br><span class="line">    &#123;     <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">       ans++;</span><br><span class="line">       last = meet[i].end; <span class="comment">//更新last为最后一个选中会议的结束时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回可以安排的会议最大数</span></span><br></pre></td></tr></table></figure><p>上面介绍的程序中，只是返回了可以安排的会议最大数，而不知道安排了哪些会议，这显然是不满足需要的。我们可以改进一下，在会议结构体meet中添加会议编号num变量，选中会议时，显示选中了第几个会议。</p><h3 id="2-4-5-实战演练">2.4.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">     <span class="type">int</span> num;   <span class="comment">//记录会议的编号</span></span><br><span class="line">&#125;meet[<span class="number">1000</span>];    <span class="comment">//会议的最大个数为1000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">setMeet</span>&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">  private:</span><br><span class="line">    <span class="type">int</span> n,ans; <span class="comment">// n:会议总数 ans: 最大的安排会议总数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> s,e;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议总数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议的开始时间和结束时间，以空格分开：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">         meet[i].beg=s;</span><br><span class="line">         meet[i].end=e;</span><br><span class="line">         meet[i].num=i+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (x.end == y.end)</span><br><span class="line">           <span class="keyword">return</span> x.beg &gt; y.beg;</span><br><span class="line">     <span class="keyword">return</span> x.end &lt; y.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     sort(meet,meet+n,cmp);    <span class="comment">//对会议按结束时间排序</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;排完序的会议时间如下：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;会议编号&quot;</span>&lt;&lt;<span class="string">&quot;  开始时间 &quot;</span>&lt;&lt;<span class="string">&quot; 结束时间&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; meet[i].num&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;meet[i].beg &lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt; meet[i].end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-------------------------------------------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;选择的会议的过程：&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt; meet[<span class="number">0</span>].num&lt;&lt;<span class="string">&quot;个会议&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//选中了第一个会议</span></span><br><span class="line">     ans=<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//记录刚刚被选中会议的结束时间</span></span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(meet[i].beg&gt;=last)</span><br><span class="line">          &#123;            <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">             ans++;</span><br><span class="line">             last = meet[i].end;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt;meet[i].num&lt;&lt;<span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;最多可以安排&quot;</span> &lt;&lt;ans &lt;&lt; <span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setMeet sm;</span><br><span class="line">  sm.init();<span class="comment">//读入数据</span></span><br><span class="line">  sm.solve();<span class="comment">//贪心算法求解</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入会议总数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输入会议的开始时间和结束时间，以空格分开：</span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">排完序的会议时间如下：</span><br><span class="line">会议编号    开始时间    结束时间</span><br><span class="line">   <span class="number">2</span>           <span class="number">1</span>          <span class="number">4</span></span><br><span class="line">   <span class="number">4</span>           <span class="number">2</span>          <span class="number">5</span></span><br><span class="line">   <span class="number">1</span>           <span class="number">3</span>          <span class="number">6</span></span><br><span class="line">   <span class="number">3</span>           <span class="number">5</span>          <span class="number">7</span></span><br><span class="line">   <span class="number">6</span>           <span class="number">3</span>          <span class="number">8</span></span><br><span class="line">   <span class="number">5</span>           <span class="number">5</span>          <span class="number">9</span></span><br><span class="line">   <span class="number">8</span>           <span class="number">6</span>          <span class="number">10</span></span><br><span class="line">   <span class="number">7</span>           <span class="number">8</span>          <span class="number">11</span></span><br><span class="line">   <span class="number">9</span>           <span class="number">8</span>          <span class="number">12</span></span><br><span class="line">   <span class="number">10</span>          <span class="number">12</span>         <span class="number">14</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">选择的会议的过程：</span><br><span class="line">  选择第<span class="number">2</span>个会议</span><br><span class="line">  选择第<span class="number">3</span>个会议</span><br><span class="line">  选择第<span class="number">7</span>个会议</span><br><span class="line">  选择第<span class="number">10</span>个会议</span><br><span class="line">最多可以安排<span class="number">4</span>个会议</span><br></pre></td></tr></table></figure><p>使用上面贪心算法可得，选择的会议是第2、3、7、10个会议，输出最优值是4。</p><h3 id="2-4-6-算法解析及优化拓展">2.4.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4><p>（1）时间复杂度：在该算法中，问题的规模就是会议总个数n。显然，执行次数随问题规模的增大而变化。首先在成员函数setMeet::init()中，输入n个结构体数据。输入作为基本语句，显然，共执行n次。而后在调用成员函数setMeet::solve()中进行排序，易知sort排序函数的平均时间复杂度为O(nlogn)。随后进行选择会议，贡献最大的为if(meet[i].beg&gt;=last)语句，时间复杂度为O(n)，总时间复杂度为O(n +nlogn)= O(nlogn)。</p><p>（2）空间复杂度：在该算法中，meet[]结构体数组为输入数据，不计算在空间复杂度内。辅助空间有i、n、ans等变量，则该程序空间复杂度为常数阶，即O(1)。</p><h4 id="2．算法优化拓展-2">2．算法优化拓展</h4><p>想一想，你有没有更好的办法来处理此问题，比如有更小的算法时间复杂度？</p><h3 id="2-5-一场说走就走的旅行——最短路径">2.5　一场说走就走的旅行——最短路径</h3><p>有一天，孩子回来对我说：“妈妈，听说马尔代夫很不错，放假了我想去玩。”马尔代夫？我也想去！没有人不向往一场说走就走的旅行！“其实我想去的地方很多，呼伦贝尔大草原、玉龙雪山、布达拉宫、艾菲尔铁塔……”小孩子还说着他感兴趣的地方。于是我们拿出地图，标出想去的地点，然后计算最短路线，估算大约所需的时间，有了这张秘制地图，一场说走就走的旅行不是梦！</p><p>“哇，感觉我们像凡尔纳的《环游地球八十天》，好激动！可是老妈你也太out了，学计算机的最短路线你用手算？”</p><p>暴汗……，“小子你别牛，你知道怎么算？”</p><p>“呃，好像是叫什么迪科斯彻的人会算。”</p><p>哈哈，关键时刻还要老妈上场了！</p><p><img src="https://source.drie.cn/qxsf-images/38.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-8　一场说走就走的旅行</b></center><h3 id="2-5-1-问题分析">2.5.1　问题分析</h3><p>根据题目描述可知，这是一个求单源最短路径的问题。给定有向带权图<strong>G</strong> =（V，Ｅ），其中每条边的权是非负实数。此外，给定V中的一个顶点，称为源点。现在要计算从源到所有其他各顶点的最短路径长度，这里路径长度指路上各边的权之和。</p><p>如何求源点到其他各点的最短路径呢？</p><p>如图2-9所示，艾兹格•W•迪科斯彻（Edsger Wybe Dijkstra），荷兰人，计算机科学家。他早年钻研物理及数学，后转而研究计算学。他曾在1972年获得过素有“计算机科学界的诺贝尔奖”之称的图灵奖，与Donald Ervin Knuth并称为我们这个时代最伟大的计算机科学家。</p><p><img src="https://source.drie.cn/qxsf-images/39.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-9　艾兹格•W•迪科斯彻</b></center><h3 id="2-5-2-算法设计">2.5.2　算法设计</h3><p>Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径。</p><p>Dijkstra算法的基本思想是首先假定源点为u，顶点集合V被划分为两部分：集合S和 V−S。初始时 S 中仅含有源点 u，其中 S 中的顶点到源点的最短路径已经确定。集合V−S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V−S中的点的路径为特殊路径，并用数组dist[]记录当前每个顶点所对应的最短特殊路径长度。</p><p>Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径，将其连接的V−S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点之间的最短路径长度。</p><p>（1）数据结构。设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从源点u到顶点i有边，就令 <strong>map</strong>[u][i]等于&lt;u，i&gt;的权值，否则 <strong>map</strong>[u][i]=∞（无穷大）；采用一维数组 dist[i]来记录从源点到i顶点的最短路径长度；采用一维数组p[i]来记录最短路径上i顶点的前驱。</p><p>（2）初始化。令集合S={u}，对于集合V−S中的所有顶点x，初始化dist[i]=<strong>map</strong>[u][i]，如果源点u到顶点i有边相连，初始化p[i]=u，否则p[i]= −1。</p><p>（3）找最小。在集合V−S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t，即dist[t]=min（dist[j]|j属于V−S集合），则顶点t就是集合V−S中距离源点u最近的顶点。</p><p>（4）加入S战队。将顶点t加入集合S中，同时更新V−S。</p><p>（5）判结束。如果集合V−S为空，算法结束，否则转（6）。</p><p>（6）借东风。在（3）中已经找到了源点到t的最短路径，那么对集合V−S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dis[j]&gt;dist[t]+<strong>map</strong>[t][j]，则dist[j]=dist[t]+<strong>map</strong>[t][j]，记录顶点j的前驱为t，有p[j]= t，转（3）。</p><p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过数组p[]逆向找到最短路径上经过的城市。</p><h3 id="2-5-3-完美图解">2.5.3　完美图解</h3><p>现在我们有一个景点地图，如图2-10所示，假设从1号结点出发，求到其他各个结点的最短路径。</p><p><img src="https://source.drie.cn/qxsf-images/40.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-10　景点地图</b></center><p>算法步骤如下。</p><p>（1）数据结构</p><p>设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从顶点i到顶点j有边，则<strong>map</strong>[i][j]等于&lt;i，j&gt;的权值，否则<strong>map</strong>[i][j]=∞（无穷大），如图2-11所示。</p><p><img src="https://source.drie.cn/qxsf-images/41.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-11　邻接矩阵**map**[][]</b></center><p>（2）初始化</p><p>令集合S={1}，V−S={2，3，4，5}，对于集合V−S中的所有顶点x，初始化最短距离数组dist[i]=<strong>map</strong>[1][i]，dist[u]=0，如图2-12所示。如果源点1到顶点i有边相连，初始化前驱数组p[i]=1，否则p[i]= −1，如图2-13所示。</p><p><img src="https://source.drie.cn/qxsf-images/42.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-12　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/43.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-13　前驱数组p[]</b></center><p>（3）找最小</p><p>在集合V−S={2，3，4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-14所示。</p><p><img src="https://source.drie.cn/qxsf-images/44.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-14　最短距离数组dist[]</b></center><p>找到最小值为2，对应的结点t=2。</p><p>（4）加入S战队</p><p>将顶点t=2加入集合S中S={1，2}，同时更新V−S={3，4，5}，如图2-15所示。</p><p><img src="https://source.drie.cn/qxsf-images/45.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-15　景点地图</b></center><p>（5）借东风</p><p>刚刚找到了源点到t=2的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵都可以看出，2号结点的邻接点是3和4号结点，如图2-16所示。</p><p><img src="https://source.drie.cn/qxsf-images/46.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-16　邻接矩阵**map**[][]</b></center><p>先看3号结点能否借助2号走捷径：dist[2]+<strong>map</strong>[2][3]=2+2=4，而当前dist[3]=5&gt;4，因此可以走捷径即2—3，更新dist[3]=4，记录顶点3的前驱为2，即p[3]= 2。</p><p>再看4号结点能否借助2号走捷径：如果dist[2]+<strong>map</strong>[2][4]=2+6=8，而当前dist[4]=∞&gt;8，因此可以走捷径即2—4，更新dist[4]=8，记录顶点4的前驱为2，即p[4]= 2。</p><p>更新后如图2-17和图2-18所示。</p><p><img src="https://source.drie.cn/qxsf-images/47.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-17　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/48.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-18　前驱数组p[]</b></center><p>（6）找最小</p><p>在集合V−S={3，4，5}中，依照贪心策略来寻找dist[]具有最小值的顶点t，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-19所示。</p><p><img src="https://source.drie.cn/qxsf-images/49.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-19　最短距离数组dist[]</b></center><p>找到最小值为4，对应的结点t=3。</p><p>（7）加入S战队</p><p>将顶点t=3加入集合S中S={1，2，3}，同时更新V−S={4，5}，如图2-20所示。</p><p><img src="https://source.drie.cn/qxsf-images/50.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-20　景点地图</b></center><p>（8）借东风</p><p>刚刚找到了源点到t =3的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，3号结点的邻接点是4和5号结点。</p><p>先看4号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][4]=4+7=11，而当前dist[4]=8&lt;11，比当前路径还长，因此不更新。</p><p>再看5号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][5]=4+1=5，而当前dist[5]=∞&gt;5，因此可以走捷径即3—5，更新dist[5]=5，记录顶点5的前驱为3，即p[5]=3。</p><p>更新后如图2-21和图2-22所示。</p><p><img src="https://source.drie.cn/qxsf-images/51.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-21　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/52.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-22　前驱数组p[]</b></center><p>（9）找最小</p><p>在集合V−S={4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-23所示。</p><p><img src="https://source.drie.cn/qxsf-images/53.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-23　最短距离数组dist[]</b></center><p>找到最小值为5，对应的结点t=5。</p><p>（10）加入S战队</p><p>将顶点t=5加入集合S中S={1，2，3，5}，同时更新V−S={4}，如图2-24所示。</p><p><img src="https://source.drie.cn/qxsf-images/54.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-24　景点地图</b></center><p>（11）借东风</p><p>刚刚找到了源点到t =5的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，5号结点没有邻接点，因此不更新，如图2-25和图2-26所示。</p><p><img src="https://source.drie.cn/qxsf-images/56.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-26　前驱数组p[]</b></center><p>（12）找最小</p><p>在集合V−S={4}中，依照贪心策略来寻找dist[]最小的顶点t，只有一个顶点，所以很容易找到，如图2-27所示。</p><p><img src="https://source.drie.cn/qxsf-images/57.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-27　最短距离数组dist[]</b></center><p>找到最小值为8，对应的结点t=4。</p><p>（13）加入S战队</p><p>将顶点t加入集合S中S={1，2，3，5，4}，同时更新V−S={ }，如图2-28所示。</p><p><img src="https://source.drie.cn/qxsf-images/58.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-28　景点地图</b></center><p>（14）算法结束</p><p>V−S={ }为空时，算法停止。</p><p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过前驱数组p[]逆向找到最短路径上经过的城市，如图2-29所示。</p><p><img src="https://source.drie.cn/qxsf-images/59.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-29　前驱数组p[]</b></center><p>例如，p[5]=3，即5的前驱是3；p[3]=2，即3的前驱是2；p[2]=1，即2的前驱是1；p[1]= −1，1没有前驱，那么从源点1到5的最短路径为1—2—3—5。</p><h3 id="2-5-4-伪代码详解">2.5.4　伪代码详解</h3><p>（1）数据结构</p><p>n：城市顶点个数。m：城市间路线的条数。<strong>map</strong>[][]：地图对应的带权邻接矩阵。dist[]：记录源点u到某顶点的最短路径长度。p[]：记录源点到某顶点的最短路径上的该顶点的前一个顶点（前驱）。flag[]：flag[i]等于true，说明顶点i已经加入到集合S，否则顶点i属于集合V−S。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">//初始化城市的个数，可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">//无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br></pre></td></tr></table></figure><p>（2）初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点（t的出边相关联的顶点）的前驱为u：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[n];<span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则i属于集合V-S</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      dist[i] = <span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">      flag[i]=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">         p[i]=<span class="number">-1</span>;   <span class="comment">//说明源点u到顶点i无边相连，设置p[i]=-1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         p[i]=u;   <span class="comment">//说明源点u到顶点i有边相连，设置p[i]=u</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（3）初始化集合S，令集合S={u}，从源点到u的最短路径为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag[u]=<span class="literal">true</span>;   <span class="comment">//初始化集合S中，只有一个元素：源点 u </span></span><br><span class="line">dist[u] = <span class="number">0</span>;   <span class="comment">//初始化源点 u的最短路径为0，自己到自己的最短路径</span></span><br></pre></td></tr></table></figure><p>（4）找最小</p><p>在集合V−S中寻找距离源点u最近的顶点t，若找不到t，则跳出循环；否则，将t加入集合S。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF,t = u ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j ++) <span class="comment">//在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">  <span class="keyword">if</span>( !flag[j] &amp;&amp; dist[j] &lt; temp)</span><br><span class="line">  &#123;</span><br><span class="line">     t=j;   <span class="comment">//记录距离源点u最近的顶点</span></span><br><span class="line">     temp=dist[j];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(t == u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">flag[t] = <span class="literal">true</span>;      <span class="comment">//否则，将t加入集合S</span></span><br></pre></td></tr></table></figure><p>（5）借东风</p><p>考查集合V−S中源点u到t的邻接点j的距离，如果源点u经过t到达j的路径更短，则更新dist[j] =dist[t]+<strong>map</strong>[t][j]，即松弛操作，并记录j的前驱为t：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)  <span class="comment">//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">   <span class="keyword">if</span>(!flag[j] &amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF) <span class="comment">//!flag[j]表示j在V-S中，map[t][j]&lt;INF表示t与j邻接</span></span><br><span class="line">      <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j])) <span class="comment">//经过t到达j的路径更短</span></span><br><span class="line">      &#123;</span><br><span class="line">         dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">         p[j]=t; <span class="comment">//记录j的前驱为t </span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>重复（4）～（5），直到源点u到所有顶点的最短路径被找到。</p><h3 id="2-5-5-实战演练">2.5.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 初始化无穷大为10000000</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;<span class="comment">//n城市的个数，m为城市间路线的条数</span></span><br><span class="line"><span class="type">bool</span> flag[N]; <span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//①</span></span><br><span class="line">    &#123;</span><br><span class="line">     dist[i] =<span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">     flag[i]=<span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">        p[i]=<span class="number">-1</span>; <span class="comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        p[i]=u; <span class="comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span></span><br><span class="line">     &#125;</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    flag[u]=<span class="literal">true</span>;   <span class="comment">//初始时，集合S中只有一个元素：源点u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//②</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> temp = INF,t = u;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="comment">//③在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">           <span class="keyword">if</span>(!flag[j]&amp;&amp;dist[j]&lt;temp)</span><br><span class="line">             &#123;</span><br><span class="line">              t=j;</span><br><span class="line">              temp=dist[j];</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span>(t==u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">           flag[t]= <span class="literal">true</span>;  <span class="comment">//否则，将t加入集合</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//④//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">             <span class="keyword">if</span>(!flag[j]&amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF)<span class="comment">//!s[j]表示j在V-S中  </span></span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j]))</span><br><span class="line">                 &#123;</span><br><span class="line">                   dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">                   p[j]=t ;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="type">int</span> u,v,w,st;</span><br><span class="line">             system(<span class="string">&quot;color 0d&quot;</span>);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线以及距离：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span>(m--)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">               <span class="built_in">map</span>[u][v] =min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; st;</span><br><span class="line">             Dijkstra(st);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明：&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot; - &quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">if</span>(dist[i] == INF)</span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短距离为:&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">11</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">29</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">32</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">27</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">21</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">19</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">5</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">1</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">2</span> 最短距离为：<span class="number">24</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">3</span> 最短距离为：<span class="number">23</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">4</span> 最短距离为：<span class="number">30</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">5</span> 最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>想一想：因为我们在程序中使用p[]数组记录了最短路径上每一个结点的前驱，因此除了显示最短距离外，还可以显示最短路径上经过了哪些城市，可以增加一段程序逆向找到该最短路径上的城市序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findpath</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;s;<span class="comment">//利用C++自带的函数创建一个栈s，需要程序头部引入#include&lt;stack&gt;</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点为：&quot;</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    x=p[i];</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s.push(x);<span class="comment">//将前驱依次压入栈中</span></span><br><span class="line">      x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点到其他各顶点最短路径为：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="string">&quot;--&quot;</span>;<span class="comment">//依次取栈顶元素</span></span><br><span class="line">      s.pop();<span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;;最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在主函数末尾调用该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findpath(st);<span class="comment">//主函数中st为源点</span></span><br></pre></td></tr></table></figure><p>输出结果如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源点为：<span class="number">5</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>；最短距离为：<span class="number">8</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-2</span>；最短距离为：<span class="number">24</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>；最短距离为：<span class="number">23</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>-<span class="number">-4</span>；最短距离为：<span class="number">30</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>；最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2-5-6-算法解析及优化拓展">2.5.6　算法解析及优化拓展</h3><h4 id="1．算法时间复杂度">1．算法时间复杂度</h4><p>（1）时间复杂度：在Dijkstra算法描述中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大，当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n= n²，算法的时间复杂度为O(n²)。</p><p>（2）空间复杂度：由以上算法可以得出，实现该算法所需要的辅助空间包含为数组flag、变量i、j、t和temp所分配的空间，因此，空间复杂度为O(n)。</p><h4 id="2．算法优化拓展-3">2．算法优化拓展</h4><p>在for语句③中，即在集合V−S中寻找距离源点u最近的顶点t，其时间复杂度为O(n)，如果我们使用优先队列，则可以把时间复杂度降为O(log n)。那么如何使用优先队列呢？</p><p>（1）优先队列（见附录C）</p><p>（2）数据结构</p><p>在上面的例子中，我们使用了一维数组dist[t]来记录源点u到顶点t的最短路径长度。在此为了操作方便，我们使用结构体的形式来实现，定义一个结构体Node，里面包含两个成员：u为顶点，step为源点到顶点u的最短路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         v = a;   <span class="comment">//参数传递，v为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递，step为源点到顶点v的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123; </span><br><span class="line">         <span class="keyword">return</span> step &gt; a.step; <span class="comment">//重载 &lt;，step(源点到顶点v的最短路径)最小值优先</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的结构体中除了两个成员变量外，还有一个构造函数和运算符优先级重载，下面详细介绍其含义用途。</p><p>为什么要使用构造函数？</p><p>如果不使用构造函数也是可以的，只定义一般的结构体，里面包含两个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么在变量参数赋值时，需要这样赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node vs ; <span class="comment">//先定义一个Node结点类型变量</span></span><br><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>; <span class="comment">//分别对该变量的两个成员进行赋值</span></span><br></pre></td></tr></table></figure><p>采用构造函数的形式定义结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u = a;   <span class="comment">//参数传递u为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递step为源点到顶点u的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则变量参数赋值就可以直接通过参数传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">vs</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span><br></pre></td></tr></table></figure><p>上面语句等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>很明显通过构造函数的形式定义结构体，参数赋值更方便快捷，后面程序中会将结点压入优先队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 创建优先队列，最小值优先</span></span><br><span class="line">Q.push(Node(i,dist[i])); <span class="comment">//将结点Node压入优先队列Q</span></span><br><span class="line">                         <span class="comment">//参数i传递给顶点v， dist[i]传递给step</span></span><br></pre></td></tr></table></figure><p>（3）使用优先队列优化的Dijkstra算法源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],n,m;</span><br><span class="line"><span class="type">int</span> flag[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u=a;step=sp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123;  <span class="comment">// 重载 &lt;</span></span><br><span class="line">          <span class="keyword">return</span> step&gt;a.step;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">     <span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 优先队列优化</span></span><br><span class="line">     Q.push(Node(st,<span class="number">0</span>));</span><br><span class="line">     <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));<span class="comment">//初始化flag数组为0</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">       dist[i]=INF; <span class="comment">// 初始化所有距离为，无穷大</span></span><br><span class="line">     dist[st]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">     &#123;</span><br><span class="line">          Node it=Q.top();<span class="comment">//优先队列队头元素为最小值</span></span><br><span class="line">          Q.pop();</span><br><span class="line">          <span class="type">int</span> t=it.u;</span><br><span class="line">          <span class="keyword">if</span>(flag[t])<span class="comment">//说明已经找到了最短距离，该结点是队列里面的重复元素</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">          flag[t]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(!flag[i]&amp;&amp;<span class="built_in">map</span>[t][i]&lt;INF)&#123; <span class="comment">// 判断与当前点有关系的点，并且自己不能到自己</span></span><br><span class="line">                  <span class="keyword">if</span>(dist[i]&gt;dist[t]+<span class="built_in">map</span>[t][i])</span><br><span class="line">                  &#123;   <span class="comment">// 求距离当前点的每个点的最短距离,进行松弛操作</span></span><br><span class="line">                      dist[i]=dist[t]+<span class="built_in">map</span>[t][i];</span><br><span class="line">                      Q.push(Node(i,dist[i]));<span class="comment">// 把更新后的最短距离压入优先队列，注意：里面的元素有重复</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">          <span class="type">int</span> u,v,w,st;</span><br><span class="line">          system(<span class="string">&quot;color 0d&quot;</span>);<span class="comment">//设置背景及字体颜色</span></span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">             &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间u,v的路线以及距离w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">while</span>(m--)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">               <span class="built_in">map</span>[u][v]=min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;st;</span><br><span class="line">          Dijkstra(st);</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明:&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot;---&gt;&quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i;</span><br><span class="line">               <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">1</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">1</span> 最短距离为：<span class="number">0</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">2</span> 最短距离为：<span class="number">2</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">3</span> 最短距离为：<span class="number">3</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">4</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">5</span> 最短距离为：<span class="number">4</span></span><br></pre></td></tr></table></figure><p>在使用优先队列的 Dijkstra 算法描述中，while (!Q.empty())语句执行的次数为n，因为要弹出n个最小值队列才会空；Q.pop()语句的时间复杂度为logn，while语句中的for语句执行n次，for语句中的Q.push (Node(i,dist[i]))时间复杂度为logn。因此，总的语句的执行次数为n* logn+n²*logn，算法的时间复杂度为O(n²logn)。</p><p>貌似时间复杂度又变大了？</p><p>这是因为我们采用的邻接矩阵存储的，如果采用邻接表存储（见附录D），那么for语句④松弛操作就不用每次执行n次，而是执行t结点的邻接边数x，每个结点的邻接边加起来为边数E，那么总的时间复杂度为O(n<em>logn+E</em>logn)，如果E≥n，则时间复杂度为O(E*logn)。</p><p><strong>注意：</strong> 优先队列中尽管有重复的结点，但重复结点最坏是n<sup class="my_markdown">2</sup>，log n<sup class="my_markdown">2</sup>=2 log n，并不改变时间复杂度的数量级。</p><p>想一想，还能不能把时间复杂度再降低呢？如果我们使用斐波那契堆，那么松弛操作的时间复杂度O(1)，总的时间复杂度为O(n* logn+E)。</p><h3 id="2-6-神秘电报密码——哈夫曼编码">2.6　神秘电报密码——哈夫曼编码</h3><p>看过谍战电影《风声》的观众都会对影片中神奇的消息传递惊叹不已！吴志国大队长在受了残忍的“针刑”之后躺在手术台上唱空城计，变了音调，把消息传给了护士，顾晓梦在衣服上缝补了长短不一的针脚……那么，片中无处不在的摩尔斯码到底是什么？它又有着怎样的神秘力量呢？</p><p>摩尔斯电码（Morse code）由点dot（. ）、划dash（-）两种符号组成。它的基本原理是：把英文字母表中的字母、标点符号和空格按照出现的频率排序，然后用点和划的组合来代表这些字母、标点符号和空格，使频率最高的符号具有最短的点划组合。</p><p><img src="https://source.drie.cn/qxsf-images/60.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-30　神秘电报密码</b></center><h3 id="2-6-1-问题分析">2.6.1　问题分析</h3><p>我们先看一个生活中的例子：</p><p>有一群退休的老教授聚会，其中一个老教授带着刚会说话的漂亮小孙女，于是大家逗她：“你能猜猜我们多大了吗？猜对了有糖吃哦！”小女孩就开始猜：“你是1岁了吗？”，老教授摇摇头。“你是两岁了吗？”，老教授仍然摇摇头。“那一定是3岁了！”……大家哈哈大笑。或许我们都感觉到了小女孩的天真可爱，然而生活中的确有很多类似这样的判断。</p><p>曾经有这样一个C++设计题目：将一个班级的成绩从百分制转为等级制。一同学设计的程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">70</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">80</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在上面程序中，如果分数小于60，我们做1次判定即可；如果分数为60～70，需要判定2次；如果分数为70～80，需要判定3次；如果分数为80～90，需要判定4次；如果分数为90～100，需要判定5次。</p><p>这段程序貌似是没有任何问题，但是我们却犯了从1岁开始判断一个老教授年龄的错误，因为我们的考试成绩往往是呈正态分布的，如图2-31所示。</p><p><img src="https://source.drie.cn/qxsf-images/61.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-31　运行结果</b></center><p>也就是说，大多数（70%）人的成绩要判断3次或3次以上才能成功，假设班级人数为100人，则判定次数为：</p><p>100×10%×1+100×20%×2+100×40%×3+100×20%×4+100×10%×5=300（次）</p><p>如果我们改写程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">80</span>) </span><br><span class="line">   <span class="keyword">if</span> (score &lt;<span class="number">70</span>) </span><br><span class="line">       <span class="keyword">if</span> (score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>则判定次数为：</p><p>100×10%×3+100×20%×3+100×40%×2+100×20%×2+100×10%×2=230（次）</p><p>为什么会有这样大的差别呢？我们来看两种判断方式的树形图，如图2-32所示。</p><p><img src="https://source.drie.cn/qxsf-images/62.jpg" alt="code"><br><img src="https://source.drie.cn/qxsf-images/63.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-32　两种判断方式的树形图</b></center><p>从图2-32中我们可以看到，当频率高的分数越靠近树根（先判断）时，我们只用1次猜中的可能性越大。</p><p>再看五笔字型的编码方式：</p><p>我们在学习五笔时，需要背一级简码。所谓一级简码，就是指25个汉字，对应着25个按键，打1个字母键再加1个空格键就可打出来相应的字。为什么要这样设置呢？因为根据文字统计，这25个汉字是使用频率最高的。</p><p>五笔字根之一级简码：</p><p>G 一　F 地　D 在　 S 要　 A 工</p><p>H 上　J 是　K 中　 L 国　 M 同</p><p>T 和　R 的　E 有　 W 人　Q 我</p><p>Y 主　U 产　I 不　 O 为　 P 这</p><p>N 民　B 了　V 发　C 以　 X 经</p><p>通常的编码方法有固定长度编码和不等长度编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要<img class="my_markdown" src="https://source.drie.cn/qxsf-images/64.gif" style="width:47px;  height: 19px; "/>位。例如，3个不同的字符a、b、c，至少需要2位二进制数表示，a为00，b为01，c为10。如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。</p><p>不等长编码方法需要解决两个关键问题：</p><p>（1）编码尽可能短</p><p>我们可以让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。即 <strong>频率越高，编码越短</strong> 。</p><p>（2）不能有二义性</p><p>例如，ABCD四个字符如果编码如下。</p><p>A：0。B：1。C：01。D：10。</p><p>那么现在有一列数0110，该怎样翻译呢？是翻译为ABBA，ABD，CBA，还是CD？那么如何消除二义性呢？解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即 <strong>前缀码特性</strong> 。</p><p>1952年，数学家D.A.Huffman提出了根据字符在文件中出现的频率，用0、1的数字串表示各字符的最佳编码方式，称为哈夫曼（Huffman）编码。哈夫曼编码很好地解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是采用哈夫曼编码压缩的。</p><h3 id="2-6-2-算法设计">2.6.2　算法设计</h3><p>哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将所要编码的字符作为叶子结点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式，通过n−1次的“合并”运算后构造出的一棵树，核心思想是权值越大的叶子离根越近。</p><p>哈夫曼算法采取的 <strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong> ，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中，求解步骤如下。</p><p>（1）确定合适的数据结构。编写程序前需要考虑的情况有：</p><ul><li>哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n−1个结点（n−1次的“合并”，每次产生一个新结点），</li><li>构成哈夫曼树后，为求编码，需从叶子结点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值、双亲、左孩子、右孩子和结点的信息。</li></ul><p>（2）初始化。构造n棵结点为n个字符的单结点树集合T={t<sub class="my_markdown">1</sub>，t<sub>2</sub>，t<sub>3</sub>，…，t<sub class="my_markdown">n</sub>}，每棵树只有一个带权的根结点，权值为该字符的使用频率。</p><p>（3）如果T中只剩下一棵树，则哈夫曼树构造成功，跳到步骤（6）。否则，从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左孩子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p><p>（4）从集合T中删去t<sub class="my_markdown">i</sub>，t<sub class="my_markdown">j</sub>，加入z<sub class="my_markdown">k</sub>。</p><p>（5）重复以上（3）～（4）步。</p><p>（6）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码。算法结束。</p><h3 id="2-6-3-完美图解">2.6.3　完美图解</h3><p>假设我们现在有一些字符和它们的使用频率（见表2-13），如何得到它们的哈夫曼编码呢？</p><center class="my_markdown"><b class="my_markdown">表2-13　字符频率</b></center><p>| 字符 | a | b | c | d | e | f |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 频率 | 0.05 | 0.32 | 0.18 | 0.07 | 0.25 | 0.13 |</p><p>我们可以把每一个字符作为叶子，它们对应的频率作为其权值，为了比较大小方便，可以对其同时扩大100倍，得到a～f分别对应5、32、18、7、25、13。</p><p>（1）初始化。构造n棵结点为n个字符的单结点树集合T={a，b，c，d，e，f}，如图2-33所示。</p><p><img src="https://source.drie.cn/qxsf-images/65.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-33　叶子结点</b></center><p>（2）从集合T中取出没有双亲的且权值最小的两棵树a和d，将它们合并成一棵新树t<sub class="my_markdown">1</sub>，新树的左孩子为a，右孩子为d，新树的权值为a和d的权值之和为12。新树的树根t<sub class="my_markdown">1</sub>加入集合T，a和d从集合T中删除，如图2-34所示。</p><p><img src="https://source.drie.cn/qxsf-images/66.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-34　构建新树</b></center><p>（3）从集合T中取出没有双亲的且权值最小的两棵树t<sub class="my_markdown">1</sub>和f，将它们合并成一棵新树t<sub>2</sub>，新树的左孩子为t<sub class="my_markdown">1</sub>，右孩子为f，新树的权值为t<sub class="my_markdown">1</sub>和f的权值之和为25。新树的树根t<sub>2</sub>加入集合T，将t<sub class="my_markdown">1</sub>和f从集合T中删除，如图2-35所示。</p><p><img src="https://source.drie.cn/qxsf-images/67.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-35　构建新树</b></center><p>（4）从集合T中取出没有双亲且权值最小的两棵树c和e，将它们合并成一棵新树t<sub class="my_markdown">3</sub>，新树的左孩子为c，右孩子为e，新树的权值为c和e的权值之和为43。新树的树根t<sub class="my_markdown">3</sub>加入集合T，将c和e从集合T中删除，如图2-36所示。</p><p><img src="https://source.drie.cn/qxsf-images/68.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-36　构建新树</b></center><p>（5）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">2</sub>和b，将它们合并成一棵新树t<sub>4</sub>，新树的左孩子为t<sub class="my_markdown">2</sub>，右孩子为b，新树的权值为t<sub class="my_markdown">2</sub>和b的权值之和为57。新树的树根t<sub>4</sub>加入集合T，将t<sub class="my_markdown">2</sub>和b从集合T中删除，如图2-37所示。</p><p><img src="https://source.drie.cn/qxsf-images/69.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-37　构建新树</b></center><p>（6）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">3</sub>和t<sub>4</sub>，将它们合并成一棵新树t<sub>5</sub>，新树的左孩子为t<sub>4</sub>，右孩子为t<sub class="my_markdown">3</sub>，新树的权值为t<sub class="my_markdown">3</sub>和t<sub>4</sub>的权值之和为 100。新树的树根t<sub>5</sub>加入集合T，将t<sub class="my_markdown">3</sub>和t<sub>4</sub>从集合T中删除，如图 2-38所示。</p><p><img src="https://source.drie.cn/qxsf-images/70.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-38　哈夫曼树</b></center><p>（7）T中只剩下一棵树，哈夫曼树构造成功。</p><p>（8）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码，如图2-39所示。</p><p><img src="https://source.drie.cn/qxsf-images/71.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-39　哈夫曼编码</b></center><h3 id="2-6-4-伪代码详解">2.6.4　伪代码详解</h3><p>在构造哈夫曼树的过程中，首先给每个结点的双亲、左孩子、右孩子初始化为−1，找出所有结点中双亲为−1、权值最小的两个结点t<sub class="my_markdown">1</sub>、t<sub>2</sub>，并合并为一棵二叉树，更新信息（双亲结点的权值为t<sub class="my_markdown">1</sub>、t<sub>2</sub>权值之和，其左孩子为权值最小的结点t<sub class="my_markdown">1</sub>，右孩子为次小的结点t<sub>2</sub>，t<sub class="my_markdown">1</sub>、t<sub>2</sub>的双亲为双亲结点的编号）。重复此过程，构造一棵哈夫曼树。</p><p>（1）数据结构</p><p>每个结点的结构包括权值、双亲、左孩子、右孩子、结点字符信息这 5 个域。如图 2-40所示，定义为结构体形式，定义结点结构体HnodeType：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">double</span> weight; <span class="comment">//权值</span></span><br><span class="line">     <span class="type">int</span> parent;  <span class="comment">//双亲</span></span><br><span class="line">     <span class="type">int</span> lchild;  <span class="comment">//左孩子</span></span><br><span class="line">     <span class="type">int</span> rchild;  <span class="comment">//右孩子</span></span><br><span class="line">     <span class="type">char</span> value; <span class="comment">//该节点表示的字符</span></span><br><span class="line">&#125; HNodeType;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/72.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-40　结点结构体</b></center><p>在编码结构体中，bit[]存放结点的编码，start 记录编码开始下标，逆向译码（从叶子到根，想一想为什么不从根到叶子呢？）。存储时，start从n−1开始依次递减，从后向前存储；读取时，从start+1开始到n−1，从前向后输出，即为该字符的编码。如图2-41所示。</p><p><img src="https://source.drie.cn/qxsf-images/73.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-41　编码数组</b></center><p>编码结构体HcodeType：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> bit[MAXBIT]; <span class="comment">//存储编码的数组</span></span><br><span class="line">     <span class="type">int</span> start;       <span class="comment">//编码开始下标</span></span><br><span class="line">&#125; HCodeType;          <span class="comment">/* 编码结构体 */</span></span><br></pre></td></tr></table></figure><p>（2）初始化</p><p>初始化存放哈夫曼树数组HuffNode[]中的结点（见表2-14）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">     HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">     HuffNode[i].parent =<span class="number">-1</span>; <span class="comment">//双亲</span></span><br><span class="line">     HuffNode[i].lchild =<span class="number">-1</span>; <span class="comment">//左孩子</span></span><br><span class="line">     HuffNode[i].rchild =<span class="number">-1</span>; <span class="comment">//右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center class="my_markdown"><b class="my_markdown">表2-14　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/74.jpg" alt="code"><br>输入n个叶子结点的字符及权值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）循环构造Huffman树</p><p>从集合T中取出双亲为−1且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左儿子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> i, j, x1, x2; <span class="comment">//x1、x2为两个最小权值结点的序号。</span></span><br><span class="line">    <span class="type">double</span> m1,m2; <span class="comment">//m1、m2为两个最小权值结点的权值。</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">         m1=m2=MAXVALUE;  <span class="comment">//初始化为最大值</span></span><br><span class="line">         x1=x2=<span class="number">-1</span>;  <span class="comment">//初始化为-1</span></span><br><span class="line">         <span class="comment">//找出所有结点中权值最小、无双亲结点的两个结点</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2 = m1;</span><br><span class="line">                   x2 = x1;</span><br><span class="line">                   m1 = HuffNode[j].weight;</span><br><span class="line">                   x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2=HuffNode[j].weight;</span><br><span class="line">                   x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 更新新树信息 */</span></span><br><span class="line">         HuffNode[x1].parent = n+i; <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[x2].parent = n+i; <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[n+i].weight =m1+m2; <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">         HuffNode[n+i].lchild = x1; <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">         HuffNode[n+i].rchild = x2; <span class="comment">//新结点n+i的右孩子为x2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><p>（1）i=0时，j=0；j&lt;6；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">0</span>   x2=<span class="number">3</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">5</span>  m2=<span class="number">7</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">0</span>].parent = <span class="number">6</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">3</span>].parent = <span class="number">6</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].weight =<span class="number">12</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">6</span>].lchild = <span class="number">0</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">6</span>].rchild = <span class="number">3</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-15所示。</p><center class="my_markdown"><b class="my_markdown">表2-15　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/75.jpg" alt="code"><br>对应的哈夫曼树如图2-42所示。</p><p><img src="https://source.drie.cn/qxsf-images/76.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-42　哈夫曼树生成过程</b></center><p>（2）i=1时，j=0；j&lt;7；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">6</span>    x2=<span class="number">5</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">12</span>  m2=<span class="number">13</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">5</span>].parent = <span class="number">7</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].parent = <span class="number">7</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">7</span>].weight =<span class="number">25</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">7</span>].lchild = <span class="number">6</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">7</span>].rchild = <span class="number">5</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-16所示。</p><center class="my_markdown"><b class="my_markdown">表2-16　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/77.jpg" alt="code"><br>对应的哈夫曼树如图2-43所示。</p><p><img src="https://source.drie.cn/qxsf-images/78.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-43　哈夫曼树生成过程</b></center><p>（3）i=2时，j=0；j&lt;8；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">2</span>    x2=<span class="number">4</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">18</span>  m2=<span class="number">25</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">2</span>].parent = <span class="number">8</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">4</span>].parent = <span class="number">8</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">43</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">2</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">4</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-17所示。</p><center class="my_markdown"><b class="my_markdown">表2-17　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/79.jpg" alt="code"><br>对应的哈夫曼树如图2-44所示。</p><p><img src="https://source.drie.cn/qxsf-images/80.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-44　哈夫曼树生成过程</b></center><p>（4）i=3时，j=0；j&lt;9；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">7</span>    x2=<span class="number">1</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">25</span>  m2=<span class="number">32</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">7</span>].parent = <span class="number">9</span>;    <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">1</span>].parent = <span class="number">9</span>;     <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">57</span>;     <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">7</span>;     <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">1</span>;     <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-18所示。</p><center class="my_markdown"><b class="my_markdown">表2-18　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/81.jpg" alt="code"><br>对应的哈夫曼树如图2-45所示。</p><p><img src="https://source.drie.cn/qxsf-images/82.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-45　哈夫曼树生成过程</b></center><p>（5）i=4时，j=0；j&lt;10；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">8</span>    x2=<span class="number">9</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">43</span>  m2=<span class="number">57</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">8</span>].parent = <span class="number">10</span>;  <span class="comment">//x1的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">9</span>].parent =<span class="number">10</span>;   <span class="comment">//x2的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">10</span>].weight =<span class="number">100</span>;  <span class="comment">//新结点权值为两个最小权值之和m1+ m2</span></span><br><span class="line">HuffNode[<span class="number">10</span>].lchild = <span class="number">8</span>; <span class="comment">//新结点编号n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">10</span>].rchild = <span class="number">9</span>; <span class="comment">//新结点编号n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-19所示。</p><center class="my_markdown"><b class="my_markdown">表2-19　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/83.jpg" alt="code"><br>对应的哈夫曼树如图2-46所示。</p><p><img src="https://source.drie.cn/qxsf-images/84.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-46　哈夫曼树生成过程</b></center><p>（6）输出哈夫曼编码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">   &#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">          cd.start = n<span class="number">-1</span>;</span><br><span class="line">          c = i;  <span class="comment">//i为叶子结点编号</span></span><br><span class="line">          p = HuffNode[c].parent;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(HuffNode[p].lchild == c)&#123;</span><br><span class="line">                  cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">              cd.start--;         <span class="comment">/* start向前移动一位 */</span></span><br><span class="line">              c = p;              <span class="comment">/* c,p变量上移，准备下一循环 */</span></span><br><span class="line">              p = HuffNode[c].parent;    </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">          <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">              HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">          HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：哈夫曼编码数组如图2-47所示。</p><p><img src="https://source.drie.cn/qxsf-images/85.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-47　哈夫曼编码数组</b></center><p>（1）i=0时，c=0；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd.start = n<span class="number">-1</span>=<span class="number">5</span>;</span><br><span class="line">p = HuffNode[<span class="number">0</span>].parent=<span class="number">6</span>;<span class="comment">//从哈夫曼树建成后的表HuffNode[]中读出</span></span><br><span class="line">                         <span class="comment">//p指向0号结点的父亲6号</span></span><br></pre></td></tr></table></figure><p>构建完成的哈夫曼树数组如表2-20所示。</p><center class="my_markdown"><b class="my_markdown">表2-20　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/86.jpg" alt="code"><br>如果p != −1，那么从表HuffNode[]中读出6号结点的左孩子和右孩子，判断0号结点是它的左孩子还是右孩子，如果是左孩子编码为0；如果是右孩子编码为1。</p><p>从表2-20可以看出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HuffNode[<span class="number">6</span>].lchild=<span class="number">0</span>;<span class="comment">//0号结点是其父亲6号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">5</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">4</span>; <span class="comment">/* start向前移动一位*/</span></span><br></pre></td></tr></table></figure><p>哈夫曼编码树如图2-48所示，哈夫曼编码数组如图2-49所示。</p><p><img src="https://source.drie.cn/qxsf-images/87.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-48　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/88.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-49　哈夫曼编码数组</b></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = p=<span class="number">6</span>;                      <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">6</span>].parent=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>c、p变量上移后如图2-50所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">7</span>].lchild=<span class="number">6</span>;<span class="comment">//6号结点是其父亲7号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">4</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">3</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">7</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">7</span>].parent=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/89.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-50　哈夫曼编码树</b></center><p>哈夫曼编码树如图2-51所示，哈夫曼编码数组如图2-52所示。</p><p><img src="https://source.drie.cn/qxsf-images/90.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-51　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/91.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-52　哈夫曼编码数组</b></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">9</span>].lchild=<span class="number">7</span>;<span class="comment">//7号结点是其父亲9号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">2</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">9</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">9</span>].parent=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>哈夫曼编码树如图2-53所示，哈夫曼编码数组如图2-54所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">10</span>].lchild!=<span class="number">9</span>;<span class="comment">//9号结点不是其父亲10号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//编码为1</span></span><br><span class="line">cd.start--=<span class="number">1</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">10</span>;            <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">10</span>].parent=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/92.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-53　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/93.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-54　哈夫曼编码数组</b></center><p>哈夫曼编码树如图2-55所示，哈夫曼编码数组如图2-56所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">-1</span>;该叶子结点编码结束。</span><br><span class="line"><span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">   <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">   HuffCode[i].start = cd.start;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/94.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-55　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/95.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-56　哈夫曼编码数组</b></center><p>HuffCode[]数组如图2-57所示。</p><p><img src="https://source.drie.cn/qxsf-images/96.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-57　哈夫曼编码HuffCode[]数组</b></center><p>注意：图中的箭头不表示指针。</p><h3 id="2-6-5-实战演练">2.6.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBIT    100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE  10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEAF   30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNODE   MAXLEAF*2 -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> lchild;</span><br><span class="line">    <span class="type">int</span> rchild;</span><br><span class="line">    <span class="type">char</span> value;</span><br><span class="line">&#125; HNodeType;        <span class="comment">/* 结点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit[MAXBIT];</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">&#125; HCodeType;        <span class="comment">/* 编码结构体 */</span></span><br><span class="line">HNodeType HuffNode[MAXNODE]; <span class="comment">/* 定义一个结点结构体数组 */</span></span><br><span class="line">HCodeType HuffCode[MAXLEAF];<span class="comment">/* 定义一个编码结构体数组*/</span></span><br><span class="line"><span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanTree</span> <span class="params">(HNodeType HuffNode[MAXNODE],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，</span></span><br><span class="line"><span class="comment">       x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> i, j, x1, x2;</span><br><span class="line">    <span class="type">double</span> m1,m2;</span><br><span class="line">    <span class="comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">         HuffNode[i].parent =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].lchild =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].rchild =<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输入 n 个叶子结点的权值 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 构造 Huffman 树 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;<span class="comment">//执行n-1次合并</span></span><br><span class="line">         m1=m2=MAXVALUE;</span><br><span class="line">         <span class="comment">/* m1、m2中存放两个无父结点且结点权值最小的两个结点 */</span></span><br><span class="line">         x1=x2=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">/* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 */</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2 = m1;</span><br><span class="line">                  x2 = x1;</span><br><span class="line">                  m1 = HuffNode[j].weight;</span><br><span class="line">                  x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2=HuffNode[j].weight;</span><br><span class="line">                  x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 设置找到的两个子结点 x1、x2 的父结点信息 */</span></span><br><span class="line">         HuffNode[x1].parent  = n+i;</span><br><span class="line">         HuffNode[x2].parent  = n+i;</span><br><span class="line">         HuffNode[n+i].weight = m1+m2;</span><br><span class="line">         HuffNode[n+i].lchild = x1;</span><br><span class="line">         HuffNode[n+i].rchild = x2;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x1.weight and x2.weight in round &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x1]. weight&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x2].weight&lt;&lt;<span class="built_in">endl</span>; <span class="comment">/* 用于测试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cd.start = n<span class="number">-1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">        p = HuffNode[c].parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(HuffNode[p].lchild == c)</span><br><span class="line">                cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">            cd.start--;        <span class="comment">/* 求编码的低一位 */</span></span><br><span class="line">            c = p;</span><br><span class="line">            p = HuffNode[c].parent;    <span class="comment">/* 设置下一循环条件 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">        <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">           HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">        HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    HuffmanTree (HuffNode, n);  <span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line">    HuffmanCode(HuffCode, n);  <span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line">    <span class="comment">/* 输出已保存好的所有存在编码的哈夫曼编码 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;HuffNode[i].value&lt;&lt;<span class="string">&quot;: Huffman code is: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=HuffCode[i].start+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;HuffCode[i].bit[j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Please input n：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">1</span></span><br><span class="line">a <span class="number">0.05</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">2</span></span><br><span class="line">b <span class="number">0.32</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">3</span></span><br><span class="line">c <span class="number">0.18</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">4</span></span><br><span class="line">d <span class="number">0.07</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">5</span></span><br><span class="line">e <span class="number">0.25</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">6</span></span><br><span class="line">f <span class="number">0.13</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x1.weight and x2.weight in round <span class="number">1</span>      <span class="number">0.05</span>    <span class="number">0.07</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">2</span>      <span class="number">0.12</span>    <span class="number">0.13</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">3</span>      <span class="number">0.18</span>    <span class="number">0.25</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">4</span>      <span class="number">0.25</span>    <span class="number">0.32</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">5</span>      <span class="number">0.43</span>    <span class="number">0.57</span></span><br><span class="line">a: Huffman code is: <span class="number">1000</span></span><br><span class="line">b: Huffman code is: <span class="number">11</span></span><br><span class="line">c: Huffman code is: <span class="number">00</span></span><br><span class="line">d: Huffman code is: <span class="number">1001</span></span><br><span class="line">e: Huffman code is: <span class="number">01</span></span><br><span class="line">f: Huffman code is: <span class="number">101</span></span><br></pre></td></tr></table></figure><h3 id="2-6-6-算法解析及优化拓展">2.6.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以看出，在函数HuffmanTree()中，if (HuffNode[j].weight&lt;m1&amp;&amp; HuffNode[j].parent==−1)为基本语句，外层i与j组成双层循环：</p><p>i=0时，该语句执行n次；</p><p>i=1时，该语句执行n+1次；</p><p>i=2时，该语句执行n+2次；</p><p>……</p><p>i=n−2时，该语句执行n+n−2次；</p><p>则基本语句共执行n+（n+1）+（n+2）+…+（n+（n−2））=（n−1）*（3n−2）/2次（等差数列）；在函数HuffmanCode()中，编码和输出编码时间复杂度都接近n<sup class="my_markdown">2</sup>；则该算法时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：所需存储空间为结点结构体数组与编码结构体数组，哈夫曼树数组 HuffNode[]中的结点为n个，每个结点包含bit[MAXBIT]和start两个域，则该算法空间复杂度为O( n* MAXBIT)。</p><h4 id="2．算法优化拓展-4">2．算法优化拓展</h4><p>该算法可以从两个方面优化：</p><p>（1）函数HuffmanTree()中找两个权值最小结点时使用优先队列，时间复杂度为logn，执行n−1次，总时间复杂度为O( n logn)。</p><p>（2）函数HuffmanCode()中，哈夫曼编码数组HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度为实际的编码长度，这样可以大大节省空间。</p><h3 id="2-7-沟通无限校园网——最小生成树">2.7　沟通无限校园网——最小生成树</h3><p>校园网是为学校师生提供资源共享、信息交流和协同工作的计算机网络。校园网是一个宽带、具有交互功能和专业性很强的局域网络。如果一所学校包括多个学院及部门，也可以形成多个局域网络，并通过有线或无线方式连接起来。原来的网络系统只局限于以学院、图书馆为单位的局域网，不能形成集中管理以及各种资源的共享，个别学院还远离大学本部，这些情况严重地阻碍了整个学校的网络化需求。现在需要设计网络电缆布线，将各个单位的局域网络连通起来，如何设计能够使费用最少呢？</p><p><img src="https://source.drie.cn/qxsf-images/97.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-58　校园网络</b></center><h3 id="2-7-1-问题分析">2.7.1　问题分析</h3><p>某学校下设10个学院，3个研究所，1个大型图书馆，4个实验室。其中，1～10号节点代表10个学院，11～13号节点代表3个研究所，14号节点代表图书馆，15～18号节点代表4个实验室。该问题用无向连通图<strong>G</strong> =（V，E）来表示通信网络，V表示顶点集，E表示边集。把各个单位抽象为图中的顶点，顶点与顶点之间的边表示单位之间的通信网络，边的权值表示布线的费用。如果两个节点之间没有连线，代表这两个单位之间不能布线，费用为无穷大。如图2-59所示。</p><p><img src="https://source.drie.cn/qxsf-images/98.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-59　校园网连通图</b></center><p>那么我们如何设计网络电缆布线，将各个单位连通起来，并且费用最少呢？</p><p>对于n个顶点的连通图，只需n−1条边就可以使这个图连通，n−1条边要想保证图连通，就必须不含回路，所以我们只需要找出n−1条权值最小且无回路的边即可。</p><p>需要说明几个概念。</p><p>（1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图。</p><p>（2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图。</p><p>（3）生成树：如果生成子图恰好是一棵树，则称为生成树。</p><p>（4）最小生成树：权值之和最小的生成树，则称为最小生成树。</p><p>本题就是最小生成树求解问题。</p><h3 id="2-7-2-算法设计">2.7.2　算法设计</h3><p>找出n−1条权值最小的边很容易，那么怎么保证无回路呢?</p><p>如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法—— <strong>避圈法</strong> 。在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。</p><p>首先任选一个结点，例如1号结点，把它放在集合U中，U={1}，那么剩下的结点即V−U={2，3，4，5，6，7}，V是图的所有顶点集合。如图2-60所示。</p><p><img src="https://source.drie.cn/qxsf-images/99.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-60　最小生成树求解过程</b></center><p>现在只需在连接两个集合（V和V−U）的边中看哪一条边权值最小，把权值最小的边关联的结点加入到集合U。从图2-68可以看出，连接两个集合的3条边中，结点1到结点2的边权值最小，选中此条边，把2号结点加入U集合U={1，2}，V−U={3，4，5，6，7}。</p><p>再从连接两个集合（V和V−U）的边中选择一条权值最小的边。从图2-61可以看出，连接两个集合的4条边中，结点2到结点7的边权值最小，选中此条边，把7号结点加入U集合U={1，2，7}，V−U={3，4，5，6}。</p><p><img src="https://source.drie.cn/qxsf-images/100.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-61　最小生成树求解过程</b></center><p>如此下去，直到U=V结束，选中的边和所有的结点组成的图就是最小生成树。</p><p>是不是非常简单啊？</p><p>这就是Prim算法，1957年由美国计算机科学家Robert C.Prim发现的。那么如何用算法来实现呢？</p><p>首先，令U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，TE={}。u<sub class="my_markdown">0</sub>可以是任何一个结点，因为最小生成树包含所有结点，所以从哪个结点出发都可以得到最小生成树，不影响最终结果。TE为选中的边集。</p><p>然后，做如下 <strong>贪心选择</strong> ：选取连接U和V−U的所有边中的最短边，即满足条件i∈U，j∈V−U，且边（i，j）是连接U和V−U的所有边中的最短边，即该边的权值最小。</p><p>然后，将顶点j加入集合U，边（i，j）加入TE。继续上面的贪心选择一直进行到U=V为止，此时，选取到的所有边恰好构成图<strong>G</strong>的一棵最小生成树T。</p><p>算法设计及步骤如下。</p><p>步骤1：确定合适的数据结构。设置带权邻接矩阵<strong>C</strong>存储图<strong>G</strong>，如果图<strong>G</strong>中存在边（u，x），令<strong>C</strong>[u][x]等于边（u，x）上的权值，否则，<strong>C</strong>[u][x]=∞；bool数组s[]，如果s[i]=true，说明顶点i已加入集合U。</p><p>如图2-62所示，直观地看图很容易找出 U 集合到 V−U集合的边中哪条边是最小的，但是程序中如果穷举这些边，再找最小值就太麻烦了，那怎么办呢？</p><p><img src="https://source.drie.cn/qxsf-images/101.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-62　最小生成树求解过程</b></center><p>可以通过设置两个数组巧妙地解决这个问题，closest[j]表示V−U中的顶点j到集合U中的最邻近点，lowcost[j]表示V−U中的顶点j到集合U中的最邻近点的边值，即边（j,closest[j]）的权值。</p><p>例如，在图2-62中，7号结点到U集合中的最邻近点是2，closest[7]=2，如图2-63所示。7号结点到最邻近点2的边值为1，即边（2，7）的权值，记为lowcost[7]=1，如图2-64所示。</p><p><img src="https://source.drie.cn/qxsf-images/102.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-63　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/103.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-64　lowcost[]数组</b></center><p>只需要在V−U集合中找lowcost[]值最小的顶点即可。</p><p>步骤2：初始化。令集合U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，并初始化数组closest[]、lowcost[]和s[]。</p><p>步骤3：在V−U集合中找lowcost值最小的顶点t，即lowcost[t]=min{lowcost[j]|j∈V−U}，满足该公式的顶点t就是集合V−U中连接集合U的最邻近点。</p><p>步骤4：将顶点t加入集合U。</p><p>步骤5：如果集合V−U，算法结束，否则，转步骤6。</p><p>步骤6：对集合V−U中的所有顶点j，更新其lowcost[]和closest[]。更新公式：if（<strong>C</strong>[t] [j]&lt;lowcost [j] ) { lowcost [j]= <strong>C</strong> [t] [j]; closest [j] = t; }，转步骤3。</p><p>按照上述步骤，最终可以得到一棵权值之和最小的生成树。</p><h3 id="2-7-3-完美图解">2.7.3　完美图解</h3><p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-65所示。</p><p><img src="https://source.drie.cn/qxsf-images/104.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-65　无向连通带权图**G**</b></center><p>（1）数据结构</p><p>设置地图的带权邻接矩阵为<strong>C</strong>[][]，即如果从顶点i到顶点j有边，就让<strong>C</strong>[i][j]=&lt;i，j&gt;的权值，否则<strong>C</strong>[i][j]=∞（无穷大），如图2-66所示。</p><p><img src="https://source.drie.cn/qxsf-images/105.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-66　邻接矩阵**C**[ ][ ]</b></center><p>（2）初始化</p><p>假设u<sub class="my_markdown">0</sub>=1；令集合U={1}，V−U={2，3，4，5，6，7}，TE={}，s[1]=true，初始化数组closest[]：除了1号结点外其余结点均为1，表示V−U中的顶点到集合U的最临近点均为1，如图2-67所示。lowcost[]：1号结点到V−U中的顶点的边值，即读取邻接矩阵第1行，如图2-68所示。</p><p><img src="https://source.drie.cn/qxsf-images/106.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-67　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/107.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-68　lowcost[]数组</b></center><p>初始化后如图2-69所示。</p><p><img src="https://source.drie.cn/qxsf-images/108.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-69　最小生成树求解过程</b></center><p>（3）找最小</p><p>在集合V−U={2，3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-70所示。</p><p><img src="https://source.drie.cn/qxsf-images/109.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-70　lowcost[]数组</b></center><p>找到最小值为23，对应的结点t=2。</p><p>选中的边和结点如图2-71所示。</p><p><img src="https://source.drie.cn/qxsf-images/110.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-71　最小生成树求解过程</b></center><p>（4）加入U战队</p><p>将顶点t加入集合U={1，2}，同时更新V−U={3，4，5，6，7}。</p><p>（5）更新</p><p>刚刚找到了到U集合的最邻近点t = 2，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，2号结点的邻接点是3和7号结点：</p><p><strong>C</strong>[2][3]=20&lt;lowcost[3]=∞，更新最邻近距离lowcost[3]=20，最邻近点closest[3]=2；</p><p><strong>C</strong>[2][7]=1&lt;lowcost[7]=36，更新最邻近距离lowcost[7]=1，最邻近点closest[7]=2；</p><p>更新后的closest[j]和lowcost[j]数组如图2-72和图2-73所示。</p><p><img src="https://source.drie.cn/qxsf-images/111.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-72　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/112.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-73　lowcost[]数组</b></center><p>更新后如图2-74所示。</p><p><img src="https://source.drie.cn/qxsf-images/113.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-74　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为2，最邻近距离为20；4、5号顶点到U集合的最邻近点仍为初始化状态1，最邻近距离为∞；6号顶点到U集合的最邻近点为1，最邻近距离为26；7号顶点到U集合的最邻近点为2，最邻近距离为1。</p><p>（6）找最小</p><p>在集合V−U={3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-75所示。</p><p><img src="https://source.drie.cn/qxsf-images/114.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-75　lowcost[]数组</b></center><p>找到最小值为1，对应的结点t=7。</p><p>选中的边和结点如图2-76所示。</p><p><img src="https://source.drie.cn/qxsf-images/115.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-76　最小生成树求解过程</b></center><p>（7）加入U战队</p><p>将顶点t加入集合U={1，2，7}，同时更新V−U={3，4，5，6}。</p><p>（8）更新</p><p>刚刚找到了到U集合的最邻近点t =7，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图或邻接矩阵可以看出，7号结点在集合V−U中的邻接点是3、4、5、6结点：</p><p><strong>C</strong>[7][3]=4&lt;lowcost[3]=20，更新最邻近距离lowcost[3]=4，最邻近点closest[3]=7；</p><p><strong>C</strong>[7][4]=9&lt;lowcost[4]=∞，更新最邻近距离lowcost[4]=9，最邻近点closest[4]=7；</p><p><strong>C</strong>[7][5]=16&lt;lowcost[5]=∞，更新最邻近距离lowcost[5]=16，最邻近点closest[5]=7；</p><p><strong>C</strong>[7][6]=25&lt;lowcost[6]=28，更新最邻近距离lowcost[6]=25，最邻近点closest[6]=7；</p><p>更新后的closest[j]和lowcost[j]数组如图2-77和图2-78所示。</p><p><img src="https://source.drie.cn/qxsf-images/116.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-77　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/117.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-78　lowcost[]数组</b></center><p>更新后如图2-79所示。</p><p><img src="https://source.drie.cn/qxsf-images/118.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-79　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为7，最邻近距离为4；4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（9）找最小</p><p>在集合V−U={3，4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-80所示。</p><p><img src="https://source.drie.cn/qxsf-images/119.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-80　lowcost[]数组</b></center><p>找到最小值为4，对应的结点t=3。</p><p>选中的边和结点如图2-81所示。</p><p><img src="https://source.drie.cn/qxsf-images/120.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-81　最小生成树求解过程</b></center><p>（10）加入U战队</p><p>将顶点t加入集合U ={1，2，3，7}，同时更新V−U={4，5，6}。</p><p>（11）更新</p><p>刚刚找到了到U集合的最邻近点t =3，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，3号结点在集合V−U中的邻接点是4号结点：</p><p>C[3][4]=15&gt;lowcost[4]=9，不更新。</p><p>closest[j]和lowcost[j]数组不改变。</p><p>更新后如图2-82所示。</p><p><img src="https://source.drie.cn/qxsf-images/121.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-82　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（12）找最小</p><p>在集合V−U={4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-83所示。</p><p><img src="https://source.drie.cn/qxsf-images/122.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-83　lowcost[]数组</b></center><p>找到最小值为9，对应的结点t=4。</p><p>选中的边和结点如图2-84所示。</p><p><img src="https://source.drie.cn/qxsf-images/123.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-84　最小生成树求解过程</b></center><p>（13）加入U战队</p><p>将顶点t加入集合U ={1，2，3，4，7}，同时更新V−U={5，6}。</p><p>（14）更新</p><p>刚刚找到了到U集合的最邻近点t =4，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，4号结点在集合V−U中的邻接点是5号结点：</p><p><strong>C</strong>[4][5]=3&lt;lowcost[5]=16，更新最邻近距离lowcost[5]=3，最邻近点closest[5]=4；</p><p>更新后的closest[j]和lowcost[j]数组如图2-85和图2-86所示。</p><p><img src="https://source.drie.cn/qxsf-images/124.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-85　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/125.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-86　lowcost[]数组</b></center><p>更新后如图2-87所示。</p><p><img src="https://source.drie.cn/qxsf-images/126.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-87　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。5号顶点到U集合的最邻近点为4，最邻近距离为3；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（15）找最小</p><p>在集合V−U={5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-88所示。</p><p><img src="https://source.drie.cn/qxsf-images/127.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-88　lowcost[]数组</b></center><p>找到最小值为3，对应的结点t=5。</p><p>选中的边和结点如图2-89所示。</p><p><img src="https://source.drie.cn/qxsf-images/128.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-89　最小生成树求解过程</b></center><p>（16）加入U战队</p><p>将顶点t加入集合U={1，2，3，4，5，7}，同时更新V−U={6}。</p><p>（17）更新</p><p>刚刚找到了到U集合的最邻近点t =5，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，5号结点在集合V−U中的邻接点是6号结点：</p><p><strong>C</strong>[5][6]=17&lt;lowcost[6]=25，更新最邻近距离lowcost[6]=17，最邻近点closest[6]=5；</p><p>更新后的closest[j]和lowcost[j]数组如图2-90和图2-91所示。</p><p><img src="https://source.drie.cn/qxsf-images/129.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-90　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/130.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-91　lowcost[]数组</b></center><p>更新后如图2-92所示。</p><p><img src="https://source.drie.cn/qxsf-images/131.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-92　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。6号顶点到U集合的最邻近点为5，最邻近距离为17。</p><p>（18）找最小</p><p>在集合V−U={6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-93所示。</p><p><img src="https://source.drie.cn/qxsf-images/132.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-93　lowcost[]数组</b></center><p>找到最小值为17，对应的结点t=6。</p><p>选中的边和结点如图2-94所示。</p><p><img src="https://source.drie.cn/qxsf-images/133.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-94　最小生成树求解过程</b></center><p>（19）加入U战队</p><p>将顶点t加入集合U ={1，2，3，4，5，6，7}，同时更新V−U={}。</p><p>（20）更新</p><p>刚刚找到了到U集合的最邻近点t =6，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图2-94可以看出，6号结点在集合V−U中无邻接点，因为V−U={}。</p><p>closest[j]和lowcost[j]数组如图2-95和图2-96所示。</p><p><img src="https://source.drie.cn/qxsf-images/134.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-95　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/135.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-96　lowcost[]数组</b></center><p>得到的最小生成树如图2-97所示。</p><p><img src="https://source.drie.cn/qxsf-images/136.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-97　最小生成树</b></center><p>最小生成树权值之和为57，即把lowcost数组中的值全部加起来。</p><h3 id="2-7-4-伪代码详解">2.7.4　伪代码详解</h3><p>（1）初始化。s[1]=true，初始化数组closest，除了u<sub class="my_markdown">0</sub>外其余顶点最邻近点均为u<sub class="my_markdown">0</sub>，表示V−U中的顶点到集合U的最临近点均为u<sub class="my_markdown">0</sub>；初始代数组lowcost，u<sub class="my_markdown">0</sub>到V−U中的顶点的边值，无边相连则为∞（无穷大）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i != u0) <span class="comment">//除u0之外的顶点</span></span><br><span class="line">     &#123;</span><br><span class="line">          lowcost[i] = c[u0][i];   <span class="comment">//u0到其它顶点的边值</span></span><br><span class="line">          closest[i] = u0;  <span class="comment">//最邻近点初始化为u0</span></span><br><span class="line">          s[i] = <span class="literal">false</span>;  <span class="comment">//初始化u0之外的顶点不属于U集合，即属于V-U集合</span></span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          lowcost[i] =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在集合V−U中寻找距离集合U最近的顶点t。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF;</span><br><span class="line"><span class="type">int</span> t = u0;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//在集合中V-U中寻找距离集合U最近的顶点t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) <span class="comment">//!s[j] 表示j结点在V-U集合中</span></span><br><span class="line">    &#123; </span><br><span class="line">        t = j;</span><br><span class="line">        temp = lowcost[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t == u0) <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>（3）更新lowcost和closest数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[t] = <span class="literal">true</span>;     <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//更新lowcost和closest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) <span class="comment">// !s[j] 表示j结点在V-U集合中</span></span><br><span class="line">                                          <span class="comment">//t到j的边值小于当前的最邻近值</span></span><br><span class="line">    &#123;</span><br><span class="line">         lowcost[j] = c[t][j]; <span class="comment">//更新j的最邻近值为t到j的边值</span></span><br><span class="line">         closest[j] = t;    <span class="comment">//更新j的最邻近点为t</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-5-实战演练">2.7.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">bool</span> s[N];</span><br><span class="line"><span class="type">int</span> closest[N];</span><br><span class="line"><span class="type">int</span> lowcost[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> u0, <span class="type">int</span> c[N][N])</span> </span><br><span class="line">&#123;  <span class="comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span></span><br><span class="line">  <span class="comment">//如果s[i]=true,说明顶点i已加入最小生成树</span></span><br><span class="line">  <span class="comment">//的顶点集合U；否则顶点i属于集合V-U</span></span><br><span class="line">  <span class="comment">//将最后的相关的最小权值传递到数组lowcost</span></span><br><span class="line">  s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//①</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="keyword">if</span>(i != u0) </span><br><span class="line">       &#123;</span><br><span class="line">            lowcost[i] = c[u0][i];</span><br><span class="line">            closest[i] = u0;</span><br><span class="line">            s[i] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            lowcost[i] =<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//②</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> temp = INF;</span><br><span class="line">       <span class="type">int</span> t = u0;</span><br><span class="line">       <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//③在集合中V-u中寻找距离集合U最近的顶点t</span></span><br><span class="line">       &#123; </span><br><span class="line">           <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) </span><br><span class="line">           &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                temp = lowcost[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span>(t == u0)</span><br><span class="line">         <span class="keyword">break</span>;       <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">      s[t] = <span class="literal">true</span>;    <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//④更新lowcost和closest</span></span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j]))</span><br><span class="line">          &#123;</span><br><span class="line">              lowcost[j] = c[t][j];</span><br><span class="line">              closest[j] = t;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, c[N][N], m, u, v, w;</span><br><span class="line">    <span class="type">int</span> u0;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sumcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">          c[i][j] = INF;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入任一结点u0：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u0 ;</span><br><span class="line">    <span class="comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span></span><br><span class="line">    Prim(n, u0, c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;数组lowcost的内容为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lowcost[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                sumcost += lowcost[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; sumcost &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line">输入任一结点u0：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组lowcost的内容为：</span><br><span class="line"><span class="number">0</span> <span class="number">23</span> <span class="number">4</span> <span class="number">9</span> <span class="number">3</span> <span class="number">17</span> <span class="number">1</span></span><br><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure><h3 id="2-7-6-算法解析">2.7.6　算法解析</h3><p>（1）时间复杂度：在Prim（int n，int u<sub class="my_markdown">0</sub>，int <strong>c</strong>[N][N]）算法中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大。当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n=n²，算法的时间复杂度为O(n²)。</p><p>（2）空间复杂度：算法所需要的辅助空间包含i、j、lowcost和closest，则算法的空间复杂度是O(n)。</p><h3 id="2-7-7-算法优化拓展">2.7.7　算法优化拓展</h3><p>该算法可以从两个方面优化：</p><p>（1）for语句③找lowcost最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行n次，总时间复杂度为O( n logn)。</p><p>（2）for语句④更新lowcost和closest数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从1～n检查，检查更新的次数为E（边数），每次更新数据入队，入队的时间复杂度为logn，这样更新的时间复杂度为O( Elogn)。</p><h4 id="1．算法设计">1．算法设计</h4><p>构造最小生成树还有一种算法，Kurskal算法：设<strong>G</strong>=（V，E）是无向连通带权图，V={1，2，…，n}；设最小生成树<strong>T</strong>=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图<strong>T</strong>=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要<strong>T</strong>中选中的边数不到n−1，就做如下的贪心选择：在边集E中选取权值最小的边（i，j），如果将边（i，j）加入集合TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合E中删去。继续上面的贪心选择，直到<strong>T</strong>中所有顶点都在同一个连通分支上为止。此时，选取到的n−1条边恰好构成<strong>G</strong>的一棵最小生成树<strong>T</strong>。</p><p>那么，怎样判断加入某条边后图<strong>T</strong>会不会出现回路呢？</p><p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：如果所选择加入的边的起点和终点都在<strong>T</strong>的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p><p>步骤1：初始化。将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，边集TE={ }，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</p><p>步骤2：在E中寻找权值最小的边（i，j）。</p><p>步骤3：如果顶点i和j位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并。</p><p>步骤4：将边（i，j）从集合E中删去，即E=E−{（i，j）}。</p><p>步骤 5：如果选取边数小于n−1，转步骤2；否则，算法结束，生成最小生成树T。</p><h4 id="2．完美图解">2．完美图解</h4><p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-98所示。</p><p><img src="https://source.drie.cn/qxsf-images/137.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-98　无向连通带权图**G**</b></center><p>（1）初始化</p><p>将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，如图2-99所示。</p><p><img src="https://source.drie.cn/qxsf-images/138.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-99　按边权值排序后的图**G**</b></center><p>边集初始化为空集，TE={ }，把每个结点都初始化为一个孤立的分支，即一个顶点对应一个集合，集合号为该结点的序号，如图2-100所示。</p><p><img src="https://source.drie.cn/qxsf-images/139.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-100　每个结点初始化集合号</b></center><p>（2）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">1</sub>（2，7），边值为1。</p><p>（3）合并</p><p>结点2和结点7的集合号不同，即属于两个不同连通分支，则将边（2，7）加入边集TE，执行合并操作（将两个连通分支所有结点合并为一个集合）；假设把小的集合号赋值给大的集合号，那么7号结点的集合号也改为2，如图2-101所示。</p><p><img src="https://source.drie.cn/qxsf-images/140.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-101　最小生成树求解过程</b></center><p>（4）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">2</sub>（4，5），边值为3。</p><p>（5）合并</p><p>结点4和结点5集合号不同，即属于两个不同连通分支，则将边（4，5）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么5号结点的集合号也改为4，如图2-102所示。</p><p><img src="https://source.drie.cn/qxsf-images/141.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-102　最小生成树求解过程</b></center><p>（6）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">3</sub>（3，7），边值为4。</p><p>（7）合并</p><p>结点3和结点7集合号不同，即属于两个不同连通分支，则将边（3，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么3号结点的集合号也改为2，如图2-103所示。</p><p><img src="https://source.drie.cn/qxsf-images/142.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-103　最小生成树求解过程</b></center><p>（8）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">4</sub>（4，7），边值为9。</p><p>（9）合并</p><p>结点4和结点7集合号不同，即属于两个不同连通分支，则将边（4，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么4、5号结点的集合号都改为2，如图2-104所示。</p><p><img src="https://source.drie.cn/qxsf-images/143.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-104　最小生成树求解过程</b></center><p>（10）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">5</sub>（3，4），边值为15。</p><p>（11）合并</p><p>结点3和结点4集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（12）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">6</sub>（5，7），边值为16。</p><p>（13）合并</p><p>结点5和结点7集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（14）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">7</sub>（5，6），边值为17。</p><p>（15）合并</p><p>结点5和结点6集合号不同，即属于两个不同连通分支，则将边（5，6）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么6号结点的集合号都改为2，如图2-105所示。</p><p><img src="https://source.drie.cn/qxsf-images/144.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-105　最小生成树求解过程</b></center><p>（16）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">8</sub>（2，3），边值为20。</p><p>（17）合并</p><p>结点2和结点3集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（18）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">9</sub>（1，2），边值为23。</p><p>（19）合并</p><p>结点1和结点2集合号不同，即属于两个不同连通分支，则将边（1，2）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么2、3、4、5、6、7号结点的集合号都改为1，如图2-106所示。</p><p><img src="https://source.drie.cn/qxsf-images/145.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-106　最小生成树</b></center><p>（20）选中的各边和所有的顶点就是最小生成树，各边权值之和就是最小生成树的代价。</p><h4 id="3．伪码详解">3．伪码详解</h4><p>（1）数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nodeset[N];<span class="comment">//集合号数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="comment">//边的存储结构</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br></pre></td></tr></table></figure><p>（2）初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;<span class="comment">//每个结点赋值一个集合号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）对边进行排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//定义优先级，按边值进行升序排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(e, e+m, comp);<span class="comment">//调用系统排序函数</span></span><br></pre></td></tr></table></figure><p>（4）合并集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];<span class="comment">//p为a结点的集合号</span></span><br><span class="line">     <span class="type">int</span> q = nodeset[b]; <span class="comment">//q为b结点的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//集合号相同，什么也不做，返回</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的全部改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4．实战演练">4．实战演练</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> nodeset[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];</span><br><span class="line">     <span class="type">int</span> q = nodeset[b];</span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  Init(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u,v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;</span><br><span class="line">  sort(e, e+m, comp);</span><br><span class="line">  <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5．算法复杂度分析">5．算法复杂度分析</h4><p>（1）时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为e<em>loge，算法的时间复杂度为O(e</em>loge)。而合并集合需要n−1次合并，每次为O(n)，合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是O(n)。</p><h4 id="6．算法优化拓展">6．算法优化拓展</h4><p>该算法合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)，我们可以用并查集（见附录E）的思想优化，使合并集合的时间复杂度降为O(e*logn)，优化后的程序如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-9</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//排序优先级，按边的权值从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          father[i] = i;<span class="comment">//顶点所属集合号，初始化每个顶点一个集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//找祖宗</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x != father[x])</span><br><span class="line">     father[x] = Find(father[x]);<span class="comment">//把当前结点到其祖宗路径上的所有结点的集合号改为祖宗集合号</span></span><br><span class="line">     <span class="keyword">return</span> father[x]; <span class="comment">//返回其祖宗的集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//两结点合并集合号</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = Find(a); <span class="comment">//找a的集合号</span></span><br><span class="line">     <span class="type">int</span> q = Find(b); <span class="comment">//找b的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(p &gt; q)</span><br><span class="line">           father[p] = q;<span class="comment">//小的集合号赋值给大的集合号</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">           father[q] = p;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Init(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">    sort(e, e+m, comp);</span><br><span class="line">    <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure><h4 id="7．两种算法的比较">7．两种算法的比较</h4><p>（1）从算法的思想可以看出，如果图<strong>G</strong>中的边数较小时，可以采用Kruskal算法，因为Kruskal算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</p><p>（2）从时间上讲，Prim算法的时间复杂度为O(n<sup class="my_markdown">2</sup>)，Kruskal算法的时间复杂度为O(eloge)。</p><p>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V−U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《趣学算法》——第一章（算法之美）</title>
      <link href="/posts/87ab2347.html"/>
      <url>/posts/87ab2347.html</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-算法之美">第一章  算法之美</h3><p>如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路。数学是美学，算法是艺术。走进算法的人，才能体会它的魅力。</p><p>多年来，我有一个梦想，希望每一位提到算法的人，不再立即紧皱眉头，脑海闪现枯燥的公式、冗长的代码；希望每一位阅读和使用算法的人，体会到算法之美，像躺在法国普罗旺斯小镇的长椅上，呷一口红酒，闭上眼睛，体会舌尖上的美味，感受鼻腔中满溢的薰衣草的芳香……</p><p><img src="https://source.drie.cn/qxsf-images/1.png" alt="code"></p><h3 id="1-1-打开算法之门">1.1　打开算法之门</h3><p>瑞士著名的科学家N.Wirth教授曾提出： <strong>数据结构+算法=程序</strong> 。</p><p>数据结构是程序的骨架，算法是程序的灵魂。</p><p>在我们的生活中，算法无处不在。我们每天早上起来，刷牙、洗脸、吃早餐，都在算着时间，以免上班或上课迟到；去超市购物，在资金有限的情况下，考虑先买什么、后买什么，算算是否超额；在家中做饭，用什么食材、调料，做法、步骤，还要品尝一下咸淡，看看是否做熟。所以，不要说你不懂算法，其实你每天都在用！</p><p>但是对计算机专业算法，很多人都有困惑：“I can understand, but I can’tuse！”，我能看懂，但不会用！就像参观莫高窟的壁画，看到它、感受它，却无法走进。我们正需要一把打开算法之门的钥匙，就如陶渊明《桃花源记》中的“初极狭，才通人。复行数十步，豁然开朗。”</p><h3 id="1-2-妙不可言——算法复杂性">1.2　妙不可言——算法复杂性</h3><p>我们首先看一道某跨国公司的招聘试题。</p><p>写一个算法，求下面序列之和：</p><p>−1，1，−1，1，…，(−1)<sup class="my_markdown">n</sup></p><p>当你看到这个题目时，你会怎么想？for语句？while循环？</p><p>先看算法1-1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-1 </span></span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  sum=sum+(<span class="number">-1</span>)^n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以实现求和运算，但是为什么不这样算?！</p><p><img src="https://source.drie.cn/qxsf-images/2.jpg" alt="code"><br>再看算法1-2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-2</span></span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//判断n是不是偶数，%表示求余数</span></span><br><span class="line">  sum =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  sum=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>有的人看到这个代码后恍然大悟，原来可以这样啊？这不就是数学家高斯使用的算法吗？</p><p><img src="https://source.drie.cn/qxsf-images/3.jpg" alt="code"><br>一共50对数，每对之和均为101，那么总和为：</p><p>（1+100）×50=5050</p><p>1787年，10岁的高斯用了很短的时间算出了结果，而其他孩子却要算很长时间。</p><p>可以看出，算法1-1需要运行n+1次，如果n=100 00，就要运行100 01次，而算法1-2仅仅需要运行1次！是不是有很大差别？</p><blockquote><p>高斯的方法我也知道，但遇到类似的题还是……我用的笨办法也是算法吗？</p></blockquote><p><strong>答：是算法。</strong></p><p><strong>算法是指对特定问题求解步骤的一种描述。</strong></p><p>算法只是对问题求解方法的一种描述，它不依赖于任何一种语言，既可以用自然语言、程序设计语言（C、C++、Java、Python等）描述，也可以用流程图、框图来表示。一般为了更清楚地说明算法的本质，我们去除了计算机语言的语法规则和细节，采用“伪代码”来描述算法。“伪代码”介于自然语言和程序设计语言之间，它更符合人们的表达方式，容易理解，但不是严格的程序设计语言，如果要上机调试，需要转换成标准的计算机程序设计语言才能运行。</p><p>算法具有以下特性。</p><p>（1） <strong>有穷性</strong> ：算法是由若干条指令组成的有穷序列，总是在执行若干次后结束，不可能永不停止。</p><p>（2） <strong>确定性</strong> ：每条语句有确定的含义，无歧义。</p><p>（3） <strong>可行性</strong> ：算法在当前环境条件下可以通过有限次运算实现。</p><p>（4） <strong>输入输出</strong> ：有零个或多个输入，一个或多个输出。</p><blockquote><p>算法1-2的确算得挺快的，但如何知道我写的算法好不好呢？</p></blockquote><p><strong>“好”算法的标准如下。</strong></p><p>（1）正确性：正确性是指算法能够满足具体问题的需求，程序运行正常，无语法错误，能够通过典型的软件测试，达到预期的需求。</p><p>（2）易读性：算法遵循标识符命名规则，简洁易懂，注释语句恰当适量，方便自己和他人阅读，便于后期调试和修改。</p><p>（3）健壮性：算法对非法数据及操作有较好的反应和处理。例如，在学生信息管理系统中登记学生年龄时，若将21岁误输入为210岁，系统应该提示出错。</p><p>（4）高效性：高效性是指算法运行效率高，即算法运行所消耗的时间短。算法时间复杂度就是算法运行需要的时间。现代计算机一秒钟能计算数亿次，因此不能用秒来具体计算算法消耗的时间，由于相同配置的计算机进行一次基本运算的时间是一定的，我们可以用算法基本运算的执行次数来衡量算法的效率。因此，将算法基本运算的执行次数作为时间复杂度的衡量标准。</p><p>（5）低存储性：低存储性是指算法所需要的存储空间低。对于像手机、平板电脑这样的嵌入式设备，算法如果占用空间过大，则无法运行。算法占用的空间大小称为 <strong>空间复杂度</strong> 。</p><p>除了（1）～（3）中的基本标准外，我们对好的算法的评判标准就是 <strong>高效率</strong> 、 <strong>低存储</strong> 。</p><blockquote><p>（1）～（3）中的标准都好办，但时间复杂度怎么算呢？</p></blockquote><p><strong>时间复杂度</strong> ：算法运行需要的时间，一般将 <strong>算法的执行次数</strong> 作为时间复杂度的度量标准。</p><p>看算法1-3，并分析算法的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-3 </span></span><br><span class="line">sum=<span class="number">0</span>;                     <span class="comment">//运行1次</span></span><br><span class="line">total=<span class="number">0</span>;                   <span class="comment">//运行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)        <span class="comment">//运行n次</span></span><br><span class="line">&#123;</span><br><span class="line">  sum=sum+i;               <span class="comment">//运行n次</span></span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)      <span class="comment">//运行n*n次</span></span><br><span class="line">    total=total+i*j;       <span class="comment">//运行n*n次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把算法的所有语句的运行次数加起来：1+1+n+n+n×n+n×n，可以用一个函数T(n)表达：</p><p>T(n)=2n<sup class="my_markdown">2</sup>+2n+2</p><p>当n足够大时，例如n=10<sup class="my_markdown">5</sup>时，T(n)=2×10<sup>10</sup>+2×10<sup class="my_markdown">5</sup>+2，我们可以看到算法运行时间主要取决于第一项，后面的甚至可以忽略不计。</p><p>用极限表示为：</p><p>，C为不等于0的常数</p><p><img src="https://source.drie.cn/qxsf-images/4.gif" alt="code"><br>如果用 <strong>时间复杂度的渐近上界</strong> 表示，如图1-1所示。</p><p>从图1-1中可以看出，当n≥n<sub class="my_markdown">0</sub>时，T(n)≤Cf (n)，当n足够大时，T(n)和f (n)近似相等。因此，我们用О(f (n))来表示时间复杂度渐近上界，通常用这种表示法衡量算法时间复杂度。算法1-3的时间复杂度渐近上界为О(f (n))＝О(n<sup class="my_markdown">2</sup>)，用极限表示为：</p><p><img src="https://source.drie.cn/qxsf-images/7.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/8.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-1　渐近时间复杂度上界</b></center><p>还有 <strong>渐近下界</strong> 符号Ω(T(n)≥Cf (n))，如图1-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/9.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-2　渐近时间复杂度下界</b></center><p>从图1-2可以看出，当n≥n<sub class="my_markdown">0</sub>时，T(n)≥Cf (n)，当n足够大时，T(n)和f (n)近似相等，因此，我们用Ω(f (n))来表示时间复杂度渐近下界。</p><p><strong>渐近精确界</strong> 符号Θ(C<sub class="my_markdown">1</sub>f (n)≤T(n)≤C<sub>2</sub>f (n))，如图1-3所示。</p><p>从图1-3中可以看出，当n≥n<sub class="my_markdown">0</sub>时，C<sub>1</sub>f (n)≤T(n)≤C<sub>2</sub>f (n)，当n足够大时，T(n)和f (n)近似相等。这种两边逼近的方式，更加精确近似，因此，用Θ (f (n))来表示时间复杂度渐近精确界。</p><p><img src="https://source.drie.cn/qxsf-images/10.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-3　渐进时间复杂度精确界</b></center><p>我们通常使用时间复杂度渐近上界О(f (n))来表示时间复杂度。</p><p>看算法1-4，并分析算法的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-4</span></span><br><span class="line">i=<span class="number">1</span>;              <span class="comment">//运行1次</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)     <span class="comment">//可假设运行x次</span></span><br><span class="line">&#123;</span><br><span class="line">  i=i*<span class="number">2</span>;         <span class="comment">//可假设运行x次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察算法1-4，无法立即确定while 及i=i*2运行了多少次。这时可假设运行了x次，每次运算后i值为2，2<sup class="my_markdown">2</sup>，2<sup>3</sup>，…，2<sup>x</sup>，当i=n时结束，即2<sup>x</sup>＝n时结束，则x=log<sub class="my_markdown">2</sub>n，那么算法1-4的运算次数为1+2log<sub class="my_markdown">2</sub>n，时间复杂度渐近上界为О(f (n))＝О(log<sub class="my_markdown">2</sub>n)。</p><p>在算法分析中，渐近复杂度是对算法运行次数的粗略估计，大致反映问题规模增长趋势，而不必精确计算算法的运行时间。在计算渐近时间复杂度时，可以只考虑对算法运行时间贡献大的语句，而忽略那些运算次数少的语句，循环语句中处在循环内层的语句往往运行次数最多，即为对运行时间贡献最大的语句。例如在算法1-3中，total=total+i*j是对算法贡献最大的语句，只计算该语句的运行次数即可。</p><p><strong>注意：</strong> 不是每个算法都能直接计算运行次数。</p><p>例如算法1-5，在a[n]数组中顺序查找x，返回其下标i，如果没找到，则返回−1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-5 </span></span><br><span class="line">findx(<span class="type">int</span> x)      <span class="comment">//在a[n]数组中顺序查找x</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)  </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (a[i]==x)  </span><br><span class="line">     <span class="keyword">return</span> i;    <span class="comment">//返回其下标i</span></span><br><span class="line">   ｝</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很难计算算法1-5中的程序到底执行了多少次，因为运行次数依赖于x在数组中的位置，如果第一个元素就是x，则执行1次（最好情况）；如果最后一个元素是x，则执行n次（最坏情况）；如果分布概率均等，则平均执行次数为（n+1）/2。</p><p>有些算法，如排序、查找、插入等算法，可以分为 <strong>最好</strong> 、 <strong>最坏</strong> 和 <strong>平均</strong> 情况分别求算法渐近复杂度，但我们考查一个算法通常考查最坏的情况，而不是考查最好的情况， <strong>最坏情况对衡量算法的好坏具有实际的意义</strong> 。</p><blockquote><p>我明白了，那空间复杂度应该就是算法占了多大存储空间了？</p></blockquote><p><strong>空间复杂度</strong> ：算法占用的空间大小。一般将算法的 <strong>辅助空间</strong> 作为衡量空间复杂度的标准。</p><p>空间复杂度的本意是指算法在运行过程中占用了多少存储空间。算法占用的存储空间包括：</p><p>（1）输入/输出数据；</p><p>（2）算法本身；</p><p>（3）额外需要的辅助空间。</p><p>输入/输出数据占用的空间是必需的，算法本身占用的空间可以通过精简算法来缩减，但这个压缩的量是很小的，可以忽略不计。而在运行时使用的辅助变量所占用的空间，即辅助空间是衡量空间复杂度的关键因素。</p><p>看算法1-6，将两个数交换，并分析其空间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-6 </span></span><br><span class="line">swap(<span class="type">int</span> x,<span class="type">int</span> y)  <span class="comment">//x与y交换 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp=x;  <span class="comment">//temp为辅助空间 ①</span></span><br><span class="line">  x=y;   ②</span><br><span class="line">  y=temp; ③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两数的交换过程如图1-4所示。</p><p><img src="https://source.drie.cn/qxsf-images/11.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-4　两数交换过程</b></center><p>图1-4中的步骤标号与算法1-6中的语句标号一一对应，该算法使用了一个辅助空间temp，空间复杂度为О(1)。</p><p><strong>注意：</strong> 递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。</p><p>看算法1-7，计算n的阶乘，并分析其空间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-7 </span></span><br><span class="line">fac(<span class="type">int</span> n)  <span class="comment">//计算n的阶乘</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">0</span>)   <span class="comment">//小于零的数无阶乘值</span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;n&lt;0,data error!&quot;</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n= =<span class="number">0</span> || n= =<span class="number">1</span>) </span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">return</span> n*fac(n<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阶乘是典型的递归调用问题，递归包括递推和回归。递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。</p><p><strong>思考：</strong> 试求5的阶乘，程序将怎样计算呢？</p><p>5的阶乘的递推和回归过程如图1-5和图1-6所示。</p><p><img src="https://source.drie.cn/qxsf-images/12.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-5　5的阶乘递推过程</b></center><p><img src="https://source.drie.cn/qxsf-images/13.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-6　5的阶乘回归过程</b></center><p>图1-5和图1-6的递推、回归过程是我们从逻辑思维上推理，用图的方式形象地表达出来的，但计算机内部是怎样处理的呢？计算机使用一种称为“栈”的数据结构，它类似于一个放一摞盘子的容器，每次从顶端放进去一个，拿出来的时候只能从顶端拿一个，不允许从中间插入或抽取，因此称为“后进先出”（last in first out）。</p><p>5的阶乘进栈过程如图1-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/14.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-7　5的阶乘进栈过程</b></center><p>5的阶乘出栈过程如图1-8所示。</p><p><img src="https://source.drie.cn/qxsf-images/15.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-8　5的阶乘出栈过程</b></center><p>从图1-7和图1-8的进栈、出栈过程中，我们可以很清晰地看到，首先把子问题一步步地压进栈，直到得到返回值，再一步步地出栈，最终得到递归结果。在运算过程中，使用了n个栈空间作为辅助空间，因此阶乘递归算法的空间复杂度为О(n)。在算法1-7中，时间复杂度也为О(n)，因为n的阶乘仅比n−1的阶乘多了一次乘法运算，fac(n)=n*fac(n−1)。如果用T(n)表示fac(n)的时间复杂度，可表示为：</p><p>T(n)= T(n−1)+1</p><p>= T(n−2)+1+1</p><p>……</p><p>= T(1)+…+1+1</p><p>=n</p><h3 id="1-3-美不胜收——魔鬼序列">1.3　美不胜收——魔鬼序列</h3><h4 id="趣味故事1-1：一棋盘的麦子">趣味故事1-1：一棋盘的麦子</h4><p>有一个古老的传说，有一位国王的女儿不幸落水，水中有很多鳄鱼，国王情急之下下令：“谁能把公主救上来，就把女儿嫁给他。”很多人纷纷退让，一个勇敢的小伙子挺身而出，冒着生命危险把公主救了上来，国王一看是个穷小子，想要反悔，说：“除了女儿，你要什么都可以。”小伙子说：“好吧，我只要一棋盘的麦子。您在第1个格子里放1粒麦子，在第2个格子里放2粒，在第3个格子里放4粒，在第4个格子里放8粒，以此类推，每一格子里的麦子粒数都是前一格的两倍。把这64个格子都放好了就行，我就要这么多。”国王听后哈哈大笑，觉得小伙子的要求很容易满足，满口答应。结果发现，把全国的麦子都拿来，也填不完这64格……国王无奈，只好把女儿嫁给了这个小伙子。</p><p><strong>解析</strong></p><p>棋盘上的64个格子究竟要放多少粒麦子？</p><p>把每一个放的麦子数加起来，总和为S，则：</p><p>S=1+2<sup class="my_markdown">1</sup>+2<sup>2</sup>+2<sup>3</sup>+…+2<sup>63</sup>　　 ①</p><p>我们把式①等号两边都乘以2，等式仍然成立：</p><p>2S=2<sup class="my_markdown">1</sup>+2<sup>2</sup>+2<sup>3</sup>+…+2<sup>63</sup>+2<sup>64</sup>　　 ②</p><p>式 ②减去式①，则：</p><p>S=2<sup class="my_markdown">64</sup>−1 ＝18 446 744 073 709 551 615</p><p>据专家统计，每个麦粒的平均重量约41.9毫克，那么这些麦粒的总重量是：</p><p>18 446 744 073 709 551 615×41.9＝772 918 576 688 430 212 668.5（毫克）</p><p>≈7729（亿吨）</p><p>全世界人口按60亿计算，每人可以分得128吨！</p><p>我们称这样的函数为 <strong>爆炸增量函数</strong> ，想一想，如果算法时间复杂度是О(2<sup class="my_markdown">n</sup>) 会怎样？随着n的增长，这个算法会不会“爆掉”？经常见到有些算法调试没问题，运行一段也没问题，但关键的时候宕机（shutdown）。例如，在线考试系统，50个人考试没问题，100人考试也没问题，如果全校1万人考试就可能出现宕机。</p><p><strong>注意：</strong> 宕机就是死机，指电脑不能正常工作了，包括一切原因导致的死机。计算机主机出现意外故障而死机，一些服务器（如数据库）死锁，服务器的某些服务停止运行都可以称为宕机。</p><p>常见的算法时间复杂度有以下几类。</p><p>（1）常数阶。</p><p>常数阶算法运行的次数是一个常数，如5、20、100。常数阶算法时间复杂度通常用О(1)表示，例如算法1-6，它的运行次数为4，就是常数阶，用О(1)表示。</p><p>（2）多项式阶。</p><p>很多算法时间复杂度是多项式，通常用О(n)、О(n<sup class="my_markdown">2</sup>)、О(n<sup>3</sup>)等表示。例如算法1-3就是多项式阶。</p><p>（3）指数阶。</p><p>指数阶时间复杂度运行效率极差，程序员往往像躲“恶魔”一样避开它。常见的有О(2<sup class="my_markdown">n</sup>)、О(n！)、О(n<sup class="my_markdown">n</sup>)等。使用这样的算法要慎重，例如趣味故事1-1。</p><p>（4）对数阶。</p><p>对数阶时间复杂度运行效率较高，常见的有О(logn)、О(nlogn)等，例如算法1-4。</p><p>常见时间复杂度函数曲线如图1-9所示。</p><p><img src="https://source.drie.cn/qxsf-images/16.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-9　常见函数增量曲线</b></center><p>从图1-9中可以看出，指数阶增量随着x的增加而急剧增加，而对数阶增加缓慢。它们之间的关系为：</p><p>О(1)&lt; О(logn)&lt; О(n)&lt; О(nlogn) &lt; О(n<sup class="my_markdown">2</sup>)&lt; О(n<sup class="my_markdown">3</sup>)&lt; О(2<sup class="my_markdown">n</sup>) &lt; О(n!)&lt; О(n<sup class="my_markdown">n</sup>)</p><p>我们在设计算法时要注意算法复杂度增量的问题，尽量避免爆炸级增量。</p><h4 id="趣味故事1-2：神奇兔子数列">趣味故事1-2：神奇兔子数列</h4><p>假设第1个月有1对刚诞生的兔子，第2个月进入成熟期，第3个月开始生育兔子，而1对成熟的兔子每月会生1对兔子，兔子永不死去……那么，由1对初生兔子开始，12个月后会有多少对兔子呢？</p><p>兔子数列即斐波那契数列，它的发明者是意大利数学家列昂纳多•斐波那契（Leonardo Fibonacci，1170—1250）。1202年，他撰写了《算盘全书》（《Liber Abaci》）一书，该书是一部较全面的初等数学著作。书中系统地介绍了印度—阿拉伯数码及其演算法则，介绍了中国的“盈不足术”；引入了负数，并研究了一些简单的一次同余式组。</p><p>（1）问题分析</p><p>我们不妨拿新出生的1对小兔子分析：</p><p>第1个月，小兔子①没有繁殖能力，所以还是1对。</p><p>第2个月，小兔子①进入成熟期，仍然是1对。</p><p>第3个月，兔子①生了1对小兔子②，于是这个月共有2（1+1=2）对兔子。</p><p>第4个月，兔子①又生了1对小兔子③。因此共有3（1+2=3）对兔子。</p><p>第5个月，兔子①又生了1对小兔子④，而在第3个月出生的兔子②也生下了1对小兔子⑤。共有5（2+3=5）对兔子。</p><p>第6个月，兔子①②③各生下了1对小兔子。新生3对兔子加上原有的5对兔子这个月共有8（3+5=8）对兔子。</p><p>……</p><p>为了表达得更清楚，我们用图示来分别表示新生兔子、成熟期兔子和生育期兔子，兔子的繁殖过程如图1-10所示。</p><p><img src="https://source.drie.cn/qxsf-images/17.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-10　兔子繁殖过程</b></center><p>这个数列有十分明显的特点，从第3个月开始， <strong>当月的兔子数</strong> = <strong>上月兔子数</strong> + <strong>当月新生兔子数</strong> ，而当月新生的兔子正好是 <strong>上上月的兔子数</strong> 。因此，前面相邻两项之和，构成了后一项，即：</p><p><strong>当月的兔子数</strong> = <strong>上月兔子数</strong> + <strong>上上月的兔子数</strong></p><p>斐波那契数列如下：</p><p>1，1，2，3，5，8，13，21，34，…</p><p>递归式表达式：</p><p><img src="https://source.drie.cn/qxsf-images/18.gif" alt="code"><br>那么我们该怎么设计算法呢？</p><blockquote><p>哈哈，这太简单了，用递归算法很快就算出来了！</p></blockquote><p>（2）算法设计</p><p>首先按照递归表达式设计一个递归算法，见算法1-8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-8 </span></span><br><span class="line">Fib1(<span class="type">int</span> n) </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> Fib1(n<span class="number">-1</span>)+Fib1(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写得不错，那么算法设计完成后，我们有3个问题：</p><ul><li>算法是否正确？</li><li>算法复杂度如何？</li><li>能否改进算法？</li></ul><p>（3）算法验证分析</p><p>第一个问题毋庸置疑，因为算法1-8是完全按照递推公式写出来的，所以正确性没有问题。那么算法复杂度呢？假设T(n)表示计算Fib1(n)所需要的基本操作次数，那么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">1</span>时，T(n)=<span class="number">1</span>；</span><br><span class="line">n=<span class="number">2</span>时，T(n)=<span class="number">1</span>；</span><br><span class="line">n=<span class="number">3</span>时，T(n)=<span class="number">3</span>；<span class="comment">//调用Fib1(2)、Fib1(1)和执行一次加法运算Fib1(2)+Fib1(1)</span></span><br></pre></td></tr></table></figure><p>因此，n&gt;2时要分别调用Fib1(n−1)、Fib1(n−2)和执行一次加法运算，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&gt;<span class="number">2</span>时，T(n)= T(n<span class="number">-1</span>)+ T(n<span class="number">-2</span>)+<span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>递归表达式和时间复杂度T(n)之间的关系如下：</p><p><img src="https://source.drie.cn/qxsf-images/19.gif" alt="code"><br>由此可得：。</p><p><img src="https://source.drie.cn/qxsf-images/20.gif" alt="code"><br>那么怎么计算F(n)呢？</p><p>有兴趣的读者可以看本书附录A中通项公式的求解方法，也可以看下文中的简略解释。</p><p>斐波那契数列通项为：</p><p><img src="https://source.drie.cn/qxsf-images/21.gif" alt="code"><br>当n趋近于无穷时，</p><p><img src="https://source.drie.cn/qxsf-images/22.gif" alt="code"><br>由于<img class="my_markdown" src="https://source.drie.cn/qxsf-images/20.gif" style="width:100px;  height: 18px; "/>，这是一个指数阶的算法！</p><p>如果我们今年计算出了F(100)，那么明年才能算出F(101)，多算一个斐波那契数需要一年的时间， <strong>爆炸增量函数</strong> 是算法设计的噩梦！算法1-8的时间复杂度属于 <strong>爆炸增量函数</strong> ，这在算法设计时是应当避开的，那么我们能不能改进它呢？</p><p>（4）算法改进</p><p>既然斐波那契数列中的每一项是前两项之和，如果记录前两项的值，只需要一次加法运算就可以得到当前项，时间复杂度会不会更低一些？我们用数组试试看，见算法1-9。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-9 </span></span><br><span class="line">Fib2(<span class="type">int</span> n) </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> *a=new <span class="type">int</span>[n];<span class="comment">//定义一个数组</span></span><br><span class="line">  a[<span class="number">1</span>]=<span class="number">1</span>；</span><br><span class="line">  a[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">     a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">  <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，算法1-9的时间复杂度为О(n)。算法仍然是按照F(n)的定义，所以正确性没有问题，而 <strong>时间复杂度</strong> 却从算法1-8的 <strong>指数阶降到了多项式阶</strong> ，这是算法效率的一个巨大突破！</p><p>算法1-9使用了一个辅助数组记录中间结果，空间复杂度也为О(n)，其实我们只需要得到第n个斐波那契数，中间结果只是为了下一次使用，根本不需要记录。因此，我们可以采用 <strong>迭代法</strong> 进行算法设计，见算法1-10。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-10 </span></span><br><span class="line">Fib3(<span class="type">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,s1,s2; </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  s1=<span class="number">1</span>;</span><br><span class="line">  s2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">     s2=s1+s2; <span class="comment">//辗转相加法</span></span><br><span class="line">     s1=s2-s1; <span class="comment">//记录前一项</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代过程如下。</p><p>初始值：s<sub class="my_markdown">1</sub>=1；s<sub>2</sub>=1；</p><p>当前解　　　 记录前一项</p><p>i=3时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=2　　 s<sub>1</sub>=s<sub class="my_markdown">2</sub>−s<sub>1</sub>=1</p><p>i=4时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=3　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=2</p><p>i=5时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=5　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=3</p><p>i=6时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=8　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=5</p><p>……　　　　　 ……　　　　　 ……</p><p>算法1-10使用了若干个辅助变量，迭代辗转相加，每次记录前一项，时间复杂度为О(n)，但 <strong>空间复杂度</strong> 降到了О(1)。</p><p><strong>问题的进一步讨论</strong> ：我们能不能继续降阶，使算法时间复杂度更低呢？实质上，斐波那契数列时间复杂度还可以降到对数阶О(logn)，有兴趣的读者可以查阅相关资料。想想看，我们把一个算法从 <strong>指数阶</strong> 降到 <strong>多项式阶</strong> ，再降到 <strong>对数阶</strong> ，这是一件多么振奋人心的事！</p><p>（5）惊人大发现</p><p>科学家经研究在植物的叶、枝、茎等排列中发现了斐波那契数！例如，在树木的枝干上选一片叶子，记其为数1，然后依序点数叶子（假定没有折损），直到到达与那片叶子正对的位置，则其间的叶子数多半是斐波那契数。叶子从一个位置到达下一个正对的位置称为一个循回。叶子在一个循回中旋转的圈数也是斐波那契数。在一个循回中，叶子数与叶子旋转圈数的比称为叶序（源自希腊词，意即叶子的排列）比。多数植物的叶序比呈现为斐波那契数的比，例如，蓟的头部具有13条顺时针旋转和21条逆时针旋转的斐波那契螺旋，向日葵的种子的圈数与子数、菠萝的外部排列同样有着这样的特性，如图1-11所示。</p><p><img src="https://source.drie.cn/qxsf-images/23.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-11　斐波那契螺旋（图片来自网络）</b></center><p>观察延龄草、野玫瑰、南美血根草、大波斯菊、金凤花、耧斗菜、百合花、蝴蝶花的花瓣，可以发现它们的花瓣数目为斐波那契数：3，5，8，13，21，…。如图1-12所示。</p><p><img src="https://source.drie.cn/qxsf-images/24.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-12　植物花瓣（图片来自网络）</b></center><p>树木在生长过程中往往需要一段“休息”时间，供自身生长，而后才能萌发新枝。所以，一株树苗在一段间隔（例如一年）以后长出一条新枝；第二年新枝“休息”，老枝依旧萌发；此后，老枝与“休息”过一年的枝同时萌发，当年生的新枝则次年“休息”。这样，一株树木各个年份的枝桠数便构成斐波那契数列，这个规律就是生物学上著名的“鲁德维格定律”。</p><p>这些植物懂得斐波那契数列吗？应该并非如此，它们只是按照自然的规律才进化成这样的。这似乎是植物排列种子的“优化方式”，它能使所有种子具有相近的大小却又疏密得当，不至于在圆心处挤太多的种子而在圆周处却又很稀疏。叶子的生长方式也是如此，对于许多植物来说，每片叶子从中轴附近生长出来，为了在生长的过程中一直都能最佳地利用空间（要考虑到叶子是一片一片逐渐地生长出来，而不是一下子同时出现的），每片叶子和前一片叶子之间的角度应该是222.5°，这个角度称为“黄金角度”，因为它和整个圆周360°之比是黄金分割数0.618的倒数，而这种生长方式就导致了斐波那契螺旋的产生。向日葵的种子排列形成的斐波那契螺旋有时能达到89，甚至144。1992年，两位法国科学家通过对花瓣形成过程的计算机仿真实验，证实了在系统保持最低能量的状态下，花朵会以斐波那契数列的规律长出花瓣。</p><p>有趣的是：这样一个完全是自然数的数列，通项公式却是用无理数来表达的。而且当n趋向于无穷大时，斐波那契数列前一项与后一项的比值越来越逼近黄金分割比0.618：1÷1 = 1，1÷2 = 0.5，2÷3 = 0.666，…，3÷5 = 0.6，5÷8 = 0.625，…，55÷89 = 0.617977，…，144÷233 = 0.618025，…，46368÷75025 = 0.6180339886……</p><p>越到后面，这些比值越接近黄金分割比：</p><p><img src="https://source.drie.cn/qxsf-images/25.gif" alt="code"><br>斐波那契数列起源于兔子数列，这个现实中的例子让我们真切地感到数学源于生活，生活中我们需要不断地通过现象发现数学问题，而不是为了学习而学习。学习的目的是满足对世界的好奇心，如果我们怀着这样一颗好奇心，或许世界会因你而不同！斐波那契通过兔子繁殖来告诉我们这种数学问题的本质，随着数列项的增加，前一项与后一项之比越来越逼近黄金分割的数值0.618时，我彻底被震惊到了，因为数学可以表达美，这是令我们叹为观止的地方。当数学创造了更多的奇迹时，我们会发现数学本质上是可以回归到自然的，这样的事例让我们感受到数学的美，就像黄金分割、斐波那契数列，如同大自然中的一朵朵小花，散发着智慧的芳香……</p><h3 id="1-4-灵魂之交——马克思手稿中的数学题">1.4　灵魂之交——马克思手稿中的数学题</h3><p>有人抱怨：算法太枯燥、乏味了，看到公式就头晕，无法学下去了。你肯定选择了一条充满荆棘的路。选对方法，你会发现这里是一条充满鸟语花香和欢声笑语的幽径，在这里，你可以和高德纳聊聊，同爱因斯坦喝杯咖啡，与歌德巴赫和角谷谈谈想法，Dijkstra也不错。与世界顶级的大师进行灵魂之交，不问结果，这一过程已足够美妙！</p><p>如果这本书能让多一个人爱上算法，这就足够了！</p><h4 id="趣味故事1-3：马克思手稿中的数学题">趣味故事1-3：马克思手稿中的数学题</h4><p>马克思手稿中有一道趣味数学问题：有30个人，其中有男人、女人和小孩，这些人在一家饭馆吃饭花了50先令；每个男人花3先令，每个女人花2先令，每个小孩花1先令；问男人、女人和小孩各有几人？</p><p>（1）问题分析</p><p>设x、y、z分别代表男人、女人和小孩。按题目的要求，可得到下面的方程：</p><p>x+y+z=30　①</p><p>3x+2y+z=50 ②</p><p>两式相减，②−①得：</p><p>2x+y=20　③</p><p>从式③可以看出，因为x、y为正整数，x最大只能取9，所以x变化范围是1～9。那么我们可以让x从1到9变化，再找满足①②两个条件y、z值，找到后输入即可，答案可能不止一个。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-11。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> x,y,z,count=<span class="number">0</span>; <span class="comment">//记录可行解的个数</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; Men，Women，Children&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;........................................&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  <span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=<span class="number">9</span>;x++) </span><br><span class="line">  &#123; </span><br><span class="line">    y=<span class="number">20</span><span class="number">-2</span>*x;  <span class="comment">//固定x值然后根据式③求得y值 </span></span><br><span class="line">    z=<span class="number">30</span>-x-y;  <span class="comment">//由式①求得z值 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span>*x+<span class="number">2</span>*y+z==<span class="number">50</span>)  <span class="comment">//判断当前得到的一组解是否满足式②</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;++count&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印出第几个解和解值x，y，z</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>算法完全按照题中方程设计，因此正确性毋庸置疑。那么算法复杂度怎样呢？从算法1-11中可以看出，对算法时间复杂度贡献最大的语句是for(x=1;x&lt;=9;x++)，该语句的执行次数是9，for循环中3条语句的执行次数也为9，其他语句执行次数为1，for语句一共执行36次基本运算，时间复杂度为О(1)。没有使用辅助空间，空间复杂度也为О(1)。</p><p>（4）问题的进一步讨论</p><p>为什么让x变化来确定y、z值？让y变化来确定x、z值会怎样呢？让z变化来确定x、y值行不行？有没有更好的算法降低时间复杂度？</p><h4 id="趣味故事1-4：爱因斯坦的阶梯">趣味故事1-4：爱因斯坦的阶梯</h4><p>爱因斯坦家里有一条长阶梯，若每步跨2阶，则最后剩1阶；若每步跨3阶，则最后剩2阶；若每步跨5阶，则最后剩4阶；若每步跨6阶，则最后剩5阶。只有每次跨7阶，最后才正好1阶不剩。请问这条阶梯共有多少阶？</p><p>（1）问题分析</p><p>根据题意，阶梯数n满足下面一组同余式：</p><p>n≡1(mod2)</p><p>n≡2(mod3)</p><p>n≡4(mod5)</p><p>n≡5(mod6)</p><p>n≡0(mod7)</p><p><strong>注意：</strong> 两个整数a、b，若它们除以整数m所得的余数相等，则称a、b对于模m同余，记作a≡b(mod m)，读作a同余于b模m，或读作a与b关于模m同余。那么只需要判断一个整数值是否满足这5个同余式即可。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-12。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-12</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> n=<span class="number">1</span>; <span class="comment">//n为所设的阶梯数 </span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>))) </span><br><span class="line">      n++;      <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Count the stairs= &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出阶梯数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>算法的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count the stairs =<span class="number">119</span></span><br></pre></td></tr></table></figure><p>因为n从1开始，找到第一个满足条件的数就停止，所以算法1-12中的while语句运行了119次。有的算法从算法本身无法看出算法的运行次数，例如算法1-12，我们很难知道while语句执行了多少次，因为它是满足条件时停止，那么多少次才能满足条件呢？每个问题具体的次数是不同的，所以不能看到程序中有n，就简单地说它的时间复杂度为n。</p><blockquote><p>我们从1开始一个一个找结果的办法是不是太麻烦了？</p></blockquote><p>（4）算法改进</p><p>因为从上面的5个同余式来看，这个数一定是7的倍数n≡0(mod 7)，除以6余5，除以5余4，除以3余2，除以2余1，我们为什么不从7的倍数开始判断呢？算法改进见算法1-13。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-13</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> n=<span class="number">7</span>; <span class="comment">//n为所设的阶梯数 </span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>))) </span><br><span class="line">  n=n+<span class="number">7</span>;      <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Count the stairs=&quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出阶梯数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count the stairs =<span class="number">119</span></span><br></pre></td></tr></table></figure><p>算法1-13中的while语句执行了119/7=17次，可见运行次数减少了不少呢！</p><p>（5）问题的进一步讨论</p><p>此题算法还可考虑求1、2、4、5的最小公倍数n，然后令t=n−1，判断t≡0(mod 7)是否成立，若不成立则t=t+n，再进行判别，直到选出满足条件的t为止。</p><p>1、2、4、5的最小公倍数n=20。</p><p>t=n-1=19，t≡0(mod 7)不成立；</p><p>t= t+n=39，t≡0(mod 7)不成立；</p><p>t= t+n=59，t≡0(mod 7)不成立；</p><p>t= t+n=79，t≡0(mod 7)不成立；</p><p>t= t+n=99，t≡0(mod 7)不成立；</p><p>t= t+n=119，t≡0(mod 7)成立。</p><p>我们可以看到这一算法判断6次即成功，但是，求多个数的最小公倍数需要多少时间复杂度，是不是比上面的算法更优呢？结果如何请大家动手试一试。</p><h4 id="趣味故事1-5：哥德巴赫猜想">趣味故事1-5：哥德巴赫猜想</h4><p>哥德巴赫猜想：任一大于2的偶数，都可表示成两个素数之和。</p><p>验证：2000以内大于2的偶数都能够分解为两个素数之和。</p><p>（1）问题分析</p><p>为了验证哥德巴赫猜想对2000以内大于2的偶数都是成立的，要将整数分解为两部分（两个整数之和），然后判断分解出的两个整数是否均为素数。若是，则满足题意；否则重新进行分解和判断。素数测试的算法可采用试除法，即用2，3，4，…，<img class="my_markdown" src="D:/%25E9%25A1%25B9%25E7%259B%25AE/MarkdownBooks-master/Algorithm/%25E8%25B6%25A3%25E5%25AD%25A6%25E7%25AE%2597%25E6%25B3%2595/images/26.gif" style="width:25px;  height: 19px; "/>去除n，如果能被整除则为合数，不能被整除则为素数。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-14。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span> n)</span>; <span class="comment">//判断是否均为素数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> i,n; </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;=<span class="number">2000</span>;i+=<span class="number">2</span>) <span class="comment">//对2000大于2的偶数分解判断，从4开始，每次增2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">2</span>;n&lt;i;n++)  <span class="comment">//将偶数i分解为两个整数，一个整数是n，一个是i-n</span></span><br><span class="line">      <span class="keyword">if</span>(prime(n))    <span class="comment">//判断第一个整数是否均为素数 </span></span><br><span class="line">         <span class="keyword">if</span>(prime(i-n))   <span class="comment">//判断第二个整数是否均为素数 </span></span><br><span class="line">         &#123; </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="string">&quot;=&quot;</span> &lt;&lt; n &lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;i-n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//若均是素数则输出 </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     <span class="keyword">if</span>(n==i) </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;error &quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//判断是否为素数 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> j; </span><br><span class="line">  <span class="keyword">if</span>(i&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=(<span class="type">int</span>)(<span class="built_in">sqrt</span>((<span class="type">double</span>)i);j++) </span><br><span class="line">    <span class="keyword">if</span>(!(i%j)) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>要验证哥德巴赫猜想对2000以内大于2的偶数都是成立的，我们首先要看看这个范围的偶数有多少个。1～2000中有1000个偶数，1000个奇数，那么大于2的偶数有999个，即i=4，6，8，…，2000。再看偶数分解和素数判断，这就要看最好情况和最坏情况了。最好的情况是一次分解，两次素数判断即可成功，最坏的情况要i−2次分解（即n=2，3，…，i−1的情况），每次分解分别执行2～sqrt(n)次、2～sqrt(i−n)次判断。</p><p>这个程序看似简单合理，但存在下面两个问题。</p><p>1）偶数分解存在重复。</p><ul><li>i=4：分解为（2，2），（3，1），从n=2，3，…，i−1分解，每次得到一组数（n，i−n）。</li><li>i=6：分解为（2，4），（3，3），（4，2），（5，1）。</li><li>i=8：分解为（2，6），（3，5），（4，4），（5，3），（6，2），（7，1）。</li></ul><p>除了最后一项外，每组分解都在i/2处对称分布。最后一组中有一个数为1，1既不是素数也不是合数，因此去掉最后一组，那么我们就可以从n=2，3，…，i/2进行分解，省掉了一半的多余判断。</p><p>2）素数判断存在重复。</p><ul><li>i=4：分解为（2，2），（3，1），要判断2是否为素数，然后判断第二个2是否为素数。判断成功，返回。</li><li>i=6：分解为（2，4），（3，3），（4，2），（5，1），要判断2是否为素数，然后判断4是否为素数，不是继续下一个分解。再判断3是否为素数，然后判断第二个3是否为素数。判断成功，返回。</li></ul><p>每次判断素数都要调用prime函数，那么可以先判断分解有可能得到的数是否为素数，然后把结果存储下来，下次判断时只需要调用上次的结果，不需要再重新判断是否为素数。例如（2，2），第一次判断结果2是素数，那第二个2就不用判断，直接调用这个结果，后面所有的分解，只要遇到这个数就直接认定为这个结果。</p><p>（4）算法改进</p><p>先判断所有分解可能得到的数是否为素数，然后把结果存储下来，有以下两种方法。</p><p>1）用布尔型数组 flag[2…1998]记录分解可能得到的数（2～1998）所有数是不是素数，分解后的值作为下标，调用该数组即可。时间复杂度减少，但空间复杂度增加。</p><p>2）用数值型数组data[302]记录2～1998中所有的素数（302个）。</p><ul><li>分解后的值，采用折半查找（素数数组为有序存储）的办法在素数数组中查找，找到就是素数，否则不是。</li><li>不分解，直接在素数数组中找两个素数之和是否为i，如果找到，验证成功。因为素数数组为有序存储，当两个数相加比i大时，不需要再判断后面的数。</li></ul><p>（5）问题的进一步讨论</p><p>上面的方法可以写出3个算法，大家可以尝试写一写，然后分析时间复杂度、空间复杂度如何？哪个算法更优一些？是不是还可以做到更好？</p><h3 id="1-5-算法学习瓶颈">1.5　算法学习瓶颈</h3><p>很多人感叹：算法为什么这么难！</p><p>一个原因是，算法本身具有一定的复杂性，还有一个原因：讲得不到位！</p><p>算法的教与学有两个困难。</p><p>（1）我们学习了那些经典的算法，在惊叹它们奇妙的同时，难免疑虑重重：这些算法是怎么被想到的？这可能是最费解的地方。高手讲，学算法要学它的来龙去脉，包括种种证明。但这对菜鸟来说，这简直比登天还难，很可能花费很多时间也无法搞清楚。对大多数人来说，这条路是行不通的，那怎么办呢？下功夫去记忆书上的算法？记住这些算法的效率？这样做看似学会了，其实两手空空，遇到一个新问题，仍然无从下手。可这偏偏又是极重要的，无论做研究还是实际工作，一个计算机专业人士最重要的能力就是解决问题——解决那些不断从实际应用中冒出来的新问题。</p><p>（2）算法作为一门学问，有两条几乎平行的线索。一个是 <strong>数据结构</strong> （数据对象）：数、矩阵、集合、串、排列、图、表达式、分布等。另一个是 <strong>算法策略</strong> ：贪心、分治、动态规划、线性规划、搜索等。这两条线索是相互独立的：同一个数据对象（如图）上有不同的问题（如单源最短路径和多源最短路径），就可以用到不同的算法策略（例如贪婪和动态规划）；而完全不同的数据对象上的问题（如排序和整数乘法），也许就会用到相同的算法策略（如分治）。</p><p>两条线索交织在一起，该如何表述？我们早已习惯在一章中完全讲排序，而在另一章中完全讲图论算法。还没有哪一本算法书很好地解决这两个困难，传统的算法书大多注重内容的收录，但却忽视思维过程的展示，因此我们学习了经典的算法，却费解于算法设计的过程。</p><p>本书从问题出发，根据实际问题分析、设计合适的算法策略，然后在数据结构上操作实现，巧妙地将数据结构和算法策略拧成了一条线。通过大量实例，充分展现算法设计的思维过程，让读者充分体会求解问题的思路，如何分析？使用什么算法策略？采用什么数据结构？算法的复杂性如何？是否有优化的可能？</p><p>这里，我们培养的是让读者怀着一颗好奇心去思考问题、解决问题。更重要的是——体会学习的乐趣，发现算法的美！</p><h3 id="1-6-你怕什么">1.6　你怕什么</h3><p>本章主要说明以下问题。</p><p>（1）将程序执行次数作为时间复杂度衡量标准。</p><p>（2）时间复杂度通常用渐近上界符号f(n)表示。</p><p>（3）衡量算法的好坏通常考查算法的最坏情况。</p><p>（4）空间复杂度只计算辅助空间。</p><p>（5）递归算法的空间复杂度要计算递归使用的栈空间。</p><p>（6）设计算法时尽量避免爆炸级增量复杂度。</p><p>通过本章的学习，我们对算法有了初步的认识，算法就在我们的生活中。任何一个算法都不是凭空造出来的，而是来源于实际中的某一个问题，由此推及一类、一系列问题，所以算法的本质是高效地解决实际问题。本章部分内容或许你不是很清楚，不必灰心，还记得我在前言中说的“ <strong>大视野</strong> ， <strong>不求甚解</strong> ”吗？例如斐波那契数列的通项公式推导，不懂没关系，只要知道斐波那契数列用递归算法，时间复杂度是指数阶，这就够了。就像一个面包师一边和面，一边详细讲做好面包要多少面粉、多少酵母、多大火候，如果你对如何做面包非常好奇，大可津津有味地听下去，如果你只是饿了，那么只管吃好了。</p><p>通过算法，你可以与世界顶级大师进行灵魂交流，体会算法的妙处。</p><p>Donald Ervin Knuth说：“程序就是蓝色的诗”。而这首诗的灵魂就是算法，走进算法，你会发现无与伦比的美！</p><p>持之以恒地学习，没有什么是学不会的。行动起来，没有什么不可以！</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Markdown语法与外挂标签写法汇总</title>
      <link href="/posts/2013454d.html"/>
      <url>/posts/2013454d.html</url>
      
        <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/iflidrie/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/iflidrie/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/avatar.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/avatar.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://source.drie.cn/img/avatar.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://source.drie.cn/img/avatar.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard iflidrie %&#125; | &#123;% ghcard iflidrie, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=buefy %&#125; | &#123;% ghcard iflidrie, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=onedark %&#125; | &#123;% ghcard iflidrie, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=algolia %&#125; | &#123;% ghcard iflidrie, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://source.drie.cn/img/avatar.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://source.drie.cn/img/avatar.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://source.drie.cn/img/avatar.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://source.drie.cn/img/avatar.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://source.drie.cn/badge/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://source.drie.cn/badge/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup 风景1 春意盎然 &#x27;/gallery/风景1/&#x27; https://source.drie.cn/img/default<span class="emphasis">_cover_</span>1.webp %&#125;</span><br><span class="line">&#123;% galleryGroup 风景2 秋高气爽 &#x27;/gallery/风景2/&#x27; https://source.drie.cn/img/dark<span class="emphasis">_mode.webp %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% galleryGroup 卡通人物 漫画人物 &#x27;/gallery/卡通人物/&#x27; https://source.drie.cn/img/default_</span>cover<span class="emphasis">_209.webp %&#125;</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/default_cover_1.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">风景1</div>  <p>春意盎然</p>  <a href='/gallery/%E9%A3%8E%E6%99%AF1/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/dark_mode.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">风景2</div>  <p>秋高气爽</p>  <a href='/gallery/%E9%A3%8E%E6%99%AF2/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/default_cover_209.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">卡通人物</div>  <p>漫画人物</p>  <a href='/gallery/%E5%8D%A1%E9%80%9A%E4%BA%BA%E7%89%A9/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://source.drie.cn/img/default_cover_177.webp</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://source.drie.cn/img/default_cover_177.webp</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/cat.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://source.drie.cn/img/default_cover_177.webp" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://source.drie.cn/img/cat.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 演示 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> 外挂标签 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
