<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《趣学算法》——第二章（贪心算法） | Drie🦋</title><meta name="keywords" content="Java,MySQL,算法,代码,博客,Butterfly,Hexo,Drie🦋,Drie"><meta name="author" content="Drie🦋"><meta name="copyright" content="Drie🦋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第二章　贪心算法 从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相还不满足，还要求做皇帝。蛇此时终于明白了，人的贪心是永无止境的，于是一口就把这个人吞掉了。 所以，蛇吞掉的是宰相，而不是大象。故此，留下了“人心不足蛇吞相”的典故。 2.1">
<meta property="og:type" content="article">
<meta property="og:title" content="《趣学算法》——第二章（贪心算法）">
<meta property="og:url" content="https://drie.cn/posts/7177a99d.html">
<meta property="og:site_name" content="Drie🦋">
<meta property="og:description" content="第二章　贪心算法 从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相还不满足，还要求做皇帝。蛇此时终于明白了，人的贪心是永无止境的，于是一口就把这个人吞掉了。 所以，蛇吞掉的是宰相，而不是大象。故此，留下了“人心不足蛇吞相”的典故。 2.1">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.drie.cn/qxsf-images/105.jpg">
<meta property="article:published_time" content="2024-07-02T01:00:00.000Z">
<meta property="article:modified_time" content="2024-07-02T01:44:15.348Z">
<meta property="article:author" content="Drie🦋">
<meta property="article:tag" content="Java,MySQL,算法,代码,博客,Butterfly,Hexo,Drie🦋,Drie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.drie.cn/qxsf-images/105.jpg"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://drie.cn/posts/7177a99d"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://source.drie.cn/js/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《趣学算法》——第二章（贪心算法）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-02 09:44:15'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://source.drie.cn/js/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://source.drie.cn/js/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://source.drie.cn/js/carousel-touch.js"></script><link rel="stylesheet" href="https://source.drie.cn/js/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://source.drie.cn/js/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Drie🦋" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/img/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span class="menu_word" style="font-size:17px"> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/ps/"><i class="fa-fw fas fa-diamond faa-tada"></i><span class="menu_word" style="font-size:17px"> 在线PS</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/qr/"><i class="fa-fw fas fa-qrcode faa-tada"></i><span class="menu_word" style="font-size:17px"> 二维码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/vip/"><i class="fa-fw fas fa-television faa-tada"></i><span class="menu_word" style="font-size:17px"> 视频解析</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Drie🦋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span class="menu_word" style="font-size:17px"> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/ps/"><i class="fa-fw fas fa-diamond faa-tada"></i><span class="menu_word" style="font-size:17px"> 在线PS</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/qr/"><i class="fa-fw fas fa-qrcode faa-tada"></i><span class="menu_word" style="font-size:17px"> 二维码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/vip/"><i class="fa-fw fas fa-television faa-tada"></i><span class="menu_word" style="font-size:17px"> 视频解析</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">《趣学算法》——第二章（贪心算法）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-02T01:00:00.000Z" title="发表于 2024-07-02 09:00:00">2024-07-02</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-02T01:44:15.348Z" title="更新于 2024-07-02 09:44:15">2024-07-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">3.2w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>117分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《趣学算法》——第二章（贪心算法）"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第二章-贪心算法">第二章　贪心算法</h3>
<p>从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相还不满足，还要求做皇帝。蛇此时终于明白了，人的贪心是永无止境的，于是一口就把这个人吞掉了。</p>
<p>所以，蛇吞掉的是宰相，而不是大象。故此，留下了“人心不足蛇吞相”的典故。</p>
<h3 id="2-1-人之初，性本贪">2.1　人之初，性本贪</h3>
<p>我们小时候背诵《三字经》，“人之初，性本善，性相近，习相远。”其实我觉得很多时候“人之初，性本贪”。小孩子吃糖果，总是想要多多的；吃水果，想要最大的；买玩具，总是想要最好的，这些东西并不是大人教的，而是与生俱来的。对美好事物的趋优性，就像植物的趋光性，“良禽择木而栖，贤臣择主而事”“窈窕淑女，君子好逑”，我们似乎永远在追求美而优的东西。现实中的很多事情，正是因为趋优性使我们的生活一步一步走向美好。例如，我们竭尽所能买了一套房子，然后就想要添置一些新的家具，再就想着可能还需要一辆车子……</p>
<p>凡事都有两面性，一把刀可以做出美味佳肴，也可以变成杀人凶器。在这里，我们只谈好的“贪心”。</p>
<h3 id="2-1-1-贪心本质">2.1.1　贪心本质</h3>
<p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。</p>
<p>——《算法导论》</p>
<p>我们经常会听到这些话：“人要活在当下”“看清楚眼前”……贪心算法正是“活在当下，看清楚眼前”的办法，从问题的初始解开始，一步一歩地做出当前最好的选择，逐步逼近问题的目标，尽可能地得到最优解，即使达不到最优解，也可以得到最优解的近似解。</p>
<p>贪心算法在解决问题的策略上“目光短浅”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。贪心算法能得到许多问题的整体最优解或整体最优解的近似解。因此，贪心算法在实际中得到大量的应用。</p>
<p>在贪心算法中，我们需要注意以下几个问题。</p>
<p>（1）没有后悔药。一旦做出选择，不可以反悔。</p>
<p>（2）有可能得到的不是最优解，而是最优解的近似解。</p>
<p>（3）选择什么样的贪心策略，直接决定算法的好坏。</p>
<p>那么，贪心算法需要遵循什么样的原则呢？</p>
<h3 id="2-1-2-贪亦有道">2.1.2　贪亦有道</h3>
<p>“君子爱财，取之有道”，我们在贪心算法中“贪亦有道”。通常我们在遇到具体问题时，往往分不清哪些问题该用贪心策略求解，哪些问题不能使用贪心策略。经过实践我们发现，利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。如果满足这两个性质就可以使用贪心算法了。</p>
<p>（1）贪心选择</p>
<p>所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前最佳的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。运用贪心策略解决的问题在程序的运行过程中无回溯过程。关于贪心选择性质，读者可在后续的贪心策略状态空间图中得到深刻的体会。</p>
<p>（2）最优子结构</p>
<p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。例如原问题S={a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">i</sub>，…，a<sub class="my_markdown">n</sub>}，通过贪心选择选出一个当前最优解{a<sub class="my_markdown">i</sub>}之后，转化为求解子问题S−{a<sub class="my_markdown">i</sub>}，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质，如图2-1所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/27.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-1　原问题和子问题</b></center>
<h3 id="2-1-3-贪心算法秘籍">2.1.3　贪心算法秘籍</h3>
<p>武林中有武功秘籍，算法中也有贪心秘籍。上面我们已经知道了具有贪心选择和最优子结构性质就可以使用贪心算法，那么如何使用呢？下面介绍贪心算法秘籍。</p>
<p>（1）贪心策略</p>
<p>首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大的，作为局部最优解，贪心策略就是选择当前最大的苹果；如果你认为最红的苹果是最好的，那你每次都从苹果堆中拿一个最红的，贪心策略就是选择当前最红的苹果。因此根据求解目标不同，贪心策略也会不同。</p>
<p>（2）局部最优解</p>
<p>根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为a<sub class="my_markdown">1</sub>，第二次再从剩下的苹果堆中选择一个最大的苹果放起来，记为a<sub>2</sub>，以此类推。</p>
<p>（3）全局最优解</p>
<p>把所有的局部最优解合成为原来问题的一个最优解（a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…）。</p>
<blockquote>
<p>怎么有点儿像冒泡排序啊？</p>
</blockquote>
<p>“不是六郎似荷花，而是荷花似六郎”！不是贪心算法像冒泡排序，而是冒泡排序使用了贪心算法，它的贪心策略就是每一次从剩下的序列中选一个最大的数，把这些选出来的数放在一起，就得到了从大到小的排序结果，如图2-2所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/28.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-2　冒泡排序</b></center>
<h3 id="2-2-加勒比海盗船——最优装载问题">2.2　加勒比海盗船——最优装载问题</h3>
<p>在北美洲东南部，有一片神秘的海域，那里碧海蓝天、阳光明媚，这正是传说中海盗最活跃的加勒比海（Caribbean Sea）。17世纪时，这里更是欧洲大陆的商旅舰队到达美洲的必经之地，所以当时的海盗活动非常猖獗，海盗不仅攻击过往商人，甚至攻击英国皇家舰……</p>
<p>有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值。虽然海盗船足够大，但载重量为C，每件古董的重量为w<sub class="my_markdown">i</sub>，海盗们该如何把尽可能多数量的宝贝装上海盗船呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/29.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-3　加勒比海盗</b></center>
<h3 id="2-2-1-问题分析">2.2.1　问题分析</h3>
<p>根据问题描述可知这是一个可以用贪心算法求解的最优装载问题，要求装载的物品的数量尽可能多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。采用重量最轻者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。</p>
<h3 id="2-2-2-算法设计">2.2.2　算法设计</h3>
<p>（1）当载重量为定值c时，w<sub class="my_markdown">i</sub>越小时，可装载的古董数量n越大。只要依次选择最小重量古董，直到不能再装为止。</p>
<p>（2）把n个古董的重量从小到大（非递减）排序，然后根据贪心策略尽可能多地选出前i个古董，直到不能继续装为止，此时达到最优。</p>
<h3 id="2-2-3-完美图解">2.2.3　完美图解</h3>
<p>我们现在假设这批古董如图2-4所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/30.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-4　古董图片</b></center>
<p>每个古董的重量如表2-1所示，海盗船的载重量c为30，那么在不能打碎古董又不超过载重的情况下，怎么装入最多的古董？</p>
<center class="my_markdown"><b class="my_markdown">表2-1　古董重量清单</b></center>
<p>| 重量w[i] | 4 | 10 | 7 | 11 | 3 | 5 | 14 | 2 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p>
<p>（1）因为贪心策略是每次选择重量最小的古董装入海盗船，因此可以按照古董重量非递减排序，排序后如表2-2所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-2　按重量排序后古董清单</b></center>
<p>| 重量w[i] | 2 | 3 | 4 | 5 | 7 | 10 | 11 | 14 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p>
<p>（2）按照贪心策略，每次选择重量最小的古董放入（tmp 代表古董的重量，ans 代表已装裁的古董个数）。</p>
<p>i=0，选择排序后的第1个，装入重量tmp=2，不超过载重量30，ans =1。</p>
<p>i=1，选择排序后的第2个，装入重量tmp=2+3=5，不超过载重量30，ans =2。</p>
<p>i=2，选择排序后的第3个，装入重量tmp=5+4=9，不超过载重量30，ans =3。</p>
<p>i=3，选择排序后的第4个，装入重量tmp=9+5=14，不超过载重量30，ans =4。</p>
<p>i=4，选择排序后的第5个，装入重量tmp=14+7=21，不超过载重量30，ans =5。</p>
<p>i=5，选择排序后的第6个，装入重量tmp=21+10=31，超过载重量30，算法结束。</p>
<p>即放入古董的个数为ans=5个。</p>
<h3 id="2-2-4-伪代码详解">2.2.4　伪代码详解</h3>
<p>（1）数据结构定义</p>
<p>根据算法设计描述，我们用一维数组存储古董的重量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> w[N];  <span class="comment">//一维数组存储古董的重量</span></span><br></pre></td></tr></table></figure>
<p>（2）按重量排序</p>
<p>可以利用C++中的排序函数sort（见附录B），对古董的重量进行从小到大（非递减）排序。要使用此函数需引入头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>语法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">//参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                <span class="comment">//sort函数默认为升序</span></span><br></pre></td></tr></table></figure>
<p>在本例中只需要调用sort函数对古董的重量进行从小到大排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(w, w+n); <span class="comment">//按古董重量升序排序</span></span><br></pre></td></tr></table></figure>
<p>（3）按照贪心策略找最优解</p>
<p>首先用变量ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量，两个变量都初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果小于等于载重量c，则令ans ++；否则，退出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = <span class="number">0</span>;  <span class="comment">//tmp代表装载到船上的古董的重量，ans记录已经装载的古董个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">     ans ++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-5-实战演练">2.2.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> w[N]; <span class="comment">//古董的重量数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入载重量c及古董个数n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个古董的重量，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]; <span class="comment">//输入每个物品重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(w,w+n); <span class="comment">//按古董重量升序排序</span></span><br><span class="line">    <span class="type">double</span> temp=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>; <span class="comment">// tmp为已装载到船上的古董重量，ans为已装载的古董个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp+=w[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">           ans ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;能装入的古董最大数量为Ans=&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入载重量c及古董个数n：</span><br><span class="line"><span class="number">30</span> <span class="number">8</span>   <span class="comment">//载重量c及古董的个数n </span></span><br><span class="line">请输入每个古董的重量，用空格分开：</span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">7</span> <span class="number">11</span> <span class="number">3</span> <span class="number">5</span> <span class="number">14</span> <span class="number">2</span>  <span class="comment">//每个古董的重量，用空格隔开</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能装入的古董最大数量为Ans=<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-算法解析及优化拓展">2.2.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析">1．算法复杂度分析</h4>
<p>（1）时间复杂度：首先需要按古董重量排序，调用sort函数，其平均时间复杂度为O(nlogn)，输入和贪心策略求解的两个for语句时间复杂度均为O(n)，因此时间复杂度为O(n + nlog(n))。</p>
<p>（2）空间复杂度：程序中变量tmp、ans等占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为O(1)。</p>
<h4 id="2．优化拓展">2．优化拓展</h4>
<p>（1）这一个问题为什么在没有装满的情况下，仍然是最优解？算法要求装入最多数量，假如c为5，4个物品重量分别为1、3、5、7。排序后，可以装入1和3，最多装入两个。分析发现是最优的，如果装大的物品，最多装一个或者装不下，所以选最小的先装才能装入最多的数量，得到解是最优的。</p>
<p>（2）在伪代码详解的第3步“按照贪心策略找最优解”，如果把代码替换成下面代码，有什么不同？</p>
<p>首先用变量ans记录已经装载的古董个数，初始化为n；tmp代表装载到船上的古董的重量，初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果tmp大于等于载重量c，则判断是否正好等于载重量c，并令ans=i+1；否则ans = i，退出。如果tmp小于载重量c，i++，继续下一个循环。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = n;  <span class="comment">//ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&gt;=c)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(tmp==c) <span class="comment">//假如刚好，最后一个可以放</span></span><br><span class="line">        ans = i+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        ans = i; <span class="comment">//如果满了，最后一个不能放</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）如果想知道装入了哪些古董，需要添加什么程序来实现呢？请大家动手试一试吧！</p>
<p>那么，还有没有更好的算法来解决这个问题呢？</p>
<h3 id="2-3-阿里巴巴与四十大盗——背包问题">2.3　阿里巴巴与四十大盗——背包问题</h3>
<p>有一天，阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时，远处突然出现一股烟尘，弥漫着直向上空飞扬，朝他这儿卷过来，而且越来越近。靠近以后，他才看清原来是一支马队，他们共有四十人，一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋，从丛林中一直来到那个大石头跟前，喃喃地说道：“芝麻，开门吧！”随着那个头目的喊声，大石头前突然出现一道宽阔的门路，于是强盗们鱼贯而入。阿里巴巴待在树上观察他们，直到他们走得无影无踪之后，才从树上下来。他大声喊道：“芝麻，开门吧！”他的喊声刚落，洞门立刻打开了。他小心翼翼地走了进去，一下子惊呆了，洞中堆满了财物，还有多得无法计数的金银珠宝，有的散堆在地上，有的盛在皮袋中。突然看见这么多的金银财富，阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界，见识一下这些宝物，他想一种宝物只拿一个，如果太重就用锤子凿开，但毛驴的运载能力是有限的，怎么才能用驴子运走最大价值的财宝分给穷人呢？</p>
<p>阿里巴巴陷入沉思中……</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/31.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-5　阿里巴巴与四十大盗</b></center>
<h3 id="2-3-1-问题分析">2.3.1　问题分析</h3>
<p>假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？</p>
<p>我们可以尝试贪心策略：</p>
<p>（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？</p>
<p>（2）每次挑选重量最小的宝物装入，能否得到最优解？</p>
<p>（3）每次选取单位重量价值最大的宝物，能否使价值最高？</p>
<p>思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第1种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第2种策略舍弃；而第3种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大。</p>
<p>因此采用第3种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。</p>
<h3 id="2-3-2-算法设计">2.3.2　算法设计</h3>
<p>（1）数据结构及初始化。将n种宝物的重量和价值存储在结构体three（包含重量、价值、性价比3个成员）中，同时求出每种宝物的性价比也存储在对应的结构体three中，将其按照性价比从高到低排序。采用sum来存储毛驴能够运走的最大价值，初始化为0。</p>
<p>（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于m（毛驴运载能力），如果小于m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m减去放入宝物的重量；如果不小于m，则取该宝物的一部分m * p[i]，m=0，程序结束。m减少到0，则sum得到最大值。</p>
<h3 id="2-3-3-完美图解">2.3.3　完美图解</h3>
<p>假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入最大价值的物品？</p>
<center class="my_markdown"><b class="my_markdown">表2-3　宝物清单</b></center>
<p>| 宝物i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 重量w[i] | 4 | 2 | 9 | 5 | 5 | 8 | 5 | 4 | 5 | 5 |<br>
| 价值v[i] | 3 | 8 | 18 | 6 | 8 | 20 | 5 | 6 | 7 | 15 |</p>
<p>（1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，可以按照性价比降序排序，排序后如表2-4所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-4　排序后宝物清单</b></center>
<p>| 宝物i | 2 | 10 | 6 | 3 | 5 | 8 | 9 | 4 | 7 | 1 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 重量w[i] | 2 | 5 | 8 | 9 | 5 | 4 | 5 | 5 | 5 | 4 |<br>
| 价值v[i] | 8 | 15 | 20 | 18 | 8 | 6 | 7 | 6 | 5 | 3 |<br>
| 性价比p[i] | 4 | 3 | 2.5 | 2 | 1.6 | 1.5 | 1.4 | 1.2 | 1 | 0.75 |</p>
<p>（2）按照贪心策略，每次选择性价比高的宝物放入：</p>
<p>第1次选择宝物2，剩余容量30−2=28，目前装入最大价值为8。</p>
<p>第2次选择宝物10，剩余容量28−5=23，目前装入最大价值为8+15=23。</p>
<p>第3次选择宝物6，剩余容量23−8=15，目前装入最大价值为23+20=43。</p>
<p>第4次选择宝物3，剩余容量15−9=6，目前装入最大价值为43+18=61。</p>
<p>第5次选择宝物5，剩余容量6−5=1，目前装入最大价值为61+8=69。</p>
<p>第6次选择宝物8，发现上次处理完时剩余容量为1，而8号宝物重量为4，无法全部放入，那么可以采用部分装入的形式，装入1个重量单位，因为8号宝物的单位重量价值为1.5，因此放入价值1×1.5=1.5，你也可以认为装入了8号宝物的1/4，目前装入最大价值为69+1.5=70.5，剩余容量为0。</p>
<p>（3）构造最优解</p>
<p>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了8号财宝的1/4），能够装入宝物的最大价值为70.5。</p>
<h3 id="2-3-4-伪代码详解">2.3.4　伪代码详解</h3>
<p>（1）数据结构定义</p>
<p>根据算法设计中的数据结构，我们首先定义一个结构体three：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w; <span class="comment">//每种宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v; <span class="comment">//每种宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p; <span class="comment">//每种宝物的性价比（价值/重量）</span></span><br><span class="line">     ｝</span><br></pre></td></tr></table></figure>
<p>（2）性价比排序</p>
<p>我们可以利用C++中的排序函数sort（见附录B），对宝物的性价比从大到小（非递增）排序。要使用此函数需引入头文件：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>语法描述为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">// 参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br></pre></td></tr></table></figure>
<p>在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不使用自定义比较函数，那么sort函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span><span class="comment">//比较函数按照宝物性价比降序排列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p &gt; b.p; <span class="comment">//指明按照宝物性价比降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(s, s+n, cmp); <span class="comment">//前两个参数分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                   <span class="comment">//最后一个参数compare表示比较的类型</span></span><br></pre></td></tr></table></figure>
<p>（3）贪心算法求解</p>
<p>在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入宝物的最大价值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="comment">//按照排好的顺序，执行贪心策略</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>( m &gt; s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量</span></span><br><span class="line">     &#123;</span><br><span class="line">        m -= s[i].w;</span><br><span class="line">        sum += s[i].v;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">      &#123;</span><br><span class="line">         sum += m乘以s[i].p;  <span class="comment">//进行宝物切割，切割一部分(m重量)，正好达到驴子承重</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-5-实战演练">2.3.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w;<span class="comment">//每个宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v;<span class="comment">//每个宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p;<span class="comment">//性价比</span></span><br><span class="line">&#125;s[M];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a.p&gt;b.p;<span class="comment">//根据宝物的单位价值从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;<span class="comment">//n 表示有n个宝物</span></span><br><span class="line">     <span class="type">double</span> m ;<span class="comment">//m 表示毛驴的承载能力</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入宝物数量n及毛驴的承载能力m ：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个宝物的重量和价值，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s[i].w&gt;&gt;s[i].v;</span><br><span class="line">         s[i].p=s[i].v/s[i].w;<span class="comment">//每个宝物单位价值</span></span><br><span class="line">     &#125;</span><br><span class="line">     sort(s,s+n,cmp);</span><br><span class="line">     <span class="type">double</span> sum=<span class="number">0.0</span>;<span class="comment">// sum表示贪心记录运走宝物的价值之和</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//按照排好的顺序贪心</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>( m&gt;s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              m-=s[i].w;</span><br><span class="line">              sum+=s[i].v;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              sum+=m*s[i].p;<span class="comment">//部分装入</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入宝物的最大价值Maximum value=&quot;</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">19</span> <span class="comment">//宝物数量，驴子的承载重量</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span> <span class="comment">//第1个宝物的重量和价值</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="comment">//第2个宝物的重量和价值</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maxinum value=<span class="number">24.6</span></span><br></pre></td></tr></table></figure>
<h3 id="2-3-6-算法解析及优化拓展">2.3.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4>
<p>（1）时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为O(nlogn)。</p>
<p>（2）空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为O(n)。</p>
<p>为了使 m 重量里的所有物品的价值最大，利用贪心思想，每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得到的价值更大，因此采用贪心策略能得到最优解。</p>
<h4 id="2．算法优化拓展">2．算法优化拓展</h4>
<p>那么想一想，如果宝物不可分割，贪心算法是否能得到最优解？</p>
<p>下面我们看一个简单的例子。</p>
<p>假定物品的重量和价值已知，如表2-5所示，最大运载能力为10。采用贪心算法会得到怎样的结果？</p>
<center class="my_markdown"><b class="my_markdown">表2-5　物品清单</b></center>
<p>| 物品i | 1 | 2 | 3 | 4 | 5 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 重量w[i] | 3 | 4 | 6 | 10 | 7 |<br>
| 价值v[i] | 15 | 16 | 18 | 25 | 14 |<br>
| 性价比p[i] | 5 | 4 | 3 | 2.5 | 2 |</p>
<p>如果我们采用贪心算法，先装性价比高的物品，且物品不能分割，剩余容量如果无法再装入剩余的物品，不管还有没有运载能力，算法都会结束。那么我们选择的物品为 1和2，总价值为 31，而实际上还有 3 个剩余容量，但不足以装下剩余其他物品，因此得到的最大价值为31。但实际上我们如果选择物品2和3，正好达到运载能力，得到的最大价值为34。也就是说，在物品不可分割、没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。</p>
<p>想一想，为什么会这样呢？</p>
<p>物品可分割的装载问题我们称为 <strong>背包问题</strong> ，物品不可分割的装载问题我们称之为 <strong>0-1背包问题</strong> 。</p>
<p>在物品不可分割的情况下，即0-1背包问题，已经不具有贪心选择性质，原问题的整体最优解无法通过一系列局部最优的选择得到，因此这类问题得到的是近似解。如果一个问题不要求得到最优解，而只需要一个最优解的近似解，则不管该问题有没有贪心选择性质都可以使用贪心算法。</p>
<p>想一想，2.3节中加勒比海盗船问题为什么在没有装满的情况下，仍然是最优解，而0-1背包问题在没装满的情况下有可能只是最优解的近似解？</p>
<h3 id="2-4-高级钟点秘书——会议安排">2.4　高级钟点秘书——会议安排</h3>
<p>所谓“钟点秘书”，是指年轻白领女性利用工余时间为客户提供秘书服务，并按钟点收取酬金。</p>
<p>“钟点秘书”为客户提供有偿服务的方式一般是：采用电话、电传、上网等“遥控”式服务，或亲自到客户公司处理部分业务。其服务对象主要有三类：一是外地前来考察商务经营、项目投资的商人或政要人员，他们由于初来乍到，急需有经验和熟悉本地情况的秘书帮忙；二是前来开展短暂商务活动，或召开小型资讯发布会的国外客商；三是本地一些请不起长期秘书的企、事业单位。这些客户普遍认为：请“钟点秘书”，一则可免去专门租楼请人的大笔开销；二则可根据开展的商务活动请有某方面专长的可用人才；三则由于对方是临时雇用关系，工作效率往往比固定的秘书更高。据调查，在上海“钟点秘书”的行情日趋看好。对此，业内人士认为：为了便于管理，各大城市有必要组建若干家“钟点秘书服务公司”，通过会员制的形式，为众多客户提供规范、优良、全面的服务，这也是建设国际化大都市所必需的。</p>
<p>某跨国公司总裁正分身无术，为一大堆会议时间表焦头烂额，希望高级钟点秘书能做出合理的安排，能在有限的时间内召开更多的会议。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/32.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-6　高级钟点秘书</b></center>
<h3 id="2-4-1-问题分析">2.4.1　问题分析</h3>
<p>这是一个典型的会议安排问题，会议安排的目的是能在有限的时间内召开更多的会议（任何两个会议不能同时进行）。在会议安排中，每个会议i都有起始时间b<sub class="my_markdown">i</sub>和结束时间e<sub class="my_markdown">i</sub>，且b<sub class="my_markdown">i</sub>&lt;e<sub class="my_markdown">i</sub>，即一个会议进行的时间为半开区间[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）。如果[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）与[b<sub class="my_markdown">j</sub>，e<sub class="my_markdown">j</sub>）均在“有限的时间内”，且不相交，则称会议i与会议j相容的。也就是说，当b<sub class="my_markdown">i</sub>≥e<sub class="my_markdown">j</sub>或b<sub class="my_markdown">j</sub>≥e<sub class="my_markdown">i</sub>时，会议i与会议j相容。会议安排问题要求在所给的会议集合中选出最大的相容活动子集，即尽可能在有限的时间内召开更多的会议。</p>
<p>在这个问题中，“有限的时间内（这段时间应该是连续的）”是其中的一个限制条件，也应该是有一个起始时间和一个结束时间（简单化，起始时间可以是会议最早开始的时间，结束时间可以是会议最晚结束的时间），任务就是实现召开更多的满足在这个“有限的时间内”等待安排的会议，会议时间表如表2-6所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-6　会议时间表</b></center>
<p>| 会议i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 开始时间b<sub class="my_markdown">i</sub> | 8 | 9 | 10 | 11 | 13 | 14 | 15 | 17 | 18 | 16 |<br>
| 结束时间e<sub class="my_markdown">i</sub> | 10 | 11 | 15 | 14 | 16 | 17 | 17 | 18 | 20 | 19 |</p>
<p>会议安排的时间段如图2-7所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/33.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-7　会议安排时间段</b></center>
<p>从图2-7中可以看出，{会议1，会议4，会议6，会议8，会议9}，{会议2，会议4，会议7，会议8，会议9}都是能安排最多的会议集合。</p>
<p>要让会议数最多，我们需要选择最多的不相交时间段。我们可以尝试贪心策略：</p>
<p>（1）每次从剩下未安排的会议中选择会议 <strong>具有最早开始时间且与已安排的会议相容</strong> 的会议安排，以增大时间资源的利用率。</p>
<p>（2）每次从剩下未安排的会议中选择 <strong>持续时间最短且与已安排的会议相容</strong> 的会议安排，这样可以安排更多一些的会议。</p>
<p>（3）每次从剩下未安排的会议中选择 <strong>具有最早结束时间且与已安排的会议相容</strong> 的会议安排，这样可以尽快安排下一个会议。</p>
<p>思考一下，如果选择最早开始时间，则如果会议持续时间很长，例如8点开始，却要持续12个小时，这样一天就只能安排一个会议；如果选择持续时间最短，则可能开始时间很晚，例如19点开始，20点结束，这样也只能安排一个会议，所以我们最好选择那些开始时间要早，而且持续时间短的会议，即最早开始时间+持续时间最短，就是 <strong>最早结束</strong> 时间。</p>
<p>因此采用第（3）种 <strong>贪心策略，每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排</strong> 。</p>
<h3 id="2-4-2-算法设计">2.4.2　算法设计</h3>
<p>（1）初始化：将n个会议的开始时间、结束时间存放在结构体数组中（想一想，为什么不用两个一维数组分别存储？），如果需要知道选中了哪些会议，还需要在结构体中增加会议编号，然后按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）；</p>
<p>（2）根据贪心策略就是选择第一个具有最早结束时间的会议，用last记录刚选中会议的结束时间；</p>
<p>（3）选择第一个会议之后，依次 <strong>从剩下未安排的会议中选择</strong> ，如果会议i开始时间大于等于最后一个选中的会议的结束时间last，那么会议i与已选中的会议相容，可以安排，更新last为刚选中会议的结束时间；否则，舍弃会议i，检查下一个会议是否可以安排。</p>
<h3 id="2-4-3-完美图解">2.4.3　完美图解</h3>
<h4 id="1．原始的会议时间表（见表2-7）：">1．原始的会议时间表（见表2-7）：</h4>
<center class="my_markdown"><b class="my_markdown">表2-7　原始会议时间表</b></center>
<p>| 会议num | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 开始时间beg | 3 | 1 | 5 | 2 | 5 | 3 | 8 | 6 | 8 | 12 |<br>
| 结束时间end | 6 | 4 | 7 | 5 | 9 | 8 | 11 | 10 | 12 | 14 |</p>
<h4 id="2．排序后的会议时间表（见表2-8）：">2．排序后的会议时间表（见表2-8）：</h4>
<center class="my_markdown"><b class="my_markdown">表2-8　排序后的会议时间表</b></center>
<p>| 会议num | 2 | 4 | 1 | 3 | 6 | 5 | 8 | 7 | 9 | 10 |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 开始时间beg | 1 | 2 | 3 | 5 | 3 | 5 | 6 | 8 | 8 | 12 |<br>
| 结束时间end | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 14 |</p>
<h4 id="3．贪心选择过程">3．贪心选择过程</h4>
<p>（1）首先选择排序后的第一个会议即最早结束的会议（编号为2），用last记录最后一个被选中会议的结束时间，last=4。</p>
<p>（2）检查余下的会议，找到第一个开始时间大于等于 last（last=4）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-9所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-9　会议时间表</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/34.jpg" alt="code"><br>
从子问题中，选择第一个会议即最早结束的会议（编号为3)，更新last为刚选中会议的结束时间last=7。</p>
<p>（3）检查余下的会议，找到第一个开始时间大于等于last（last=7）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-10所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-10　会议时间表</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/35.jpg" alt="code"><br>
从子问题中，选择第一个会议即最早结束的会议（编号为 7)，更新 last 为刚选中会议的结束时间last=11。</p>
<p>（4）检查余下的会议，找到第一个开始时间大于等于last（last=11）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-11所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-11　会议时间表</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/36.jpg" alt="code"><br>
从子问题中，选择第一个会议即最早结束的会议（编号为10)，更新last为刚选中会议的结束时间last=14；所有会议检查完毕，算法结束。如表2-12所示。</p>
<h4 id="4．构造最优解">4．构造最优解</h4>
<p>从贪心选择的结果，可以看出，被选中的会议编号为{2，3，7，10}，可以安排的会议数量最多为4，如表2-12所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-12　会议时间表</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/37.jpg" alt="code"></p>
<h3 id="2-4-4-伪代码详解">2.4.4　伪代码详解</h3>
<p>（1）数据结构定义</p>
<p>以下C++程序代码中，结构体meet中定义了beg表示会议的开始时间，end表示会议的结束时间，会议meet的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">&#125; meet[<span class="number">1000</span>]；</span><br></pre></td></tr></table></figure>
<p>（2）对会议按照结束时间非递减排序</p>
<p>我们采用C++中自带的sort函数，自定义比较函数的办法，实现会议排序，按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.end==y.end)  <span class="comment">//结束时间相等时 </span></span><br><span class="line">        <span class="keyword">return</span> x.beg&gt;y.beg; <span class="comment">//按开始时间从大到小排序</span></span><br><span class="line">     <span class="keyword">return</span> x.end&lt;y.end; <span class="comment">//按结束时间从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(meet,meet+n,cmp);</span><br></pre></td></tr></table></figure>
<p>（3）会议安排问题的贪心算法求解</p>
<p>在会议按结束时间非递减排序的基础上，首先选中第一个会议，用last变量记录刚刚被选中会议的结束时间。下一个会议的开始时间与last比较，如果大于等于last，则选中。每次选中一个会议，更新last为最后一个被选中会议的结束时间，被选中的会议数ans加1；如果会议的开始时间不大于等于last，继续考查下一个会议，直到所有会议考查完毕。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;     <span class="comment">//用来记录可以安排会议的个数，初始时选中了第一个会议</span></span><br><span class="line"><span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//last记录第一个会议的结束时间</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n; i++)   <span class="comment">//依次检查每个会议</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(meet[i].beg &gt; =last) </span><br><span class="line">    &#123;     <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">       ans++;</span><br><span class="line">       last = meet[i].end; <span class="comment">//更新last为最后一个选中会议的结束时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回可以安排的会议最大数</span></span><br></pre></td></tr></table></figure>
<p>上面介绍的程序中，只是返回了可以安排的会议最大数，而不知道安排了哪些会议，这显然是不满足需要的。我们可以改进一下，在会议结构体meet中添加会议编号num变量，选中会议时，显示选中了第几个会议。</p>
<h3 id="2-4-5-实战演练">2.4.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">     <span class="type">int</span> num;   <span class="comment">//记录会议的编号</span></span><br><span class="line">&#125;meet[<span class="number">1000</span>];    <span class="comment">//会议的最大个数为1000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">setMeet</span>&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">  private:</span><br><span class="line">    <span class="type">int</span> n,ans; <span class="comment">// n:会议总数 ans: 最大的安排会议总数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> s,e;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议总数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议的开始时间和结束时间，以空格分开：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">         meet[i].beg=s;</span><br><span class="line">         meet[i].end=e;</span><br><span class="line">         meet[i].num=i+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (x.end == y.end)</span><br><span class="line">           <span class="keyword">return</span> x.beg &gt; y.beg;</span><br><span class="line">     <span class="keyword">return</span> x.end &lt; y.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     sort(meet,meet+n,cmp);    <span class="comment">//对会议按结束时间排序</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;排完序的会议时间如下：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;会议编号&quot;</span>&lt;&lt;<span class="string">&quot;  开始时间 &quot;</span>&lt;&lt;<span class="string">&quot; 结束时间&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; meet[i].num&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;meet[i].beg &lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt; meet[i].end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-------------------------------------------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;选择的会议的过程：&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt; meet[<span class="number">0</span>].num&lt;&lt;<span class="string">&quot;个会议&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//选中了第一个会议</span></span><br><span class="line">     ans=<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//记录刚刚被选中会议的结束时间</span></span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(meet[i].beg&gt;=last)</span><br><span class="line">          &#123;            <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">             ans++;</span><br><span class="line">             last = meet[i].end;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt;meet[i].num&lt;&lt;<span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;最多可以安排&quot;</span> &lt;&lt;ans &lt;&lt; <span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setMeet sm;</span><br><span class="line">  sm.init();<span class="comment">//读入数据</span></span><br><span class="line">  sm.solve();<span class="comment">//贪心算法求解</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入会议总数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输入会议的开始时间和结束时间，以空格分开：</span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">排完序的会议时间如下：</span><br><span class="line">会议编号    开始时间    结束时间</span><br><span class="line">   <span class="number">2</span>           <span class="number">1</span>          <span class="number">4</span></span><br><span class="line">   <span class="number">4</span>           <span class="number">2</span>          <span class="number">5</span></span><br><span class="line">   <span class="number">1</span>           <span class="number">3</span>          <span class="number">6</span></span><br><span class="line">   <span class="number">3</span>           <span class="number">5</span>          <span class="number">7</span></span><br><span class="line">   <span class="number">6</span>           <span class="number">3</span>          <span class="number">8</span></span><br><span class="line">   <span class="number">5</span>           <span class="number">5</span>          <span class="number">9</span></span><br><span class="line">   <span class="number">8</span>           <span class="number">6</span>          <span class="number">10</span></span><br><span class="line">   <span class="number">7</span>           <span class="number">8</span>          <span class="number">11</span></span><br><span class="line">   <span class="number">9</span>           <span class="number">8</span>          <span class="number">12</span></span><br><span class="line">   <span class="number">10</span>          <span class="number">12</span>         <span class="number">14</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">选择的会议的过程：</span><br><span class="line">  选择第<span class="number">2</span>个会议</span><br><span class="line">  选择第<span class="number">3</span>个会议</span><br><span class="line">  选择第<span class="number">7</span>个会议</span><br><span class="line">  选择第<span class="number">10</span>个会议</span><br><span class="line">最多可以安排<span class="number">4</span>个会议</span><br></pre></td></tr></table></figure>
<p>使用上面贪心算法可得，选择的会议是第2、3、7、10个会议，输出最优值是4。</p>
<h3 id="2-4-6-算法解析及优化拓展">2.4.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4>
<p>（1）时间复杂度：在该算法中，问题的规模就是会议总个数n。显然，执行次数随问题规模的增大而变化。首先在成员函数setMeet::init()中，输入n个结构体数据。输入作为基本语句，显然，共执行n次。而后在调用成员函数setMeet::solve()中进行排序，易知sort排序函数的平均时间复杂度为O(nlogn)。随后进行选择会议，贡献最大的为if(meet[i].beg&gt;=last)语句，时间复杂度为O(n)，总时间复杂度为O(n +nlogn)= O(nlogn)。</p>
<p>（2）空间复杂度：在该算法中，meet[]结构体数组为输入数据，不计算在空间复杂度内。辅助空间有i、n、ans等变量，则该程序空间复杂度为常数阶，即O(1)。</p>
<h4 id="2．算法优化拓展-2">2．算法优化拓展</h4>
<p>想一想，你有没有更好的办法来处理此问题，比如有更小的算法时间复杂度？</p>
<h3 id="2-5-一场说走就走的旅行——最短路径">2.5　一场说走就走的旅行——最短路径</h3>
<p>有一天，孩子回来对我说：“妈妈，听说马尔代夫很不错，放假了我想去玩。”马尔代夫？我也想去！没有人不向往一场说走就走的旅行！“其实我想去的地方很多，呼伦贝尔大草原、玉龙雪山、布达拉宫、艾菲尔铁塔……”小孩子还说着他感兴趣的地方。于是我们拿出地图，标出想去的地点，然后计算最短路线，估算大约所需的时间，有了这张秘制地图，一场说走就走的旅行不是梦！</p>
<p>“哇，感觉我们像凡尔纳的《环游地球八十天》，好激动！可是老妈你也太out了，学计算机的最短路线你用手算？”</p>
<p>暴汗……，“小子你别牛，你知道怎么算？”</p>
<p>“呃，好像是叫什么迪科斯彻的人会算。”</p>
<p>哈哈，关键时刻还要老妈上场了！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/38.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-8　一场说走就走的旅行</b></center>
<h3 id="2-5-1-问题分析">2.5.1　问题分析</h3>
<p>根据题目描述可知，这是一个求单源最短路径的问题。给定有向带权图<strong>G</strong> =（V，Ｅ），其中每条边的权是非负实数。此外，给定V中的一个顶点，称为源点。现在要计算从源到所有其他各顶点的最短路径长度，这里路径长度指路上各边的权之和。</p>
<p>如何求源点到其他各点的最短路径呢？</p>
<p>如图2-9所示，艾兹格•W•迪科斯彻（Edsger Wybe Dijkstra），荷兰人，计算机科学家。他早年钻研物理及数学，后转而研究计算学。他曾在1972年获得过素有“计算机科学界的诺贝尔奖”之称的图灵奖，与Donald Ervin Knuth并称为我们这个时代最伟大的计算机科学家。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/39.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-9　艾兹格•W•迪科斯彻</b></center>
<h3 id="2-5-2-算法设计">2.5.2　算法设计</h3>
<p>Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径。</p>
<p>Dijkstra算法的基本思想是首先假定源点为u，顶点集合V被划分为两部分：集合S和 V−S。初始时 S 中仅含有源点 u，其中 S 中的顶点到源点的最短路径已经确定。集合V−S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V−S中的点的路径为特殊路径，并用数组dist[]记录当前每个顶点所对应的最短特殊路径长度。</p>
<p>Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径，将其连接的V−S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点之间的最短路径长度。</p>
<p>（1）数据结构。设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从源点u到顶点i有边，就令 <strong>map</strong>[u][i]等于&lt;u，i&gt;的权值，否则 <strong>map</strong>[u][i]=∞（无穷大）；采用一维数组 dist[i]来记录从源点到i顶点的最短路径长度；采用一维数组p[i]来记录最短路径上i顶点的前驱。</p>
<p>（2）初始化。令集合S={u}，对于集合V−S中的所有顶点x，初始化dist[i]=<strong>map</strong>[u][i]，如果源点u到顶点i有边相连，初始化p[i]=u，否则p[i]= −1。</p>
<p>（3）找最小。在集合V−S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t，即dist[t]=min（dist[j]|j属于V−S集合），则顶点t就是集合V−S中距离源点u最近的顶点。</p>
<p>（4）加入S战队。将顶点t加入集合S中，同时更新V−S。</p>
<p>（5）判结束。如果集合V−S为空，算法结束，否则转（6）。</p>
<p>（6）借东风。在（3）中已经找到了源点到t的最短路径，那么对集合V−S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dis[j]&gt;dist[t]+<strong>map</strong>[t][j]，则dist[j]=dist[t]+<strong>map</strong>[t][j]，记录顶点j的前驱为t，有p[j]= t，转（3）。</p>
<p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过数组p[]逆向找到最短路径上经过的城市。</p>
<h3 id="2-5-3-完美图解">2.5.3　完美图解</h3>
<p>现在我们有一个景点地图，如图2-10所示，假设从1号结点出发，求到其他各个结点的最短路径。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/40.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-10　景点地图</b></center>
<p>算法步骤如下。</p>
<p>（1）数据结构</p>
<p>设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从顶点i到顶点j有边，则<strong>map</strong>[i][j]等于&lt;i，j&gt;的权值，否则<strong>map</strong>[i][j]=∞（无穷大），如图2-11所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/41.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-11　邻接矩阵**map**[][]</b></center>
<p>（2）初始化</p>
<p>令集合S={1}，V−S={2，3，4，5}，对于集合V−S中的所有顶点x，初始化最短距离数组dist[i]=<strong>map</strong>[1][i]，dist[u]=0，如图2-12所示。如果源点1到顶点i有边相连，初始化前驱数组p[i]=1，否则p[i]= −1，如图2-13所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/42.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-12　最短距离数组dist[]</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/43.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-13　前驱数组p[]</b></center>
<p>（3）找最小</p>
<p>在集合V−S={2，3，4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-14所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/44.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-14　最短距离数组dist[]</b></center>
<p>找到最小值为2，对应的结点t=2。</p>
<p>（4）加入S战队</p>
<p>将顶点t=2加入集合S中S={1，2}，同时更新V−S={3，4，5}，如图2-15所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/45.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-15　景点地图</b></center>
<p>（5）借东风</p>
<p>刚刚找到了源点到t=2的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵都可以看出，2号结点的邻接点是3和4号结点，如图2-16所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/46.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-16　邻接矩阵**map**[][]</b></center>
<p>先看3号结点能否借助2号走捷径：dist[2]+<strong>map</strong>[2][3]=2+2=4，而当前dist[3]=5&gt;4，因此可以走捷径即2—3，更新dist[3]=4，记录顶点3的前驱为2，即p[3]= 2。</p>
<p>再看4号结点能否借助2号走捷径：如果dist[2]+<strong>map</strong>[2][4]=2+6=8，而当前dist[4]=∞&gt;8，因此可以走捷径即2—4，更新dist[4]=8，记录顶点4的前驱为2，即p[4]= 2。</p>
<p>更新后如图2-17和图2-18所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/47.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-17　最短距离数组dist[]</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/48.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-18　前驱数组p[]</b></center>
<p>（6）找最小</p>
<p>在集合V−S={3，4，5}中，依照贪心策略来寻找dist[]具有最小值的顶点t，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-19所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/49.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-19　最短距离数组dist[]</b></center>
<p>找到最小值为4，对应的结点t=3。</p>
<p>（7）加入S战队</p>
<p>将顶点t=3加入集合S中S={1，2，3}，同时更新V−S={4，5}，如图2-20所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/50.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-20　景点地图</b></center>
<p>（8）借东风</p>
<p>刚刚找到了源点到t =3的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，3号结点的邻接点是4和5号结点。</p>
<p>先看4号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][4]=4+7=11，而当前dist[4]=8&lt;11，比当前路径还长，因此不更新。</p>
<p>再看5号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][5]=4+1=5，而当前dist[5]=∞&gt;5，因此可以走捷径即3—5，更新dist[5]=5，记录顶点5的前驱为3，即p[5]=3。</p>
<p>更新后如图2-21和图2-22所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/51.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-21　最短距离数组dist[]</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/52.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-22　前驱数组p[]</b></center>
<p>（9）找最小</p>
<p>在集合V−S={4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-23所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/53.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-23　最短距离数组dist[]</b></center>
<p>找到最小值为5，对应的结点t=5。</p>
<p>（10）加入S战队</p>
<p>将顶点t=5加入集合S中S={1，2，3，5}，同时更新V−S={4}，如图2-24所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/54.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-24　景点地图</b></center>
<p>（11）借东风</p>
<p>刚刚找到了源点到t =5的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，5号结点没有邻接点，因此不更新，如图2-25和图2-26所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/56.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-26　前驱数组p[]</b></center>
<p>（12）找最小</p>
<p>在集合V−S={4}中，依照贪心策略来寻找dist[]最小的顶点t，只有一个顶点，所以很容易找到，如图2-27所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/57.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-27　最短距离数组dist[]</b></center>
<p>找到最小值为8，对应的结点t=4。</p>
<p>（13）加入S战队</p>
<p>将顶点t加入集合S中S={1，2，3，5，4}，同时更新V−S={ }，如图2-28所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/58.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-28　景点地图</b></center>
<p>（14）算法结束</p>
<p>V−S={ }为空时，算法停止。</p>
<p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过前驱数组p[]逆向找到最短路径上经过的城市，如图2-29所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/59.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-29　前驱数组p[]</b></center>
<p>例如，p[5]=3，即5的前驱是3；p[3]=2，即3的前驱是2；p[2]=1，即2的前驱是1；p[1]= −1，1没有前驱，那么从源点1到5的最短路径为1—2—3—5。</p>
<h3 id="2-5-4-伪代码详解">2.5.4　伪代码详解</h3>
<p>（1）数据结构</p>
<p>n：城市顶点个数。m：城市间路线的条数。<strong>map</strong>[][]：地图对应的带权邻接矩阵。dist[]：记录源点u到某顶点的最短路径长度。p[]：记录源点到某顶点的最短路径上的该顶点的前一个顶点（前驱）。flag[]：flag[i]等于true，说明顶点i已经加入到集合S，否则顶点i属于集合V−S。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">//初始化城市的个数，可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">//无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br></pre></td></tr></table></figure>
<p>（2）初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点（t的出边相关联的顶点）的前驱为u：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[n];<span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则i属于集合V-S</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      dist[i] = <span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">      flag[i]=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">         p[i]=<span class="number">-1</span>;   <span class="comment">//说明源点u到顶点i无边相连，设置p[i]=-1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         p[i]=u;   <span class="comment">//说明源点u到顶点i有边相连，设置p[i]=u</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>（3）初始化集合S，令集合S={u}，从源点到u的最短路径为0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag[u]=<span class="literal">true</span>;   <span class="comment">//初始化集合S中，只有一个元素：源点 u </span></span><br><span class="line">dist[u] = <span class="number">0</span>;   <span class="comment">//初始化源点 u的最短路径为0，自己到自己的最短路径</span></span><br></pre></td></tr></table></figure>
<p>（4）找最小</p>
<p>在集合V−S中寻找距离源点u最近的顶点t，若找不到t，则跳出循环；否则，将t加入集合S。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF,t = u ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j ++) <span class="comment">//在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">  <span class="keyword">if</span>( !flag[j] &amp;&amp; dist[j] &lt; temp)</span><br><span class="line">  &#123;</span><br><span class="line">     t=j;   <span class="comment">//记录距离源点u最近的顶点</span></span><br><span class="line">     temp=dist[j];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(t == u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">flag[t] = <span class="literal">true</span>;      <span class="comment">//否则，将t加入集合S</span></span><br></pre></td></tr></table></figure>
<p>（5）借东风</p>
<p>考查集合V−S中源点u到t的邻接点j的距离，如果源点u经过t到达j的路径更短，则更新dist[j] =dist[t]+<strong>map</strong>[t][j]，即松弛操作，并记录j的前驱为t：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)  <span class="comment">//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">   <span class="keyword">if</span>(!flag[j] &amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF) <span class="comment">//!flag[j]表示j在V-S中，map[t][j]&lt;INF表示t与j邻接</span></span><br><span class="line">      <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j])) <span class="comment">//经过t到达j的路径更短</span></span><br><span class="line">      &#123;</span><br><span class="line">         dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">         p[j]=t; <span class="comment">//记录j的前驱为t </span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>重复（4）～（5），直到源点u到所有顶点的最短路径被找到。</p>
<h3 id="2-5-5-实战演练">2.5.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 初始化无穷大为10000000</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;<span class="comment">//n城市的个数，m为城市间路线的条数</span></span><br><span class="line"><span class="type">bool</span> flag[N]; <span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//①</span></span><br><span class="line">    &#123;</span><br><span class="line">     dist[i] =<span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">     flag[i]=<span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">        p[i]=<span class="number">-1</span>; <span class="comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        p[i]=u; <span class="comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span></span><br><span class="line">     &#125;</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    flag[u]=<span class="literal">true</span>;   <span class="comment">//初始时，集合S中只有一个元素：源点u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//②</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> temp = INF,t = u;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="comment">//③在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">           <span class="keyword">if</span>(!flag[j]&amp;&amp;dist[j]&lt;temp)</span><br><span class="line">             &#123;</span><br><span class="line">              t=j;</span><br><span class="line">              temp=dist[j];</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span>(t==u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">           flag[t]= <span class="literal">true</span>;  <span class="comment">//否则，将t加入集合</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//④//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">             <span class="keyword">if</span>(!flag[j]&amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF)<span class="comment">//!s[j]表示j在V-S中  </span></span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j]))</span><br><span class="line">                 &#123;</span><br><span class="line">                   dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">                   p[j]=t ;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="type">int</span> u,v,w,st;</span><br><span class="line">             system(<span class="string">&quot;color 0d&quot;</span>);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线以及距离：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span>(m--)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">               <span class="built_in">map</span>[u][v] =min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; st;</span><br><span class="line">             Dijkstra(st);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明：&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot; - &quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">if</span>(dist[i] == INF)</span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短距离为:&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">11</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">29</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">32</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">27</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">21</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">19</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">5</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">1</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">2</span> 最短距离为：<span class="number">24</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">3</span> 最短距离为：<span class="number">23</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">4</span> 最短距离为：<span class="number">30</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">5</span> 最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>想一想：因为我们在程序中使用p[]数组记录了最短路径上每一个结点的前驱，因此除了显示最短距离外，还可以显示最短路径上经过了哪些城市，可以增加一段程序逆向找到该最短路径上的城市序列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findpath</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;s;<span class="comment">//利用C++自带的函数创建一个栈s，需要程序头部引入#include&lt;stack&gt;</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点为：&quot;</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    x=p[i];</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s.push(x);<span class="comment">//将前驱依次压入栈中</span></span><br><span class="line">      x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点到其他各顶点最短路径为：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="string">&quot;--&quot;</span>;<span class="comment">//依次取栈顶元素</span></span><br><span class="line">      s.pop();<span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;;最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只需要在主函数末尾调用该函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findpath(st);<span class="comment">//主函数中st为源点</span></span><br></pre></td></tr></table></figure>
<p>输出结果如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源点为：<span class="number">5</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>；最短距离为：<span class="number">8</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-2</span>；最短距离为：<span class="number">24</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>；最短距离为：<span class="number">23</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>-<span class="number">-4</span>；最短距离为：<span class="number">30</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>；最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure>
<h3 id="2-5-6-算法解析及优化拓展">2.5.6　算法解析及优化拓展</h3>
<h4 id="1．算法时间复杂度">1．算法时间复杂度</h4>
<p>（1）时间复杂度：在Dijkstra算法描述中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大，当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n= n²，算法的时间复杂度为O(n²)。</p>
<p>（2）空间复杂度：由以上算法可以得出，实现该算法所需要的辅助空间包含为数组flag、变量i、j、t和temp所分配的空间，因此，空间复杂度为O(n)。</p>
<h4 id="2．算法优化拓展-3">2．算法优化拓展</h4>
<p>在for语句③中，即在集合V−S中寻找距离源点u最近的顶点t，其时间复杂度为O(n)，如果我们使用优先队列，则可以把时间复杂度降为O(log n)。那么如何使用优先队列呢？</p>
<p>（1）优先队列（见附录C）</p>
<p>（2）数据结构</p>
<p>在上面的例子中，我们使用了一维数组dist[t]来记录源点u到顶点t的最短路径长度。在此为了操作方便，我们使用结构体的形式来实现，定义一个结构体Node，里面包含两个成员：u为顶点，step为源点到顶点u的最短路径。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         v = a;   <span class="comment">//参数传递，v为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递，step为源点到顶点v的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123; </span><br><span class="line">         <span class="keyword">return</span> step &gt; a.step; <span class="comment">//重载 &lt;，step(源点到顶点v的最短路径)最小值优先</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的结构体中除了两个成员变量外，还有一个构造函数和运算符优先级重载，下面详细介绍其含义用途。</p>
<p>为什么要使用构造函数？</p>
<p>如果不使用构造函数也是可以的，只定义一般的结构体，里面包含两个参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>那么在变量参数赋值时，需要这样赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node vs ; <span class="comment">//先定义一个Node结点类型变量</span></span><br><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>; <span class="comment">//分别对该变量的两个成员进行赋值</span></span><br></pre></td></tr></table></figure>
<p>采用构造函数的形式定义结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u = a;   <span class="comment">//参数传递u为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递step为源点到顶点u的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>则变量参数赋值就可以直接通过参数传递：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">vs</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span><br></pre></td></tr></table></figure>
<p>上面语句等价于：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>;</span><br></pre></td></tr></table></figure>
<p>很明显通过构造函数的形式定义结构体，参数赋值更方便快捷，后面程序中会将结点压入优先队列：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 创建优先队列，最小值优先</span></span><br><span class="line">Q.push(Node(i,dist[i])); <span class="comment">//将结点Node压入优先队列Q</span></span><br><span class="line">                         <span class="comment">//参数i传递给顶点v， dist[i]传递给step</span></span><br></pre></td></tr></table></figure>
<p>（3）使用优先队列优化的Dijkstra算法源代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],n,m;</span><br><span class="line"><span class="type">int</span> flag[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u=a;step=sp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123;  <span class="comment">// 重载 &lt;</span></span><br><span class="line">          <span class="keyword">return</span> step&gt;a.step;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">     <span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 优先队列优化</span></span><br><span class="line">     Q.push(Node(st,<span class="number">0</span>));</span><br><span class="line">     <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));<span class="comment">//初始化flag数组为0</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">       dist[i]=INF; <span class="comment">// 初始化所有距离为，无穷大</span></span><br><span class="line">     dist[st]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">     &#123;</span><br><span class="line">          Node it=Q.top();<span class="comment">//优先队列队头元素为最小值</span></span><br><span class="line">          Q.pop();</span><br><span class="line">          <span class="type">int</span> t=it.u;</span><br><span class="line">          <span class="keyword">if</span>(flag[t])<span class="comment">//说明已经找到了最短距离，该结点是队列里面的重复元素</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">          flag[t]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(!flag[i]&amp;&amp;<span class="built_in">map</span>[t][i]&lt;INF)&#123; <span class="comment">// 判断与当前点有关系的点，并且自己不能到自己</span></span><br><span class="line">                  <span class="keyword">if</span>(dist[i]&gt;dist[t]+<span class="built_in">map</span>[t][i])</span><br><span class="line">                  &#123;   <span class="comment">// 求距离当前点的每个点的最短距离,进行松弛操作</span></span><br><span class="line">                      dist[i]=dist[t]+<span class="built_in">map</span>[t][i];</span><br><span class="line">                      Q.push(Node(i,dist[i]));<span class="comment">// 把更新后的最短距离压入优先队列，注意：里面的元素有重复</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">          <span class="type">int</span> u,v,w,st;</span><br><span class="line">          system(<span class="string">&quot;color 0d&quot;</span>);<span class="comment">//设置背景及字体颜色</span></span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">             &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间u,v的路线以及距离w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">while</span>(m--)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">               <span class="built_in">map</span>[u][v]=min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;st;</span><br><span class="line">          Dijkstra(st);</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明:&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot;---&gt;&quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i;</span><br><span class="line">               <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">1</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">1</span> 最短距离为：<span class="number">0</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">2</span> 最短距离为：<span class="number">2</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">3</span> 最短距离为：<span class="number">3</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">4</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">5</span> 最短距离为：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>在使用优先队列的 Dijkstra 算法描述中，while (!Q.empty())语句执行的次数为n，因为要弹出n个最小值队列才会空；Q.pop()语句的时间复杂度为logn，while语句中的for语句执行n次，for语句中的Q.push (Node(i,dist[i]))时间复杂度为logn。因此，总的语句的执行次数为n* logn+n²*logn，算法的时间复杂度为O(n²logn)。</p>
<p>貌似时间复杂度又变大了？</p>
<p>这是因为我们采用的邻接矩阵存储的，如果采用邻接表存储（见附录D），那么for语句④松弛操作就不用每次执行n次，而是执行t结点的邻接边数x，每个结点的邻接边加起来为边数E，那么总的时间复杂度为O(n<em>logn+E</em>logn)，如果E≥n，则时间复杂度为O(E*logn)。</p>
<p><strong>注意：</strong> 优先队列中尽管有重复的结点，但重复结点最坏是n<sup class="my_markdown">2</sup>，log n<sup class="my_markdown">2</sup>=2 log n，并不改变时间复杂度的数量级。</p>
<p>想一想，还能不能把时间复杂度再降低呢？如果我们使用斐波那契堆，那么松弛操作的时间复杂度O(1)，总的时间复杂度为O(n* logn+E)。</p>
<h3 id="2-6-神秘电报密码——哈夫曼编码">2.6　神秘电报密码——哈夫曼编码</h3>
<p>看过谍战电影《风声》的观众都会对影片中神奇的消息传递惊叹不已！吴志国大队长在受了残忍的“针刑”之后躺在手术台上唱空城计，变了音调，把消息传给了护士，顾晓梦在衣服上缝补了长短不一的针脚……那么，片中无处不在的摩尔斯码到底是什么？它又有着怎样的神秘力量呢？</p>
<p>摩尔斯电码（Morse code）由点dot（. ）、划dash（-）两种符号组成。它的基本原理是：把英文字母表中的字母、标点符号和空格按照出现的频率排序，然后用点和划的组合来代表这些字母、标点符号和空格，使频率最高的符号具有最短的点划组合。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/60.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-30　神秘电报密码</b></center>
<h3 id="2-6-1-问题分析">2.6.1　问题分析</h3>
<p>我们先看一个生活中的例子：</p>
<p>有一群退休的老教授聚会，其中一个老教授带着刚会说话的漂亮小孙女，于是大家逗她：“你能猜猜我们多大了吗？猜对了有糖吃哦！”小女孩就开始猜：“你是1岁了吗？”，老教授摇摇头。“你是两岁了吗？”，老教授仍然摇摇头。“那一定是3岁了！”……大家哈哈大笑。或许我们都感觉到了小女孩的天真可爱，然而生活中的确有很多类似这样的判断。</p>
<p>曾经有这样一个C++设计题目：将一个班级的成绩从百分制转为等级制。一同学设计的程序为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">70</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">80</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>在上面程序中，如果分数小于60，我们做1次判定即可；如果分数为60～70，需要判定2次；如果分数为70～80，需要判定3次；如果分数为80～90，需要判定4次；如果分数为90～100，需要判定5次。</p>
<p>这段程序貌似是没有任何问题，但是我们却犯了从1岁开始判断一个老教授年龄的错误，因为我们的考试成绩往往是呈正态分布的，如图2-31所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/61.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-31　运行结果</b></center>
<p>也就是说，大多数（70%）人的成绩要判断3次或3次以上才能成功，假设班级人数为100人，则判定次数为：</p>
<p>100×10%×1+100×20%×2+100×40%×3+100×20%×4+100×10%×5=300（次）</p>
<p>如果我们改写程序为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">80</span>) </span><br><span class="line">   <span class="keyword">if</span> (score &lt;<span class="number">70</span>) </span><br><span class="line">       <span class="keyword">if</span> (score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>则判定次数为：</p>
<p>100×10%×3+100×20%×3+100×40%×2+100×20%×2+100×10%×2=230（次）</p>
<p>为什么会有这样大的差别呢？我们来看两种判断方式的树形图，如图2-32所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/62.jpg" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/63.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-32　两种判断方式的树形图</b></center>
<p>从图2-32中我们可以看到，当频率高的分数越靠近树根（先判断）时，我们只用1次猜中的可能性越大。</p>
<p>再看五笔字型的编码方式：</p>
<p>我们在学习五笔时，需要背一级简码。所谓一级简码，就是指25个汉字，对应着25个按键，打1个字母键再加1个空格键就可打出来相应的字。为什么要这样设置呢？因为根据文字统计，这25个汉字是使用频率最高的。</p>
<p>五笔字根之一级简码：</p>
<p>G 一　F 地　D 在　 S 要　 A 工</p>
<p>H 上　J 是　K 中　 L 国　 M 同</p>
<p>T 和　R 的　E 有　 W 人　Q 我</p>
<p>Y 主　U 产　I 不　 O 为　 P 这</p>
<p>N 民　B 了　V 发　C 以　 X 经</p>
<p>通常的编码方法有固定长度编码和不等长度编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/64.gif" style="width:47px;  height: 19px; "/>位。例如，3个不同的字符a、b、c，至少需要2位二进制数表示，a为00，b为01，c为10。如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。</p>
<p>不等长编码方法需要解决两个关键问题：</p>
<p>（1）编码尽可能短</p>
<p>我们可以让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。即 <strong>频率越高，编码越短</strong> 。</p>
<p>（2）不能有二义性</p>
<p>例如，ABCD四个字符如果编码如下。</p>
<p>A：0。B：1。C：01。D：10。</p>
<p>那么现在有一列数0110，该怎样翻译呢？是翻译为ABBA，ABD，CBA，还是CD？那么如何消除二义性呢？解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即 <strong>前缀码特性</strong> 。</p>
<p>1952年，数学家D.A.Huffman提出了根据字符在文件中出现的频率，用0、1的数字串表示各字符的最佳编码方式，称为哈夫曼（Huffman）编码。哈夫曼编码很好地解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是采用哈夫曼编码压缩的。</p>
<h3 id="2-6-2-算法设计">2.6.2　算法设计</h3>
<p>哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将所要编码的字符作为叶子结点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式，通过n−1次的“合并”运算后构造出的一棵树，核心思想是权值越大的叶子离根越近。</p>
<p>哈夫曼算法采取的 <strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong> ，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中，求解步骤如下。</p>
<p>（1）确定合适的数据结构。编写程序前需要考虑的情况有：</p>
<ul>
<li>哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n−1个结点（n−1次的“合并”，每次产生一个新结点），</li>
<li>构成哈夫曼树后，为求编码，需从叶子结点出发走一条从叶子到根的路径。</li>
<li>译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值、双亲、左孩子、右孩子和结点的信息。</li>
</ul>
<p>（2）初始化。构造n棵结点为n个字符的单结点树集合T={t<sub class="my_markdown">1</sub>，t<sub>2</sub>，t<sub>3</sub>，…，t<sub class="my_markdown">n</sub>}，每棵树只有一个带权的根结点，权值为该字符的使用频率。</p>
<p>（3）如果T中只剩下一棵树，则哈夫曼树构造成功，跳到步骤（6）。否则，从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左孩子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p>
<p>（4）从集合T中删去t<sub class="my_markdown">i</sub>，t<sub class="my_markdown">j</sub>，加入z<sub class="my_markdown">k</sub>。</p>
<p>（5）重复以上（3）～（4）步。</p>
<p>（6）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码。算法结束。</p>
<h3 id="2-6-3-完美图解">2.6.3　完美图解</h3>
<p>假设我们现在有一些字符和它们的使用频率（见表2-13），如何得到它们的哈夫曼编码呢？</p>
<center class="my_markdown"><b class="my_markdown">表2-13　字符频率</b></center>
<p>| 字符 | a | b | c | d | e | f |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 频率 | 0.05 | 0.32 | 0.18 | 0.07 | 0.25 | 0.13 |</p>
<p>我们可以把每一个字符作为叶子，它们对应的频率作为其权值，为了比较大小方便，可以对其同时扩大100倍，得到a～f分别对应5、32、18、7、25、13。</p>
<p>（1）初始化。构造n棵结点为n个字符的单结点树集合T={a，b，c，d，e，f}，如图2-33所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/65.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-33　叶子结点</b></center>
<p>（2）从集合T中取出没有双亲的且权值最小的两棵树a和d，将它们合并成一棵新树t<sub class="my_markdown">1</sub>，新树的左孩子为a，右孩子为d，新树的权值为a和d的权值之和为12。新树的树根t<sub class="my_markdown">1</sub>加入集合T，a和d从集合T中删除，如图2-34所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/66.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-34　构建新树</b></center>
<p>（3）从集合T中取出没有双亲的且权值最小的两棵树t<sub class="my_markdown">1</sub>和f，将它们合并成一棵新树t<sub>2</sub>，新树的左孩子为t<sub class="my_markdown">1</sub>，右孩子为f，新树的权值为t<sub class="my_markdown">1</sub>和f的权值之和为25。新树的树根t<sub>2</sub>加入集合T，将t<sub class="my_markdown">1</sub>和f从集合T中删除，如图2-35所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/67.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-35　构建新树</b></center>
<p>（4）从集合T中取出没有双亲且权值最小的两棵树c和e，将它们合并成一棵新树t<sub class="my_markdown">3</sub>，新树的左孩子为c，右孩子为e，新树的权值为c和e的权值之和为43。新树的树根t<sub class="my_markdown">3</sub>加入集合T，将c和e从集合T中删除，如图2-36所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/68.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-36　构建新树</b></center>
<p>（5）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">2</sub>和b，将它们合并成一棵新树t<sub>4</sub>，新树的左孩子为t<sub class="my_markdown">2</sub>，右孩子为b，新树的权值为t<sub class="my_markdown">2</sub>和b的权值之和为57。新树的树根t<sub>4</sub>加入集合T，将t<sub class="my_markdown">2</sub>和b从集合T中删除，如图2-37所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/69.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-37　构建新树</b></center>
<p>（6）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">3</sub>和t<sub>4</sub>，将它们合并成一棵新树t<sub>5</sub>，新树的左孩子为t<sub>4</sub>，右孩子为t<sub class="my_markdown">3</sub>，新树的权值为t<sub class="my_markdown">3</sub>和t<sub>4</sub>的权值之和为 100。新树的树根t<sub>5</sub>加入集合T，将t<sub class="my_markdown">3</sub>和t<sub>4</sub>从集合T中删除，如图 2-38所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/70.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-38　哈夫曼树</b></center>
<p>（7）T中只剩下一棵树，哈夫曼树构造成功。</p>
<p>（8）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码，如图2-39所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/71.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-39　哈夫曼编码</b></center>
<h3 id="2-6-4-伪代码详解">2.6.4　伪代码详解</h3>
<p>在构造哈夫曼树的过程中，首先给每个结点的双亲、左孩子、右孩子初始化为−1，找出所有结点中双亲为−1、权值最小的两个结点t<sub class="my_markdown">1</sub>、t<sub>2</sub>，并合并为一棵二叉树，更新信息（双亲结点的权值为t<sub class="my_markdown">1</sub>、t<sub>2</sub>权值之和，其左孩子为权值最小的结点t<sub class="my_markdown">1</sub>，右孩子为次小的结点t<sub>2</sub>，t<sub class="my_markdown">1</sub>、t<sub>2</sub>的双亲为双亲结点的编号）。重复此过程，构造一棵哈夫曼树。</p>
<p>（1）数据结构</p>
<p>每个结点的结构包括权值、双亲、左孩子、右孩子、结点字符信息这 5 个域。如图 2-40所示，定义为结构体形式，定义结点结构体HnodeType：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">double</span> weight; <span class="comment">//权值</span></span><br><span class="line">     <span class="type">int</span> parent;  <span class="comment">//双亲</span></span><br><span class="line">     <span class="type">int</span> lchild;  <span class="comment">//左孩子</span></span><br><span class="line">     <span class="type">int</span> rchild;  <span class="comment">//右孩子</span></span><br><span class="line">     <span class="type">char</span> value; <span class="comment">//该节点表示的字符</span></span><br><span class="line">&#125; HNodeType;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/72.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-40　结点结构体</b></center>
<p>在编码结构体中，bit[]存放结点的编码，start 记录编码开始下标，逆向译码（从叶子到根，想一想为什么不从根到叶子呢？）。存储时，start从n−1开始依次递减，从后向前存储；读取时，从start+1开始到n−1，从前向后输出，即为该字符的编码。如图2-41所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/73.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-41　编码数组</b></center>
<p>编码结构体HcodeType：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> bit[MAXBIT]; <span class="comment">//存储编码的数组</span></span><br><span class="line">     <span class="type">int</span> start;       <span class="comment">//编码开始下标</span></span><br><span class="line">&#125; HCodeType;          <span class="comment">/* 编码结构体 */</span></span><br></pre></td></tr></table></figure>
<p>（2）初始化</p>
<p>初始化存放哈夫曼树数组HuffNode[]中的结点（见表2-14）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">     HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">     HuffNode[i].parent =<span class="number">-1</span>; <span class="comment">//双亲</span></span><br><span class="line">     HuffNode[i].lchild =<span class="number">-1</span>; <span class="comment">//左孩子</span></span><br><span class="line">     HuffNode[i].rchild =<span class="number">-1</span>; <span class="comment">//右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<center class="my_markdown"><b class="my_markdown">表2-14　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/74.jpg" alt="code"><br>
输入n个叶子结点的字符及权值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）循环构造Huffman树</p>
<p>从集合T中取出双亲为−1且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左儿子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> i, j, x1, x2; <span class="comment">//x1、x2为两个最小权值结点的序号。</span></span><br><span class="line">    <span class="type">double</span> m1,m2; <span class="comment">//m1、m2为两个最小权值结点的权值。</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">         m1=m2=MAXVALUE;  <span class="comment">//初始化为最大值</span></span><br><span class="line">         x1=x2=<span class="number">-1</span>;  <span class="comment">//初始化为-1</span></span><br><span class="line">         <span class="comment">//找出所有结点中权值最小、无双亲结点的两个结点</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2 = m1;</span><br><span class="line">                   x2 = x1;</span><br><span class="line">                   m1 = HuffNode[j].weight;</span><br><span class="line">                   x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2=HuffNode[j].weight;</span><br><span class="line">                   x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 更新新树信息 */</span></span><br><span class="line">         HuffNode[x1].parent = n+i; <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[x2].parent = n+i; <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[n+i].weight =m1+m2; <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">         HuffNode[n+i].lchild = x1; <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">         HuffNode[n+i].rchild = x2; <span class="comment">//新结点n+i的右孩子为x2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图解：</p>
<p>（1）i=0时，j=0；j&lt;6；找双亲为−1，权值最小的两个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">0</span>   x2=<span class="number">3</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">5</span>  m2=<span class="number">7</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">0</span>].parent = <span class="number">6</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">3</span>].parent = <span class="number">6</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].weight =<span class="number">12</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">6</span>].lchild = <span class="number">0</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">6</span>].rchild = <span class="number">3</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure>
<p>数据更新后如表2-15所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-15　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/75.jpg" alt="code"><br>
对应的哈夫曼树如图2-42所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/76.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-42　哈夫曼树生成过程</b></center>
<p>（2）i=1时，j=0；j&lt;7；找双亲为−1，权值最小的两个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">6</span>    x2=<span class="number">5</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">12</span>  m2=<span class="number">13</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">5</span>].parent = <span class="number">7</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].parent = <span class="number">7</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">7</span>].weight =<span class="number">25</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">7</span>].lchild = <span class="number">6</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">7</span>].rchild = <span class="number">5</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure>
<p>数据更新后如表2-16所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-16　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/77.jpg" alt="code"><br>
对应的哈夫曼树如图2-43所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/78.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-43　哈夫曼树生成过程</b></center>
<p>（3）i=2时，j=0；j&lt;8；找双亲为−1，权值最小的两个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">2</span>    x2=<span class="number">4</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">18</span>  m2=<span class="number">25</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">2</span>].parent = <span class="number">8</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">4</span>].parent = <span class="number">8</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">43</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">2</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">4</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure>
<p>数据更新后如表2-17所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-17　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/79.jpg" alt="code"><br>
对应的哈夫曼树如图2-44所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/80.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-44　哈夫曼树生成过程</b></center>
<p>（4）i=3时，j=0；j&lt;9；找双亲为−1，权值最小的两个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">7</span>    x2=<span class="number">1</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">25</span>  m2=<span class="number">32</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">7</span>].parent = <span class="number">9</span>;    <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">1</span>].parent = <span class="number">9</span>;     <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">57</span>;     <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">7</span>;     <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">1</span>;     <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure>
<p>数据更新后如表2-18所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-18　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/81.jpg" alt="code"><br>
对应的哈夫曼树如图2-45所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/82.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-45　哈夫曼树生成过程</b></center>
<p>（5）i=4时，j=0；j&lt;10；找双亲为−1，权值最小的两个数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">8</span>    x2=<span class="number">9</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">43</span>  m2=<span class="number">57</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">8</span>].parent = <span class="number">10</span>;  <span class="comment">//x1的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">9</span>].parent =<span class="number">10</span>;   <span class="comment">//x2的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">10</span>].weight =<span class="number">100</span>;  <span class="comment">//新结点权值为两个最小权值之和m1+ m2</span></span><br><span class="line">HuffNode[<span class="number">10</span>].lchild = <span class="number">8</span>; <span class="comment">//新结点编号n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">10</span>].rchild = <span class="number">9</span>; <span class="comment">//新结点编号n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure>
<p>数据更新后如表2-19所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-19　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/83.jpg" alt="code"><br>
对应的哈夫曼树如图2-46所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/84.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-46　哈夫曼树生成过程</b></center>
<p>（6）输出哈夫曼编码</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">   &#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">          cd.start = n<span class="number">-1</span>;</span><br><span class="line">          c = i;  <span class="comment">//i为叶子结点编号</span></span><br><span class="line">          p = HuffNode[c].parent;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(HuffNode[p].lchild == c)&#123;</span><br><span class="line">                  cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">              cd.start--;         <span class="comment">/* start向前移动一位 */</span></span><br><span class="line">              c = p;              <span class="comment">/* c,p变量上移，准备下一循环 */</span></span><br><span class="line">              p = HuffNode[c].parent;    </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">          <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">              HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">          HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>图解：哈夫曼编码数组如图2-47所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/85.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-47　哈夫曼编码数组</b></center>
<p>（1）i=0时，c=0；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd.start = n<span class="number">-1</span>=<span class="number">5</span>;</span><br><span class="line">p = HuffNode[<span class="number">0</span>].parent=<span class="number">6</span>;<span class="comment">//从哈夫曼树建成后的表HuffNode[]中读出</span></span><br><span class="line">                         <span class="comment">//p指向0号结点的父亲6号</span></span><br></pre></td></tr></table></figure>
<p>构建完成的哈夫曼树数组如表2-20所示。</p>
<center class="my_markdown"><b class="my_markdown">表2-20　哈夫曼树构建数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/86.jpg" alt="code"><br>
如果p != −1，那么从表HuffNode[]中读出6号结点的左孩子和右孩子，判断0号结点是它的左孩子还是右孩子，如果是左孩子编码为0；如果是右孩子编码为1。</p>
<p>从表2-20可以看出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HuffNode[<span class="number">6</span>].lchild=<span class="number">0</span>;<span class="comment">//0号结点是其父亲6号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">5</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">4</span>; <span class="comment">/* start向前移动一位*/</span></span><br></pre></td></tr></table></figure>
<p>哈夫曼编码树如图2-48所示，哈夫曼编码数组如图2-49所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/87.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-48　哈夫曼编码树</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/88.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-49　哈夫曼编码数组</b></center>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = p=<span class="number">6</span>;                      <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">6</span>].parent=<span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>c、p变量上移后如图2-50所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">7</span>].lchild=<span class="number">6</span>;<span class="comment">//6号结点是其父亲7号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">4</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">3</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">7</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">7</span>].parent=<span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/89.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-50　哈夫曼编码树</b></center>
<p>哈夫曼编码树如图2-51所示，哈夫曼编码数组如图2-52所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/90.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-51　哈夫曼编码树</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/91.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-52　哈夫曼编码数组</b></center>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">9</span>].lchild=<span class="number">7</span>;<span class="comment">//7号结点是其父亲9号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">2</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">9</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">9</span>].parent=<span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>哈夫曼编码树如图2-53所示，哈夫曼编码数组如图2-54所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">10</span>].lchild!=<span class="number">9</span>;<span class="comment">//9号结点不是其父亲10号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//编码为1</span></span><br><span class="line">cd.start--=<span class="number">1</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">10</span>;            <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">10</span>].parent=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/92.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-53　哈夫曼编码树</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/93.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-54　哈夫曼编码数组</b></center>
<p>哈夫曼编码树如图2-55所示，哈夫曼编码数组如图2-56所示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">-1</span>;该叶子结点编码结束。</span><br><span class="line"><span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">   <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">   HuffCode[i].start = cd.start;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/94.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-55　哈夫曼编码树</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/95.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-56　哈夫曼编码数组</b></center>
<p>HuffCode[]数组如图2-57所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/96.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-57　哈夫曼编码HuffCode[]数组</b></center>
<p>注意：图中的箭头不表示指针。</p>
<h3 id="2-6-5-实战演练">2.6.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBIT    100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE  10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEAF   30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNODE   MAXLEAF*2 -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> lchild;</span><br><span class="line">    <span class="type">int</span> rchild;</span><br><span class="line">    <span class="type">char</span> value;</span><br><span class="line">&#125; HNodeType;        <span class="comment">/* 结点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit[MAXBIT];</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">&#125; HCodeType;        <span class="comment">/* 编码结构体 */</span></span><br><span class="line">HNodeType HuffNode[MAXNODE]; <span class="comment">/* 定义一个结点结构体数组 */</span></span><br><span class="line">HCodeType HuffCode[MAXLEAF];<span class="comment">/* 定义一个编码结构体数组*/</span></span><br><span class="line"><span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanTree</span> <span class="params">(HNodeType HuffNode[MAXNODE],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，</span></span><br><span class="line"><span class="comment">       x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> i, j, x1, x2;</span><br><span class="line">    <span class="type">double</span> m1,m2;</span><br><span class="line">    <span class="comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">         HuffNode[i].parent =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].lchild =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].rchild =<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输入 n 个叶子结点的权值 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 构造 Huffman 树 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;<span class="comment">//执行n-1次合并</span></span><br><span class="line">         m1=m2=MAXVALUE;</span><br><span class="line">         <span class="comment">/* m1、m2中存放两个无父结点且结点权值最小的两个结点 */</span></span><br><span class="line">         x1=x2=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">/* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 */</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2 = m1;</span><br><span class="line">                  x2 = x1;</span><br><span class="line">                  m1 = HuffNode[j].weight;</span><br><span class="line">                  x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2=HuffNode[j].weight;</span><br><span class="line">                  x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 设置找到的两个子结点 x1、x2 的父结点信息 */</span></span><br><span class="line">         HuffNode[x1].parent  = n+i;</span><br><span class="line">         HuffNode[x2].parent  = n+i;</span><br><span class="line">         HuffNode[n+i].weight = m1+m2;</span><br><span class="line">         HuffNode[n+i].lchild = x1;</span><br><span class="line">         HuffNode[n+i].rchild = x2;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x1.weight and x2.weight in round &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x1]. weight&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x2].weight&lt;&lt;<span class="built_in">endl</span>; <span class="comment">/* 用于测试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cd.start = n<span class="number">-1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">        p = HuffNode[c].parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(HuffNode[p].lchild == c)</span><br><span class="line">                cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">            cd.start--;        <span class="comment">/* 求编码的低一位 */</span></span><br><span class="line">            c = p;</span><br><span class="line">            p = HuffNode[c].parent;    <span class="comment">/* 设置下一循环条件 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">        <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">           HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">        HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    HuffmanTree (HuffNode, n);  <span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line">    HuffmanCode(HuffCode, n);  <span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line">    <span class="comment">/* 输出已保存好的所有存在编码的哈夫曼编码 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;HuffNode[i].value&lt;&lt;<span class="string">&quot;: Huffman code is: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=HuffCode[i].start+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;HuffCode[i].bit[j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Please input n：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">1</span></span><br><span class="line">a <span class="number">0.05</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">2</span></span><br><span class="line">b <span class="number">0.32</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">3</span></span><br><span class="line">c <span class="number">0.18</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">4</span></span><br><span class="line">d <span class="number">0.07</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">5</span></span><br><span class="line">e <span class="number">0.25</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">6</span></span><br><span class="line">f <span class="number">0.13</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x1.weight and x2.weight in round <span class="number">1</span>      <span class="number">0.05</span>    <span class="number">0.07</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">2</span>      <span class="number">0.12</span>    <span class="number">0.13</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">3</span>      <span class="number">0.18</span>    <span class="number">0.25</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">4</span>      <span class="number">0.25</span>    <span class="number">0.32</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">5</span>      <span class="number">0.43</span>    <span class="number">0.57</span></span><br><span class="line">a: Huffman code is: <span class="number">1000</span></span><br><span class="line">b: Huffman code is: <span class="number">11</span></span><br><span class="line">c: Huffman code is: <span class="number">00</span></span><br><span class="line">d: Huffman code is: <span class="number">1001</span></span><br><span class="line">e: Huffman code is: <span class="number">01</span></span><br><span class="line">f: Huffman code is: <span class="number">101</span></span><br></pre></td></tr></table></figure>
<h3 id="2-6-6-算法解析及优化拓展">2.6.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由程序可以看出，在函数HuffmanTree()中，if (HuffNode[j].weight&lt;m1&amp;&amp; HuffNode[j].parent==−1)为基本语句，外层i与j组成双层循环：</p>
<p>i=0时，该语句执行n次；</p>
<p>i=1时，该语句执行n+1次；</p>
<p>i=2时，该语句执行n+2次；</p>
<p>……</p>
<p>i=n−2时，该语句执行n+n−2次；</p>
<p>则基本语句共执行n+（n+1）+（n+2）+…+（n+（n−2））=（n−1）*（3n−2）/2次（等差数列）；在函数HuffmanCode()中，编码和输出编码时间复杂度都接近n<sup class="my_markdown">2</sup>；则该算法时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<p>（2）空间复杂度：所需存储空间为结点结构体数组与编码结构体数组，哈夫曼树数组 HuffNode[]中的结点为n个，每个结点包含bit[MAXBIT]和start两个域，则该算法空间复杂度为O( n* MAXBIT)。</p>
<h4 id="2．算法优化拓展-4">2．算法优化拓展</h4>
<p>该算法可以从两个方面优化：</p>
<p>（1）函数HuffmanTree()中找两个权值最小结点时使用优先队列，时间复杂度为logn，执行n−1次，总时间复杂度为O( n logn)。</p>
<p>（2）函数HuffmanCode()中，哈夫曼编码数组HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度为实际的编码长度，这样可以大大节省空间。</p>
<h3 id="2-7-沟通无限校园网——最小生成树">2.7　沟通无限校园网——最小生成树</h3>
<p>校园网是为学校师生提供资源共享、信息交流和协同工作的计算机网络。校园网是一个宽带、具有交互功能和专业性很强的局域网络。如果一所学校包括多个学院及部门，也可以形成多个局域网络，并通过有线或无线方式连接起来。原来的网络系统只局限于以学院、图书馆为单位的局域网，不能形成集中管理以及各种资源的共享，个别学院还远离大学本部，这些情况严重地阻碍了整个学校的网络化需求。现在需要设计网络电缆布线，将各个单位的局域网络连通起来，如何设计能够使费用最少呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/97.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-58　校园网络</b></center>
<h3 id="2-7-1-问题分析">2.7.1　问题分析</h3>
<p>某学校下设10个学院，3个研究所，1个大型图书馆，4个实验室。其中，1～10号节点代表10个学院，11～13号节点代表3个研究所，14号节点代表图书馆，15～18号节点代表4个实验室。该问题用无向连通图<strong>G</strong> =（V，E）来表示通信网络，V表示顶点集，E表示边集。把各个单位抽象为图中的顶点，顶点与顶点之间的边表示单位之间的通信网络，边的权值表示布线的费用。如果两个节点之间没有连线，代表这两个单位之间不能布线，费用为无穷大。如图2-59所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/98.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-59　校园网连通图</b></center>
<p>那么我们如何设计网络电缆布线，将各个单位连通起来，并且费用最少呢？</p>
<p>对于n个顶点的连通图，只需n−1条边就可以使这个图连通，n−1条边要想保证图连通，就必须不含回路，所以我们只需要找出n−1条权值最小且无回路的边即可。</p>
<p>需要说明几个概念。</p>
<p>（1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图。</p>
<p>（2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图。</p>
<p>（3）生成树：如果生成子图恰好是一棵树，则称为生成树。</p>
<p>（4）最小生成树：权值之和最小的生成树，则称为最小生成树。</p>
<p>本题就是最小生成树求解问题。</p>
<h3 id="2-7-2-算法设计">2.7.2　算法设计</h3>
<p>找出n−1条权值最小的边很容易，那么怎么保证无回路呢?</p>
<p>如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法—— <strong>避圈法</strong> 。在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。</p>
<p>首先任选一个结点，例如1号结点，把它放在集合U中，U={1}，那么剩下的结点即V−U={2，3，4，5，6，7}，V是图的所有顶点集合。如图2-60所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/99.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-60　最小生成树求解过程</b></center>
<p>现在只需在连接两个集合（V和V−U）的边中看哪一条边权值最小，把权值最小的边关联的结点加入到集合U。从图2-68可以看出，连接两个集合的3条边中，结点1到结点2的边权值最小，选中此条边，把2号结点加入U集合U={1，2}，V−U={3，4，5，6，7}。</p>
<p>再从连接两个集合（V和V−U）的边中选择一条权值最小的边。从图2-61可以看出，连接两个集合的4条边中，结点2到结点7的边权值最小，选中此条边，把7号结点加入U集合U={1，2，7}，V−U={3，4，5，6}。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/100.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-61　最小生成树求解过程</b></center>
<p>如此下去，直到U=V结束，选中的边和所有的结点组成的图就是最小生成树。</p>
<p>是不是非常简单啊？</p>
<p>这就是Prim算法，1957年由美国计算机科学家Robert C.Prim发现的。那么如何用算法来实现呢？</p>
<p>首先，令U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，TE={}。u<sub class="my_markdown">0</sub>可以是任何一个结点，因为最小生成树包含所有结点，所以从哪个结点出发都可以得到最小生成树，不影响最终结果。TE为选中的边集。</p>
<p>然后，做如下 <strong>贪心选择</strong> ：选取连接U和V−U的所有边中的最短边，即满足条件i∈U，j∈V−U，且边（i，j）是连接U和V−U的所有边中的最短边，即该边的权值最小。</p>
<p>然后，将顶点j加入集合U，边（i，j）加入TE。继续上面的贪心选择一直进行到U=V为止，此时，选取到的所有边恰好构成图<strong>G</strong>的一棵最小生成树T。</p>
<p>算法设计及步骤如下。</p>
<p>步骤1：确定合适的数据结构。设置带权邻接矩阵<strong>C</strong>存储图<strong>G</strong>，如果图<strong>G</strong>中存在边（u，x），令<strong>C</strong>[u][x]等于边（u，x）上的权值，否则，<strong>C</strong>[u][x]=∞；bool数组s[]，如果s[i]=true，说明顶点i已加入集合U。</p>
<p>如图2-62所示，直观地看图很容易找出 U 集合到 V−U集合的边中哪条边是最小的，但是程序中如果穷举这些边，再找最小值就太麻烦了，那怎么办呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/101.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-62　最小生成树求解过程</b></center>
<p>可以通过设置两个数组巧妙地解决这个问题，closest[j]表示V−U中的顶点j到集合U中的最邻近点，lowcost[j]表示V−U中的顶点j到集合U中的最邻近点的边值，即边（j,closest[j]）的权值。</p>
<p>例如，在图2-62中，7号结点到U集合中的最邻近点是2，closest[7]=2，如图2-63所示。7号结点到最邻近点2的边值为1，即边（2，7）的权值，记为lowcost[7]=1，如图2-64所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/102.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-63　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/103.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-64　lowcost[]数组</b></center>
<p>只需要在V−U集合中找lowcost[]值最小的顶点即可。</p>
<p>步骤2：初始化。令集合U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，并初始化数组closest[]、lowcost[]和s[]。</p>
<p>步骤3：在V−U集合中找lowcost值最小的顶点t，即lowcost[t]=min{lowcost[j]|j∈V−U}，满足该公式的顶点t就是集合V−U中连接集合U的最邻近点。</p>
<p>步骤4：将顶点t加入集合U。</p>
<p>步骤5：如果集合V−U，算法结束，否则，转步骤6。</p>
<p>步骤6：对集合V−U中的所有顶点j，更新其lowcost[]和closest[]。更新公式：if（<strong>C</strong>[t] [j]&lt;lowcost [j] ) { lowcost [j]= <strong>C</strong> [t] [j]; closest [j] = t; }，转步骤3。</p>
<p>按照上述步骤，最终可以得到一棵权值之和最小的生成树。</p>
<h3 id="2-7-3-完美图解">2.7.3　完美图解</h3>
<p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-65所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/104.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-65　无向连通带权图**G**</b></center>
<p>（1）数据结构</p>
<p>设置地图的带权邻接矩阵为<strong>C</strong>[][]，即如果从顶点i到顶点j有边，就让<strong>C</strong>[i][j]=&lt;i，j&gt;的权值，否则<strong>C</strong>[i][j]=∞（无穷大），如图2-66所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/105.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-66　邻接矩阵**C**[ ][ ]</b></center>
<p>（2）初始化</p>
<p>假设u<sub class="my_markdown">0</sub>=1；令集合U={1}，V−U={2，3，4，5，6，7}，TE={}，s[1]=true，初始化数组closest[]：除了1号结点外其余结点均为1，表示V−U中的顶点到集合U的最临近点均为1，如图2-67所示。lowcost[]：1号结点到V−U中的顶点的边值，即读取邻接矩阵第1行，如图2-68所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/106.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-67　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/107.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-68　lowcost[]数组</b></center>
<p>初始化后如图2-69所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/108.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-69　最小生成树求解过程</b></center>
<p>（3）找最小</p>
<p>在集合V−U={2，3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-70所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/109.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-70　lowcost[]数组</b></center>
<p>找到最小值为23，对应的结点t=2。</p>
<p>选中的边和结点如图2-71所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/110.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-71　最小生成树求解过程</b></center>
<p>（4）加入U战队</p>
<p>将顶点t加入集合U={1，2}，同时更新V−U={3，4，5，6，7}。</p>
<p>（5）更新</p>
<p>刚刚找到了到U集合的最邻近点t = 2，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，2号结点的邻接点是3和7号结点：</p>
<p><strong>C</strong>[2][3]=20&lt;lowcost[3]=∞，更新最邻近距离lowcost[3]=20，最邻近点closest[3]=2；</p>
<p><strong>C</strong>[2][7]=1&lt;lowcost[7]=36，更新最邻近距离lowcost[7]=1，最邻近点closest[7]=2；</p>
<p>更新后的closest[j]和lowcost[j]数组如图2-72和图2-73所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/111.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-72　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/112.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-73　lowcost[]数组</b></center>
<p>更新后如图2-74所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/113.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-74　最小生成树求解过程</b></center>
<p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为2，最邻近距离为20；4、5号顶点到U集合的最邻近点仍为初始化状态1，最邻近距离为∞；6号顶点到U集合的最邻近点为1，最邻近距离为26；7号顶点到U集合的最邻近点为2，最邻近距离为1。</p>
<p>（6）找最小</p>
<p>在集合V−U={3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-75所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/114.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-75　lowcost[]数组</b></center>
<p>找到最小值为1，对应的结点t=7。</p>
<p>选中的边和结点如图2-76所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/115.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-76　最小生成树求解过程</b></center>
<p>（7）加入U战队</p>
<p>将顶点t加入集合U={1，2，7}，同时更新V−U={3，4，5，6}。</p>
<p>（8）更新</p>
<p>刚刚找到了到U集合的最邻近点t =7，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图或邻接矩阵可以看出，7号结点在集合V−U中的邻接点是3、4、5、6结点：</p>
<p><strong>C</strong>[7][3]=4&lt;lowcost[3]=20，更新最邻近距离lowcost[3]=4，最邻近点closest[3]=7；</p>
<p><strong>C</strong>[7][4]=9&lt;lowcost[4]=∞，更新最邻近距离lowcost[4]=9，最邻近点closest[4]=7；</p>
<p><strong>C</strong>[7][5]=16&lt;lowcost[5]=∞，更新最邻近距离lowcost[5]=16，最邻近点closest[5]=7；</p>
<p><strong>C</strong>[7][6]=25&lt;lowcost[6]=28，更新最邻近距离lowcost[6]=25，最邻近点closest[6]=7；</p>
<p>更新后的closest[j]和lowcost[j]数组如图2-77和图2-78所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/116.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-77　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/117.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-78　lowcost[]数组</b></center>
<p>更新后如图2-79所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/118.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-79　最小生成树求解过程</b></center>
<p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为7，最邻近距离为4；4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p>
<p>（9）找最小</p>
<p>在集合V−U={3，4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-80所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/119.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-80　lowcost[]数组</b></center>
<p>找到最小值为4，对应的结点t=3。</p>
<p>选中的边和结点如图2-81所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/120.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-81　最小生成树求解过程</b></center>
<p>（10）加入U战队</p>
<p>将顶点t加入集合U ={1，2，3，7}，同时更新V−U={4，5，6}。</p>
<p>（11）更新</p>
<p>刚刚找到了到U集合的最邻近点t =3，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，3号结点在集合V−U中的邻接点是4号结点：</p>
<p>C[3][4]=15&gt;lowcost[4]=9，不更新。</p>
<p>closest[j]和lowcost[j]数组不改变。</p>
<p>更新后如图2-82所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/121.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-82　最小生成树求解过程</b></center>
<p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p>
<p>（12）找最小</p>
<p>在集合V−U={4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-83所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/122.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-83　lowcost[]数组</b></center>
<p>找到最小值为9，对应的结点t=4。</p>
<p>选中的边和结点如图2-84所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/123.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-84　最小生成树求解过程</b></center>
<p>（13）加入U战队</p>
<p>将顶点t加入集合U ={1，2，3，4，7}，同时更新V−U={5，6}。</p>
<p>（14）更新</p>
<p>刚刚找到了到U集合的最邻近点t =4，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，4号结点在集合V−U中的邻接点是5号结点：</p>
<p><strong>C</strong>[4][5]=3&lt;lowcost[5]=16，更新最邻近距离lowcost[5]=3，最邻近点closest[5]=4；</p>
<p>更新后的closest[j]和lowcost[j]数组如图2-85和图2-86所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/124.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-85　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/125.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-86　lowcost[]数组</b></center>
<p>更新后如图2-87所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/126.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-87　最小生成树求解过程</b></center>
<p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。5号顶点到U集合的最邻近点为4，最邻近距离为3；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p>
<p>（15）找最小</p>
<p>在集合V−U={5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-88所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/127.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-88　lowcost[]数组</b></center>
<p>找到最小值为3，对应的结点t=5。</p>
<p>选中的边和结点如图2-89所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/128.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-89　最小生成树求解过程</b></center>
<p>（16）加入U战队</p>
<p>将顶点t加入集合U={1，2，3，4，5，7}，同时更新V−U={6}。</p>
<p>（17）更新</p>
<p>刚刚找到了到U集合的最邻近点t =5，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，5号结点在集合V−U中的邻接点是6号结点：</p>
<p><strong>C</strong>[5][6]=17&lt;lowcost[6]=25，更新最邻近距离lowcost[6]=17，最邻近点closest[6]=5；</p>
<p>更新后的closest[j]和lowcost[j]数组如图2-90和图2-91所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/129.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-90　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/130.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-91　lowcost[]数组</b></center>
<p>更新后如图2-92所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/131.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-92　最小生成树求解过程</b></center>
<p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。6号顶点到U集合的最邻近点为5，最邻近距离为17。</p>
<p>（18）找最小</p>
<p>在集合V−U={6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-93所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/132.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-93　lowcost[]数组</b></center>
<p>找到最小值为17，对应的结点t=6。</p>
<p>选中的边和结点如图2-94所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/133.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-94　最小生成树求解过程</b></center>
<p>（19）加入U战队</p>
<p>将顶点t加入集合U ={1，2，3，4，5，6，7}，同时更新V−U={}。</p>
<p>（20）更新</p>
<p>刚刚找到了到U集合的最邻近点t =6，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图2-94可以看出，6号结点在集合V−U中无邻接点，因为V−U={}。</p>
<p>closest[j]和lowcost[j]数组如图2-95和图2-96所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/134.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-95　closest[]数组</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/135.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-96　lowcost[]数组</b></center>
<p>得到的最小生成树如图2-97所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/136.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-97　最小生成树</b></center>
<p>最小生成树权值之和为57，即把lowcost数组中的值全部加起来。</p>
<h3 id="2-7-4-伪代码详解">2.7.4　伪代码详解</h3>
<p>（1）初始化。s[1]=true，初始化数组closest，除了u<sub class="my_markdown">0</sub>外其余顶点最邻近点均为u<sub class="my_markdown">0</sub>，表示V−U中的顶点到集合U的最临近点均为u<sub class="my_markdown">0</sub>；初始代数组lowcost，u<sub class="my_markdown">0</sub>到V−U中的顶点的边值，无边相连则为∞（无穷大）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i != u0) <span class="comment">//除u0之外的顶点</span></span><br><span class="line">     &#123;</span><br><span class="line">          lowcost[i] = c[u0][i];   <span class="comment">//u0到其它顶点的边值</span></span><br><span class="line">          closest[i] = u0;  <span class="comment">//最邻近点初始化为u0</span></span><br><span class="line">          s[i] = <span class="literal">false</span>;  <span class="comment">//初始化u0之外的顶点不属于U集合，即属于V-U集合</span></span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          lowcost[i] =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）在集合V−U中寻找距离集合U最近的顶点t。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF;</span><br><span class="line"><span class="type">int</span> t = u0;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//在集合中V-U中寻找距离集合U最近的顶点t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) <span class="comment">//!s[j] 表示j结点在V-U集合中</span></span><br><span class="line">    &#123; </span><br><span class="line">        t = j;</span><br><span class="line">        temp = lowcost[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t == u0) <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>（3）更新lowcost和closest数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[t] = <span class="literal">true</span>;     <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//更新lowcost和closest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) <span class="comment">// !s[j] 表示j结点在V-U集合中</span></span><br><span class="line">                                          <span class="comment">//t到j的边值小于当前的最邻近值</span></span><br><span class="line">    &#123;</span><br><span class="line">         lowcost[j] = c[t][j]; <span class="comment">//更新j的最邻近值为t到j的边值</span></span><br><span class="line">         closest[j] = t;    <span class="comment">//更新j的最邻近点为t</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-7-5-实战演练">2.7.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">bool</span> s[N];</span><br><span class="line"><span class="type">int</span> closest[N];</span><br><span class="line"><span class="type">int</span> lowcost[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> u0, <span class="type">int</span> c[N][N])</span> </span><br><span class="line">&#123;  <span class="comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span></span><br><span class="line">  <span class="comment">//如果s[i]=true,说明顶点i已加入最小生成树</span></span><br><span class="line">  <span class="comment">//的顶点集合U；否则顶点i属于集合V-U</span></span><br><span class="line">  <span class="comment">//将最后的相关的最小权值传递到数组lowcost</span></span><br><span class="line">  s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//①</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="keyword">if</span>(i != u0) </span><br><span class="line">       &#123;</span><br><span class="line">            lowcost[i] = c[u0][i];</span><br><span class="line">            closest[i] = u0;</span><br><span class="line">            s[i] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            lowcost[i] =<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//②</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> temp = INF;</span><br><span class="line">       <span class="type">int</span> t = u0;</span><br><span class="line">       <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//③在集合中V-u中寻找距离集合U最近的顶点t</span></span><br><span class="line">       &#123; </span><br><span class="line">           <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) </span><br><span class="line">           &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                temp = lowcost[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span>(t == u0)</span><br><span class="line">         <span class="keyword">break</span>;       <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">      s[t] = <span class="literal">true</span>;    <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//④更新lowcost和closest</span></span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j]))</span><br><span class="line">          &#123;</span><br><span class="line">              lowcost[j] = c[t][j];</span><br><span class="line">              closest[j] = t;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, c[N][N], m, u, v, w;</span><br><span class="line">    <span class="type">int</span> u0;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sumcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">          c[i][j] = INF;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入任一结点u0：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u0 ;</span><br><span class="line">    <span class="comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span></span><br><span class="line">    Prim(n, u0, c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;数组lowcost的内容为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lowcost[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                sumcost += lowcost[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; sumcost &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line">输入任一结点u0：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组lowcost的内容为：</span><br><span class="line"><span class="number">0</span> <span class="number">23</span> <span class="number">4</span> <span class="number">9</span> <span class="number">3</span> <span class="number">17</span> <span class="number">1</span></span><br><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure>
<h3 id="2-7-6-算法解析">2.7.6　算法解析</h3>
<p>（1）时间复杂度：在Prim（int n，int u<sub class="my_markdown">0</sub>，int <strong>c</strong>[N][N]）算法中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大。当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n=n²，算法的时间复杂度为O(n²)。</p>
<p>（2）空间复杂度：算法所需要的辅助空间包含i、j、lowcost和closest，则算法的空间复杂度是O(n)。</p>
<h3 id="2-7-7-算法优化拓展">2.7.7　算法优化拓展</h3>
<p>该算法可以从两个方面优化：</p>
<p>（1）for语句③找lowcost最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行n次，总时间复杂度为O( n logn)。</p>
<p>（2）for语句④更新lowcost和closest数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从1～n检查，检查更新的次数为E（边数），每次更新数据入队，入队的时间复杂度为logn，这样更新的时间复杂度为O( Elogn)。</p>
<h4 id="1．算法设计">1．算法设计</h4>
<p>构造最小生成树还有一种算法，Kurskal算法：设<strong>G</strong>=（V，E）是无向连通带权图，V={1，2，…，n}；设最小生成树<strong>T</strong>=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图<strong>T</strong>=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要<strong>T</strong>中选中的边数不到n−1，就做如下的贪心选择：在边集E中选取权值最小的边（i，j），如果将边（i，j）加入集合TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合E中删去。继续上面的贪心选择，直到<strong>T</strong>中所有顶点都在同一个连通分支上为止。此时，选取到的n−1条边恰好构成<strong>G</strong>的一棵最小生成树<strong>T</strong>。</p>
<p>那么，怎样判断加入某条边后图<strong>T</strong>会不会出现回路呢？</p>
<p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：如果所选择加入的边的起点和终点都在<strong>T</strong>的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p>
<p>步骤1：初始化。将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，边集TE={ }，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</p>
<p>步骤2：在E中寻找权值最小的边（i，j）。</p>
<p>步骤3：如果顶点i和j位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并。</p>
<p>步骤4：将边（i，j）从集合E中删去，即E=E−{（i，j）}。</p>
<p>步骤 5：如果选取边数小于n−1，转步骤2；否则，算法结束，生成最小生成树T。</p>
<h4 id="2．完美图解">2．完美图解</h4>
<p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-98所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/137.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-98　无向连通带权图**G**</b></center>
<p>（1）初始化</p>
<p>将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，如图2-99所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/138.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-99　按边权值排序后的图**G**</b></center>
<p>边集初始化为空集，TE={ }，把每个结点都初始化为一个孤立的分支，即一个顶点对应一个集合，集合号为该结点的序号，如图2-100所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/139.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-100　每个结点初始化集合号</b></center>
<p>（2）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">1</sub>（2，7），边值为1。</p>
<p>（3）合并</p>
<p>结点2和结点7的集合号不同，即属于两个不同连通分支，则将边（2，7）加入边集TE，执行合并操作（将两个连通分支所有结点合并为一个集合）；假设把小的集合号赋值给大的集合号，那么7号结点的集合号也改为2，如图2-101所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/140.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-101　最小生成树求解过程</b></center>
<p>（4）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">2</sub>（4，5），边值为3。</p>
<p>（5）合并</p>
<p>结点4和结点5集合号不同，即属于两个不同连通分支，则将边（4，5）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么5号结点的集合号也改为4，如图2-102所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/141.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-102　最小生成树求解过程</b></center>
<p>（6）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">3</sub>（3，7），边值为4。</p>
<p>（7）合并</p>
<p>结点3和结点7集合号不同，即属于两个不同连通分支，则将边（3，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么3号结点的集合号也改为2，如图2-103所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/142.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-103　最小生成树求解过程</b></center>
<p>（8）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">4</sub>（4，7），边值为9。</p>
<p>（9）合并</p>
<p>结点4和结点7集合号不同，即属于两个不同连通分支，则将边（4，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么4、5号结点的集合号都改为2，如图2-104所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/143.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-104　最小生成树求解过程</b></center>
<p>（10）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">5</sub>（3，4），边值为15。</p>
<p>（11）合并</p>
<p>结点3和结点4集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p>
<p>（12）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">6</sub>（5，7），边值为16。</p>
<p>（13）合并</p>
<p>结点5和结点7集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p>
<p>（14）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">7</sub>（5，6），边值为17。</p>
<p>（15）合并</p>
<p>结点5和结点6集合号不同，即属于两个不同连通分支，则将边（5，6）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么6号结点的集合号都改为2，如图2-105所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/144.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-105　最小生成树求解过程</b></center>
<p>（16）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">8</sub>（2，3），边值为20。</p>
<p>（17）合并</p>
<p>结点2和结点3集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p>
<p>（18）找最小</p>
<p>在E中寻找权值最小的边e<sub class="my_markdown">9</sub>（1，2），边值为23。</p>
<p>（19）合并</p>
<p>结点1和结点2集合号不同，即属于两个不同连通分支，则将边（1，2）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么2、3、4、5、6、7号结点的集合号都改为1，如图2-106所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/145.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图2-106　最小生成树</b></center>
<p>（20）选中的各边和所有的顶点就是最小生成树，各边权值之和就是最小生成树的代价。</p>
<h4 id="3．伪码详解">3．伪码详解</h4>
<p>（1）数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nodeset[N];<span class="comment">//集合号数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="comment">//边的存储结构</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br></pre></td></tr></table></figure>
<p>（2）初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;<span class="comment">//每个结点赋值一个集合号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（3）对边进行排序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//定义优先级，按边值进行升序排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(e, e+m, comp);<span class="comment">//调用系统排序函数</span></span><br></pre></td></tr></table></figure>
<p>（4）合并集合</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];<span class="comment">//p为a结点的集合号</span></span><br><span class="line">     <span class="type">int</span> q = nodeset[b]; <span class="comment">//q为b结点的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//集合号相同，什么也不做，返回</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的全部改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4．实战演练">4．实战演练</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> nodeset[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];</span><br><span class="line">     <span class="type">int</span> q = nodeset[b];</span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  Init(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u,v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;</span><br><span class="line">  sort(e, e+m, comp);</span><br><span class="line">  <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5．算法复杂度分析">5．算法复杂度分析</h4>
<p>（1）时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为e<em>loge，算法的时间复杂度为O(e</em>loge)。而合并集合需要n−1次合并，每次为O(n)，合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<p>（2）空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是O(n)。</p>
<h4 id="6．算法优化拓展">6．算法优化拓展</h4>
<p>该算法合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)，我们可以用并查集（见附录E）的思想优化，使合并集合的时间复杂度降为O(e*logn)，优化后的程序如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-9</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//排序优先级，按边的权值从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          father[i] = i;<span class="comment">//顶点所属集合号，初始化每个顶点一个集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//找祖宗</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x != father[x])</span><br><span class="line">     father[x] = Find(father[x]);<span class="comment">//把当前结点到其祖宗路径上的所有结点的集合号改为祖宗集合号</span></span><br><span class="line">     <span class="keyword">return</span> father[x]; <span class="comment">//返回其祖宗的集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//两结点合并集合号</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = Find(a); <span class="comment">//找a的集合号</span></span><br><span class="line">     <span class="type">int</span> q = Find(b); <span class="comment">//找b的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(p &gt; q)</span><br><span class="line">           father[p] = q;<span class="comment">//小的集合号赋值给大的集合号</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">           father[q] = p;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Init(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">    sort(e, e+m, comp);</span><br><span class="line">    <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure>
<h4 id="7．两种算法的比较">7．两种算法的比较</h4>
<p>（1）从算法的思想可以看出，如果图<strong>G</strong>中的边数较小时，可以采用Kruskal算法，因为Kruskal算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</p>
<p>（2）从时间上讲，Prim算法的时间复杂度为O(n<sup class="my_markdown">2</sup>)，Kruskal算法的时间复杂度为O(eloge)。</p>
<p>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V−U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>《趣学算法》——第二章（贪心算法）</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://drie.cn/posts/7177a99d.html">https://drie.cn/posts/7177a99d.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Drie🦋</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-02</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-02</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://drie.cn/donate/simple/images/WeChanSQ.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/donate/simple/images/WeChanSQ.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://drie.cn/donate/simple/images/AliPayQR.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/donate/simple/images/AliPayQR.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://source.drie.cn/badge/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/8f61c33e.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/177.png" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">《趣学算法》—第三章（分治法）</div></div></a></div><div class="next-post pull-right"><a href="/posts/87ab2347.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/60.png" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《趣学算法》——第一章（算法之美）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-text">第二章　贪心算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-%E4%BA%BA%E4%B9%8B%E5%88%9D%EF%BC%8C%E6%80%A7%E6%9C%AC%E8%B4%AA"><span class="toc-text">2.1　人之初，性本贪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E8%B4%AA%E5%BF%83%E6%9C%AC%E8%B4%A8"><span class="toc-text">2.1.1　贪心本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-%E8%B4%AA%E4%BA%A6%E6%9C%89%E9%81%93"><span class="toc-text">2.1.2　贪亦有道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D"><span class="toc-text">2.1.3　贪心算法秘籍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-%E5%8A%A0%E5%8B%92%E6%AF%94%E6%B5%B7%E7%9B%97%E8%88%B9%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E8%A3%85%E8%BD%BD%E9%97%AE%E9%A2%98"><span class="toc-text">2.2　加勒比海盗船——最优装载问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.2.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.2.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.2.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.2.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.2.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2．优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E4%B8%8E%E5%9B%9B%E5%8D%81%E5%A4%A7%E7%9B%97%E2%80%94%E2%80%94%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">2.3　阿里巴巴与四十大盗——背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.3.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.3.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.3.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.3.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.3.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.3.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E9%AB%98%E7%BA%A7%E9%92%9F%E7%82%B9%E7%A7%98%E4%B9%A6%E2%80%94%E2%80%94%E4%BC%9A%E8%AE%AE%E5%AE%89%E6%8E%92"><span class="toc-text">2.4　高级钟点秘书——会议安排</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.4.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.4.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.4.3　完美图解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E5%8E%9F%E5%A7%8B%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%97%B6%E9%97%B4%E8%A1%A8%EF%BC%88%E8%A7%81%E8%A1%A82-7%EF%BC%89%EF%BC%9A"><span class="toc-text">1．原始的会议时间表（见表2-7）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%8E%92%E5%BA%8F%E5%90%8E%E7%9A%84%E4%BC%9A%E8%AE%AE%E6%97%B6%E9%97%B4%E8%A1%A8%EF%BC%88%E8%A7%81%E8%A1%A82-8%EF%BC%89%EF%BC%9A"><span class="toc-text">2．排序后的会议时间表（见表2-8）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E8%B4%AA%E5%BF%83%E9%80%89%E6%8B%A9%E8%BF%87%E7%A8%8B"><span class="toc-text">3．贪心选择过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8E%E6%9E%84%E9%80%A0%E6%9C%80%E4%BC%98%E8%A7%A3"><span class="toc-text">4．构造最优解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.4.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.4.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.4.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-2"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-%E4%B8%80%E5%9C%BA%E8%AF%B4%E8%B5%B0%E5%B0%B1%E8%B5%B0%E7%9A%84%E6%97%85%E8%A1%8C%E2%80%94%E2%80%94%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-text">2.5　一场说走就走的旅行——最短路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.5.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.5.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.5.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.5.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.5.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.5.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">1．算法时间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-3"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-%E7%A5%9E%E7%A7%98%E7%94%B5%E6%8A%A5%E5%AF%86%E7%A0%81%E2%80%94%E2%80%94%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-text">2.6　神秘电报密码——哈夫曼编码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.6.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.6.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.6.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.6.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.6.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.6.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-4"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-%E6%B2%9F%E9%80%9A%E6%97%A0%E9%99%90%E6%A0%A1%E5%9B%AD%E7%BD%91%E2%80%94%E2%80%94%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-text">2.7　沟通无限校园网——最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">2.7.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.7.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2.7.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">2.7.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">2.7.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">2.7.6　算法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-7-7-%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2.7.7　算法优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">1．算法设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">2．完美图解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%EF%BC%8E%E4%BC%AA%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">3．伪码详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%EF%BC%8E%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4．实战演练</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">5．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">6．算法优化拓展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7%EF%BC%8E%E4%B8%A4%E7%A7%8D%E7%AE%97%E6%B3%95%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">7．两种算法的比较</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://drie.cn/" title="drie🦋"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/img/avatar.gif" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2023-2024</b></span><span><b>&nbsp;&nbsp;By Drie🦋</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20246897" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20246897号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/萌ICP备-20246897-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://source.drie.cn/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://source.drie.cn/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://source.drie.cn/js/fancybox.umd.min.js"></script><script src="https://source.drie.cn/js/instantpage.min.js" type="module"></script><script src="https://source.drie.cn/js/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.drie.cn/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.drie.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://source.drie.cn/js/jquery.min.js"></script><script async src="https://source.drie.cn/js/vue.min.js"></script><script async src="https://source.drie.cn/js/index.js"></script><script async src="https://source.drie.cn/js/clipboard.min.js"></script><script defer type="text/javascript" src="https://source.drie.cn/js/sweetalert2.all.js"></script><script async src="https://source.drie.cn/js/pace.min.js"></script><script defer src="https://source.drie.cn/js/winbox.bundle.min.js"></script><script async src="https://source.drie.cn/js/font_3586335_hsivh70x0fm.js"></script><script async src="https://source.drie.cn/js/font_3636804_gr02jmjr3y9.js"></script><script async src="https://source.drie.cn/js/font_3612150_kfv55xn3u2g.js"></script><script async src="https://source.drie.cn/js/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/drie.js"></script><link rel="stylesheet" href="https://source.drie.cn/js/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://source.drie.cn/js/APlayer.min.js"></script><script src="https://source.drie.cn/js/Meting.min.js"></script><script src="https://source.drie.cn/js/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://drie.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 小Dの算法学习笔记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://drie.cn/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 小Dの案例演示笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://drie.cn/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/177.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》—第三章（分治法）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/105.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》——第二章（贪心算法）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/img/default_cover_16.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/60.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》——第一章（算法之美）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://source.drie.cn/js/swiper.min.js"></script><script defer data-pjax src="https://source.drie.cn/js/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://source.drie.cn/js/wow.min.js"></script><script defer src="https://source.drie.cn/js/wow_init.js"></script><script data-pjax src="https://source.drie.cn/js/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>