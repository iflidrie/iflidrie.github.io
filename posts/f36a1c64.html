<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><div id="myscoll"></div><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《趣学算法》——第四章（动态规则) | Drie🦋</title><meta name="keywords" content="Java,MySQL,算法,代码,博客,Butterfly,Hexo,Drie🦋,Drie"><meta name="author" content="Drie🦋"><meta name="copyright" content="Drie🦋"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="第四章  动态规划 前面讲的分治法是将原问题分解为若干个规模较小、形式相同的子问题，然后求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，那么用分治法就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率。那该怎么办呢？ 动态规划闪亮登场了！ 4.1　神奇的兔子序列 公元1202年，意大利数学家列昂纳多•">
<meta property="og:type" content="article">
<meta property="og:title" content="《趣学算法》——第四章（动态规则)">
<meta property="og:url" content="https://drie.cn/posts/f36a1c64.html">
<meta property="og:site_name" content="Drie🦋">
<meta property="og:description" content="第四章  动态规划 前面讲的分治法是将原问题分解为若干个规模较小、形式相同的子问题，然后求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，那么用分治法就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率。那该怎么办呢？ 动态规划闪亮登场了！ 4.1　神奇的兔子序列 公元1202年，意大利数学家列昂纳多•">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://source.drie.cn/qxsf-images/312.png">
<meta property="article:published_time" content="2024-07-04T02:16:25.000Z">
<meta property="article:modified_time" content="2024-07-04T03:27:11.918Z">
<meta property="article:author" content="Drie🦋">
<meta property="article:tag" content="Java,MySQL,算法,代码,博客,Butterfly,Hexo,Drie🦋,Drie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://source.drie.cn/qxsf-images/312.png"><link rel="shortcut icon" href="/"><link rel="canonical" href="https://drie.cn/posts/f36a1c64"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://source.drie.cn/js/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":230},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.js',
      css: 'https://cdnjs.cloudflare.com/ajax/libs/flickr-justified-gallery/2.1.2/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《趣学算法》——第四章（动态规则)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-04 11:27:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const now = new Date()
          const hour = now.getHours()
          const isNight = hour <= 6 || hour >= 18
          if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
          else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="https://source.drie.cn/js/index.css"><style id="themeColor"></style><style id="rightSide"></style><style id="transPercent"></style><style id="blurNum"></style><style id="settingStyle"></style><span id="fps"></span><style id="defineBg"></style><style id="menu_shadow"></style><svg aria-hidden="true" style="position:absolute; overflow:hidden; width:0; height:0"><symbol id="icon-sun" viewBox="0 0 1024 1024"><path d="M960 512l-128 128v192h-192l-128 128-128-128H192v-192l-128-128 128-128V192h192l128-128 128 128h192v192z" fill="#FFD878" p-id="8420"></path><path d="M736 512a224 224 0 1 0-448 0 224 224 0 1 0 448 0z" fill="#FFE4A9" p-id="8421"></path><path d="M512 109.248L626.752 224H800v173.248L914.752 512 800 626.752V800h-173.248L512 914.752 397.248 800H224v-173.248L109.248 512 224 397.248V224h173.248L512 109.248M512 64l-128 128H192v192l-128 128 128 128v192h192l128 128 128-128h192v-192l128-128-128-128V192h-192l-128-128z" fill="#4D5152" p-id="8422"></path><path d="M512 320c105.888 0 192 86.112 192 192s-86.112 192-192 192-192-86.112-192-192 86.112-192 192-192m0-32a224 224 0 1 0 0 448 224 224 0 0 0 0-448z" fill="#4D5152" p-id="8423"></path></symbol><symbol id="icon-moon" viewBox="0 0 1024 1024"><path d="M611.370667 167.082667a445.013333 445.013333 0 0 1-38.4 161.834666 477.824 477.824 0 0 1-244.736 244.394667 445.141333 445.141333 0 0 1-161.109334 38.058667 85.077333 85.077333 0 0 0-65.066666 135.722666A462.08 462.08 0 1 0 747.093333 102.058667a85.077333 85.077333 0 0 0-135.722666 65.024z" fill="#FFB531" p-id="11345"></path><path d="M329.728 274.133333l35.157333-35.157333a21.333333 21.333333 0 1 0-30.165333-30.165333l-35.157333 35.157333-35.114667-35.157333a21.333333 21.333333 0 0 0-30.165333 30.165333l35.114666 35.157333-35.114666 35.157334a21.333333 21.333333 0 1 0 30.165333 30.165333l35.114667-35.157333 35.157333 35.157333a21.333333 21.333333 0 1 0 30.165333-30.165333z" fill="#030835" p-id="11346"></path></symbol></svg><!-- hexo injector head_end start --><link rel="stylesheet" href="https://source.drie.cn/js/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/swiperstyle.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://source.drie.cn/js/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://source.drie.cn/js/carousel-touch.js"></script><link rel="stylesheet" href="https://source.drie.cn/js/animate.min.css" media="print" onload="this.media='screen'"><link rel="stylesheet" href="https://source.drie.cn/js/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="Drie🦋" type="application/atom+xml">
</head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/img/avatar.webp" onerror="onerror=null;src='/assets/r1.jpg'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span class="menu_word" style="font-size:17px"> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/ps/"><i class="fa-fw fas fa-diamond faa-tada"></i><span class="menu_word" style="font-size:17px"> 在线PS</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/qr/"><i class="fa-fw fas fa-qrcode faa-tada"></i><span class="menu_word" style="font-size:17px"> 二维码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/vip/"><i class="fa-fw fas fa-television faa-tada"></i><span class="menu_word" style="font-size:17px"> 视频解析</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Drie🦋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page faa-parent animated-hover" href="/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-home"></use></svg><span class="menu_word" style="font-size:17px"> 首页</span></a></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--article"></use></svg><span class="menu_word" style="font-size:17px"> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-guidang1">                   </use></svg><span class="menu_word" style="font-size:17px"> 归档</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-sekuaibiaoqian">                   </use></svg><span class="menu_word" style="font-size:17px"> 标签</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-fenlei">                   </use></svg><span class="menu_word" style="font-size:17px"> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pinweishenghuo"></use></svg><span class="menu_word" style="font-size:17px"> 休闲</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/life/music/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-yinle">                   </use></svg><span class="menu_word" style="font-size:17px"> 八音盒</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/movies/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-dianying1">                   </use></svg><span class="menu_word" style="font-size:17px"> 影院</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/life/games/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-youxishoubing">                   </use></svg><span class="menu_word" style="font-size:17px"> 游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xiangzi"></use></svg><span class="menu_word" style="font-size:17px"> 八宝箱</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/box/gallery/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-tubiaozhizuomoban">                   </use></svg><span class="menu_word" style="font-size:17px"> 画廊</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/animation/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-nvwumao">                   </use></svg><span class="menu_word" style="font-size:17px"> 动画</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/box/nav/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-zhifengche">                   </use></svg><span class="menu_word" style="font-size:17px"> 网址导航</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shejiaoxinxi"></use></svg><span class="menu_word" style="font-size:17px"> 社交</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/social/fcircle/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-pengyouquan">                   </use></svg><span class="menu_word" style="font-size:17px"> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-liuyan">                   </use></svg><span class="menu_word" style="font-size:17px"> 留言板</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/social/link/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-lianjie">                   </use></svg><span class="menu_word" style="font-size:17px"> 友人帐</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-wangye"></use></svg><span class="menu_word" style="font-size:17px"> 网站</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/site/census/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon--tongjibiao">                   </use></svg><span class="menu_word" style="font-size:17px"> 网站统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/echarts/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-shujutongji1">                   </use></svg><span class="menu_word" style="font-size:17px"> 文章统计</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/site/time/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-xianxingshalou">                   </use></svg><span class="menu_word" style="font-size:17px"> 旧时光</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover hide" href="javascript:void(0);"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-maoliang"></use></svg><span class="menu_word" style="font-size:17px"> 个人</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/personal/bb/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-qunliaotian">                   </use></svg><span class="menu_word" style="font-size:17px"> 唠叨</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/love/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-love-sign">                   </use></svg><span class="menu_word" style="font-size:17px"> 恋爱小屋</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/personal/about/"><svg class="menu_icon faa-tada" aria-hidden="true" style="width:1.30em;height:1.30em;vertical-align:-0.15em;fill:currentColor;overflow:hidden;"><use xlink:href="#icon-paperplane">                   </use></svg><span class="menu_word" style="font-size:17px"> 关于</span></a></li></ul></div><div class="menus_item"><a class="site-page group faa-parent animated-hover" href="javascript:void(0);"><i class="fa-fw fas fa-list faa-tada"></i><span class="menu_word" style="font-size:17px"> 工具</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/ps/"><i class="fa-fw fas fa-diamond faa-tada"></i><span class="menu_word" style="font-size:17px"> 在线PS</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/qr/"><i class="fa-fw fas fa-qrcode faa-tada"></i><span class="menu_word" style="font-size:17px"> 二维码</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/vip/"><i class="fa-fw fas fa-television faa-tada"></i><span class="menu_word" style="font-size:17px"> 视频解析</span></a></li></ul></div></div><center id="name-container"><a id="page-name" href="javascript:scrollToTop()">PAGE_NAME</a></center><div id="nav-right"><div id="search-button"><a class="search faa-parent animated-hover" title="检索站内任何你想要的信息"><svg class="faa-tada icon" style="height:24px;width:24px;fill:currentColor;position:relative;top:6px" aria-hidden="true"><use xlink:href="#icon-valentine_-search-love-find-heart"></use></svg><span> 搜索</span></a></div><a class="meihua faa-parent animated-hover" onclick="toggleWinbox()" title="美化设置-自定义你的风格" id="meihua-button"><svg class="faa-tada icon" style="height:26px;width:26px;fill:currentColor;position:relative;top:8px" aria-hidden="true"><use xlink:href="#icon-tupian1"></use></svg></a><a class="sun_moon faa-parent animated-hover" onclick="switchNightMode()" title="浅色和深色模式转换" id="nightmode-button"><svg class="faa-tada" style="height:25px;width:25px;fill:currentColor;position:relative;top:7px" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon">       </use></svg></a><div id="toggle-menu"><a><i class="fas fa-bars fa-fw"></i></a></div></div></div></nav><div id="post-info"><h1 class="post-title">《趣学算法》——第四章（动态规则)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><svg class="meta_icon post-meta-icon" style="width:30px;height:30px;position:relative;top:10px"><use xlink:href="#icon-rili"></use></svg><span class="post-meta-label">发表于 </span><time class="post-meta-date-created" datetime="2024-07-04T02:16:25.000Z" title="发表于 2024-07-04 10:16:25">2024-07-04</time><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-gengxin1"></use></svg><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-07-04T03:27:11.918Z" title="更新于 2024-07-04 11:27:11">2024-07-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:18px;height:18px;position:relative;top:5px"><use xlink:href="#icon-biaoqian"></use></svg><a class="post-meta-categories" href="/categories/%E7%AE%97%E6%B3%95/">算法</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:8px"><use xlink:href="#icon-charuword"></use></svg><span class="post-meta-label">字数总计:</span><span class="word-count">4w</span><span class="post-meta-separator">|</span><svg class="meta_icon post-meta-icon" style="width:20px;height:20px;position:relative;top:5px"><use xlink:href="#icon-shizhong"></use></svg><span class="post-meta-label">阅读时长:</span><span>162分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="《趣学算法》——第四章（动态规则)"><svg class="meta_icon post-meta-icon" style="width:25px;height:25px;position:relative;top:5px"><use xlink:href="#icon-eye"></use></svg><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h3 id="第四章-动态规划">第四章  动态规划</h3>
<p>前面讲的分治法是将原问题分解为若干个规模较小、形式相同的子问题，然后求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，那么用分治法就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率。那该怎么办呢？</p>
<p>动态规划闪亮登场了！</p>
<h3 id="4-1-神奇的兔子序列">4.1　神奇的兔子序列</h3>
<p>公元1202年，意大利数学家列昂纳多•斐波那契（Leonardo Fibonacci）在《算盘全书》（Liber Abaci）中描述了一个神奇的兔子序列，这就是著名的斐波那契序列。</p>
<p>假设第1个月有1对刚诞生的兔子，第2个月进入成熟期，第3个月开始生育兔子，而1对成熟的兔子每月会生1对兔子，兔子永不死去……那么，由1对初生兔子开始，12个月后会有多少对兔子呢？如果是N对初生的兔子开始，M月后又会有多少对兔子呢？</p>
<p>第1个月，兔子①没有繁殖能力，所以还是 <strong>1</strong> 对。</p>
<p>第2个月，兔子①进入成熟期，仍然是 <strong>1</strong> 对。</p>
<p>第3个月，兔子①生了1对小兔②，于是这个月共有2对（ <strong>1+1=2</strong> ）兔子。</p>
<p>第4个月，兔子①又生了1对小兔③。兔子②进入成熟期。共有3对（ <strong>1+2=3</strong> ）兔子。</p>
<p>第5个月，兔子①又生了1对小兔④，兔子②也生下了1对小兔⑤。兔子③进入成熟期。共有5对（ <strong>2+3=5</strong> ）兔子。</p>
<p>第6个月，兔子①②③各生下了1对小兔。兔子④⑤进入成熟期。新生3对兔子加上原有的5对兔子，这个月共有8对（ <strong>3+5=8</strong> ）兔子。</p>
<p>……</p>
<p>这个数列有十分明显的特点，从第3个月开始，当月的兔子数=上月兔子数+本月新生小兔子数，而本月新生的兔子正好是上上月的兔子数，即当月的兔子数=前两月兔子之和。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/279.gif" alt="code"><br>
我们仅以F(6)为例，如图4-1所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/280.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-1　F(6)的递归树</b></center>
<p>从图4-1可以看出，有大量的结点重复（子问题重叠），F(4)、F(3)、F(2)、F(1)均重复计算多次。</p>
<h3 id="4-2-动态规划基础">4.2　动态规划基础</h3>
<p>动态规划是1957年理查德•贝尔曼在《Dynamic Programming》一书中提出来的，可能有的读者不知道这个人，但他的一个算法你可能听说过，他和莱斯特•福特一起提出了求解最短路径的Bellman-Ford 算法，该算法解决了Dijkstra算法不能处理的负权值边的问题。</p>
<p>《Dynamic Programming》中的“Programming”不是编程的意思，而是指一种表格处理法。我们把每一步得到的子问题结果存储在表格里，每次遇到该子问题时不需要再求解一遍，只需要查询表格即可。</p>
<h3 id="4-2-1-算法思想">4.2.1　算法思想</h3>
<p>动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子问题，自顶向下求解各子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。</p>
<h3 id="4-2-2-算法要素">4.2.2　算法要素</h3>
<p>什么问题可以使用动态规划呢？我们首先要分析问题是否具有以下两个性质：</p>
<p>（1）最优子结构</p>
<p>最优子结构性质是指问题的最优解包含其子问题的最优解。最优子结构是使用动态规划的最基本条件，如果不具有最优子结构性质，就不可以使用动态规划解决。</p>
<p>（2）子问题重叠</p>
<p>子问题重叠是指在求解子问题的过程中，有大量的子问题是重复的，那么只需要求解一次，然后把结果存储在表中，以后使用时可以直接查询，不需要再次求解。子问题重叠不是使用动态规划的必要条件，但问题存在子问题重叠更能够充分彰显动态规划的优势。</p>
<h3 id="4-2-3-解题秘籍">4.2.3　解题秘籍</h3>
<p>遇到一个实际问题，如何采用动态规划来解决呢？</p>
<p>（1）分析最优解的结构特征。</p>
<p>（2）建立最优值的递归式。</p>
<p>（3）自底向上计算最优值，并记录。</p>
<p>（4）构造最优解。</p>
<p>以神奇的兔子序列问题为例。</p>
<p>（1）分析最优解的结构特征</p>
<p>我们通过分析发现，前两个月都是1对兔子，而从第3个月开始，当月的兔子数等于前两个月的兔子数，如果把每个月的兔子数看作一个最小的子问题，那么求解第n个月的兔子数，包含了第n−1个月的兔子数和第n−2个月的兔子数这两个子问题。</p>
<p>（2）根据最优解结构特征，建立递归式</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/279.gif" alt="code"><br>
（3)自底向上计算最优值</p>
<p>看到递归式，我们也很难立即求解F(n)，如果直接递归调用将会产生大量的子问题重复，那怎么办呢？动态规划提供了一个好办法，自底向上求解，记录结果，重复的问题只需求解一次即可，如图4-2所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/281.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-2　F(6)的递归树自底向上求解</b></center>
<p>例如：</p>
<p>F(1)=1</p>
<p>F(2)=1</p>
<p>F(3)= F(2)+F(1)=2</p>
<p>F(4)= F(3)+F(2)=3</p>
<p>F(5)= F(4)+F(3)=5</p>
<p>F(6)= F(5)+F(4)=8</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib2</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> F[n+<span class="number">1</span>];</span><br><span class="line">  F[<span class="number">1</span>]=<span class="number">1</span>；</span><br><span class="line">  F[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">      F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">  <span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（4）构造最优解</p>
<p>本题中自底向上求解到树根就是我们要的最优解。</p>
<p>在众多的算法中，很多读者觉得动态规划是比较难的算法，为什么呢？难在递归式！</p>
<p>很多复杂问题，很难找到相应的递归式。实际上，一旦得到递归式，那算法就已经实现了99%，剩下的程序实现就非常简单了。那么后面的例子就重点讲解遇到一个问题怎么找到它的递归式。</p>
<p>蛇打三寸，一招致命。</p>
<h3 id="4-3-孩子有多像爸爸——最长的公共子序列">4.3　孩子有多像爸爸——最长的公共子序列</h3>
<p>假设爸爸对应的基因序列为X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}，孩子对应的基因序列Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，那么怎么找到他们有多少相似的基因呢？</p>
<p>如果按照严格递增的顺序，从爸爸的基因序列X中取出一些值，组成序列Z={x<sub class="my_markdown">i</sub><sub>1</sub>，x<sub class="my_markdown">i</sub><sub>2</sub>，x<sub class="my_markdown">i</sub><sub>3</sub>，…，x<sub class="my_markdown">ik</sub>}，其中下标{i<sub>1</sub>，i<sub>2</sub>，i<sub>3</sub>，…，i<sub class="my_markdown">k</sub> }是一个严格递增的序列。那么就说Z是X的子序列，Z中元素的个数就是该子序列的长度。</p>
<p>X和Y的公共子序列是指该序列既是X的子序列，也是Y的子序列。</p>
<p>最长公共子序列问题是指：给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的一个最长的公共子序列。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/282.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-3　人类基因序列</b></center>
<h3 id="4-3-1-问题分析">4.3.1　问题分析</h3>
<p>给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的一个最长的公共子序列。</p>
<p>例如：X=（A，B，C，B，A，D，B），Y=（B，C，B，A，A，C），那么最长公共子序列是B，C，B，A。</p>
<p>如何找到最长公共子序列呢？</p>
<p>如果使用暴力搜索方法，需要穷举X的所有子序列，检查每个子序列是否也是Y的子序列，记录找到的最长公共子序列。X的子序列有2<sup class="my_markdown">m</sup>个，因此暴力求解的方法时间复杂度为指数阶，这是我们避之不及的爆炸性时间复杂度。</p>
<p>那么能不能用动态规划算法呢？</p>
<p>下面分析该问题是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<p>假设已经知道Z<sub class="my_markdown">k</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub>}是X<sub class="my_markdown">m</sub>={x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y<sub class="my_markdown">n</sub>={y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}的最长公共子序列。这个假设很重要，我们都是这样假设已经知道了最优解。</p>
<p>那么可以分3种情况讨论。</p>
<ul>
<li>x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>= z<sub class="my_markdown">k</sub>：那么Z<sub><em>k</em>−1</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub><sub>−1</sub>}是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，如图4-4所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/283.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-4　最长公共子序列</b></center>
<p><strong>反证法证明</strong>  <strong>：</strong> 如果Z<sub class="my_markdown">k</sub><sub>−1</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub><sub>−1</sub>}不是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub><sub>−1</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub><sub>−1</sub>|。如果在X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的后面添加一个相同的字符x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>，则z<sub class="my_markdown">k</sub>=x<sub class="my_markdown">m</sub>=y<sub class="my_markdown">n</sub>，|M+{z<sub class="my_markdown">k</sub>}|&gt;|Z<sub class="my_markdown">k</sub><sub>−1</sub>+{z<sub class="my_markdown">k</sub>}|=|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p>
<ul>
<li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>，x<sub class="my_markdown">m</sub>≠ z<sub class="my_markdown">k</sub>：我们可以把x<sub class="my_markdown">m</sub>去掉，那么Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，如图4-5所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/284.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-5　最长公共子序列</b></center>
<p><strong>反证法证明：</strong> 如果Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub>|。如果我们在X<sub class="my_markdown">m</sub><sub>−1</sub>的后面添加一个字符x<sub class="my_markdown">m</sub>，那么M也是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，因为|M|&gt;|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p>
<ul>
<li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>，y<sub class="my_markdown">n</sub>≠ z<sub class="my_markdown">k</sub>：我们可以把y<sub class="my_markdown">n</sub>去掉，那么Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，如图4-6所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/285.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-6　最长公共子序列</b></center>
<p><strong>反证法证明：</strong> 如果Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub>|。如果我们在Y<sub class="my_markdown">n</sub><sub>−1</sub>的后面添加一个字符y<sub class="my_markdown">n</sub>，那么M也是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，因为|M|&gt;|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p>
<p>（2）建立最优值的递归式。</p>
<p>设<strong>c</strong>[i][j]表示X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最长公共子序列长度。</p>
<ul>
<li>x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>= z<sub class="my_markdown">k</sub>：那么<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1；</li>
<li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>：那么我们只需要求解X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最长公共子序列和X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最长公共子序列，比较它们的长度哪一个更大，就取哪一个值。即<strong>c</strong>[i][j]= max{<strong>c</strong>[i][j−1], <strong>c</strong>[i−1][j]}。</li>
<li>最长公共子序列长度递归式：</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/286.jpg" alt="code"><br>
（3)底向上计算最优值，并记录最优值和最优策略</p>
<p>i=1时：{x<sub class="my_markdown">1</sub>}和{y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p>
<p>i=2时：{x<sub class="my_markdown">2</sub>}和{y<sub>1</sub>，y<sub class="my_markdown">2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p>
<p>……</p>
<p>i=m时：{x<sub class="my_markdown">m</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p>
<p>（4）构造最优解</p>
<p>上面的求解过程只是得到了最长公共子序列长度，并不知道最长公共子序列是什么，那怎么办呢？</p>
<p>例如，现在已经求出<strong>c</strong>[m][n]=5，表示X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列长度是5，那么这个5是怎么得到的呢？我们可以反向追踪5是从哪里来的。根据递推式，有如下情况。</p>
<p>x<sub class="my_markdown">i</sub>= y<sub class="my_markdown">j</sub>时：<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1；</p>
<p>x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>时：<strong>c</strong>[i][j]= max{<strong>c</strong>[i][j−1], <strong>c</strong>[i−1][j]}；</p>
<p>那么<strong>c</strong>[i][j]的来源一共有3个：<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1，<strong>c</strong>[i][j]= <strong>c</strong>[i][j−1]，<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j]。在第3步自底向上计算最优值时，用一个辅助数组<strong>b</strong> [i][j]记录这3个来源：</p>
<p><strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1，<strong>b</strong>[i][j]=1；</p>
<p><strong>c</strong>[i][j]= c[i][j−1]，<strong>b</strong>[i][j]=2；</p>
<p><strong>c</strong>[i][j]= c[i−1][j]，<strong>b</strong>[i][j]=3。</p>
<p>这样就可以根据<strong>b</strong>[m][n]反向追踪最长公共子序列，当<strong>b</strong>[i][j]=1时，输出x<sub class="my_markdown">i</sub>；当<strong>b</strong> [i][j]=2时，追踪<strong>c</strong>[i][j−1]；当<strong>b</strong>[i][j]=3时，追踪<strong>c</strong>[i−1][j]，直到i=0或j=0停止。</p>
<h3 id="4-3-2-算法设计">4.3.2　算法设计</h3>
<p>最长公共子序列问题满足动态规划的最优子结构性质，可以自底向上逐步得到最优解。</p>
<p>（1）确定合适的数据结构</p>
<p>采用二维数组<strong>c</strong>[][]来记录最长公共子序列的长度，二维数组<strong>b</strong>[][]来记录最长公共子序列的长度的来源，以便算法结束时倒推求解得到该最长公共子序列。</p>
<p>（2）初始化</p>
<p>输入两个字符串s<sub class="my_markdown">1</sub>、s<sub>2</sub>，初始化<strong>c</strong>[][]第一行第一列元素为0。</p>
<p>（3）循环阶段</p>
<ul>
<li>i = 1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li>
</ul>
<p>如果s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[j−1]，<strong>c</strong>[i][j] = <strong>c</strong>[i−1][j−1]+1；并记录最优策略来源<strong>b</strong>[i][j]=1；</p>
<p>如果s<sub class="my_markdown">1</sub>[0] ≠s<sub>2</sub>[j−1]，则公共子序列的长度为<strong>c</strong>[i][j−1]和<strong>c</strong>[i−1][j]中的最大值，如果<strong>c</strong>[i][j−1]≥<strong>c</strong>[i−1][j]，则<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，最优策略来源<strong>b</strong>[i][j]=2；否则<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j]，最优策略来源<strong>b</strong>[i][j]=3。</p>
<ul>
<li>i = 2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li>
<li>以此类推，直到i &gt; len1时，算法结束，这时<strong>c</strong>[len1][len2]就是最长公共序列的长度。</li>
</ul>
<p>（4）构造最优解</p>
<p>根据最优决策信息数组<strong>b</strong>[][]递归构造最优解，即输出最长公共子序列。因为我们在求最长公共子序列长度<strong>c</strong>[i][j]的过程中，用<strong>b</strong>[i][j]记录了<strong>c</strong>[i][j]的来源，那么就可以根据<strong>b</strong>[i][j]数组倒推最优解。</p>
<p>如果<strong>b</strong>[i][j]=1，说明s<sub class="my_markdown">1</sub>[i−1]=s<sub>2</sub>[j−1]，那么就可以递归求解print(i−1, j−1)；然后输出s<sub class="my_markdown">1</sub>[i−1]。</p>
<p><strong>注意：</strong> 如果先输出，后递归求解print(i−1,j−1)，则输出的结果是倒序。</p>
<p>如果<strong>b</strong>[i][j]=2，说明s<sub class="my_markdown">1</sub>[i−1]≠s<sub>2</sub>[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，递归求解print(i, j−1)。</p>
<p>如果<strong>b</strong>[i][j]=3，说明s<sub class="my_markdown">1</sub>[i−1]≠s<sub>2</sub>[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i−1][j]，递归求解print(i−1, j)。当i==0 || j==0时，递归结束。</p>
<h3 id="4-3-3-完美图解">4.3.3　完美图解</h3>
<p>以字符串s<sub class="my_markdown">1</sub>=“ABCADAB”，s<sub>2</sub>=“BACDBA”为例。</p>
<p>（1）初始化</p>
<p>len1=7，len2=6，初始化<strong>c</strong>[][]第一行、第一列元素为0，如图4-7所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/287.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-7　**c**[][]初始化</b></center>
<p>（2）i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“A”与“BACDBA”分别比较一次。</p>
<p>如果字符相等，<strong>c</strong>[i][j]取左上角数值加1，记录最优值来源<strong>b</strong>[i][j]=1。</p>
<p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果<strong>c</strong>[i][j]的值来源于左侧<strong>b</strong>[i][j]=2，来源于上面<strong>b</strong>[i][j]=3。</p>
<ul>
<li>j=1：A≠B，左侧=上面，取左侧数值，<strong>c</strong>[1][1]= 0，最优策略来源<strong>b</strong>[1][1]=2，如图4-8所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/288.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-8　最长公共子序列求解过程</b></center>
<ul>
<li>j=2：A=A，则取左上角数值加1，<strong>c</strong>[1][2]= <strong>c</strong>[0][1]+1=2，最优策略来源<strong>b</strong>[1][2] =1，如图4-9所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/289.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-9　最长公共子序列求解过程</b></center>
<ul>
<li>j=3：A≠C，左侧≥上面，取左侧数值，<strong>c</strong>[1][3]= 1，最优策略来源<strong>b</strong>[1][3] =2，如图4-10所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/290.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-10　最长公共子序列求解过程</b></center>
<ul>
<li>j= 4：A≠D，左侧≥上面，取左侧数值，<strong>c</strong>[1][4]= 1，最优策略来源<strong>b</strong>[1][4] =2，如图4-11所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/291.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-11　最长公共子序列求解过程</b></center>
<ul>
<li>j=5：A≠B，左侧≥上面，取左侧数值，<strong>c</strong>[1][5]=1，最优策略来源<strong>b</strong>[1][5]=2，如图4-12所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/292.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-12　最长公共子序列求解过程</b></center>
<ul>
<li>j=6：A=A，则取左上角数值加1，<strong>c</strong>[1][6]=1，最优策略来源<strong>b</strong>[1][6]=1，如图4-13所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/293.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-13　最长公共子序列求解过程</b></center>
<p>（3）i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“B”与“BACDBA”分别比较一次。</p>
<p>如果字符相等，<strong>c</strong>[i][j]取左上角数值加1，记录最优值来源<strong>b</strong>[i][j]=1。</p>
<p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果<strong>c</strong>[i][j]的值来源于左侧<strong>b</strong>[i][j]=2，来源于上面<strong>b</strong>[i][j]=3，如图4-14所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/294.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-14　最长公共子序列求解过程</b></center>
<p>（4）继续处理i=2，3，…，len1：s<sub class="my_markdown">1</sub>[i−1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。处理结果如图4-15所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/295.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-15　最长公共子序列求解结果</b></center>
<p><strong>c</strong>[][]右下角的值即为最长公共子序列的长度。<strong>c</strong>[7][6]=4，即字符串s<sub class="my_markdown">1</sub>=“ABCADAB”，s<sub>2</sub>=“BACDBA”的最长公共子序列的长度为4。</p>
<p>那么最长公共子序列包含哪些字符呢？</p>
<p>（5）构造最优解</p>
<p>首先读取<strong>b</strong>[7][6]=2，说明来源为2，向左找<strong>b</strong>[7][5]；</p>
<p><strong>b</strong>[7][5]=1，向左上角找<strong>b</strong>[6][4]，返回时输出s[6]=“B”；</p>
<p><strong>b</strong>[6][4]=3，向上找<strong>b</strong>[5][4]；</p>
<p><strong>b</strong>[5][4]=1，向左上角找<strong>b</strong>[4][3]，返回时输出s[4]=“D”；</p>
<p><strong>b</strong>[4][3]=2，向左找<strong>b</strong>[4][2]；</p>
<p><strong>b</strong>[4][2]=1，向左上角找<strong>b</strong>[3][1]，返回时输出s[3]=“C”；</p>
<p><strong>b</strong>[3][1]=3，向上找<strong>b</strong>[2][1]；</p>
<p><strong>b</strong>[2][1]=1，向左上角找，返回时输出s[1]=“B”；</p>
<p><strong>b</strong>[1][0]中列为0，算法停止，返回，输出最长公共子序列为BCDB，如图4-16所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/296.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-16　最长公共子序列构造最优解</b></center>
<h3 id="4-3-4-伪代码详解">4.3.4　伪代码详解</h3>
<p>（1）最长公共子序列求解函数</p>
<p>首先计算两个字符串的长度，然后从i=1开始，s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>中的每一个字符比较。</p>
<p>如果当前字符相同，则公共子序列的长度为<strong>c</strong>[i−1][j−1]+1，并记录最优策略来源<strong>b</strong>[i][j] = 1。</p>
<p>如果当前字符不相同，则公共子序列的长度为<strong>c</strong>[i][j−1]和<strong>c</strong>[i−1][j]中的最大值，如果<strong>c</strong>[i][j−1]≥<strong>c</strong>[i−1][j]，则最优策略来源<strong>b</strong>[i][j]=2；如果<strong>c</strong>[i][j−1]&lt;<strong>c</strong>[i−1][j]，则最优策略来源<strong>b</strong>[i][j]=3。直到i&gt; len1时，算法结束，这时<strong>c</strong>[len1][len2]就是我们要的最长公共序列长度。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">LCSL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> I,j;</span><br><span class="line">    <span class="keyword">for</span>(I = <span class="number">1</span>;I &lt;= len1;i++)    <span class="comment">//控制s1序列</span></span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= len2;j++)  <span class="comment">//控制s2序列</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>])    <span class="comment">//字符下标从0开始</span></span><br><span class="line">        &#123;   <span class="comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span></span><br><span class="line">            c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            b[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i][j<span class="number">-1</span>]&gt;=c[i<span class="number">-1</span>][j]) <span class="comment">//两者找最大值，并记录最优策略来源</span></span><br><span class="line">            &#123;</span><br><span class="line">                  c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">                  b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                  c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">                  b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）最优解输出函数</p>
<p>输出最优解仍然使用倒推法。因为我们在求最长公共子序列长度<strong>c</strong>[i][j]的过程中，用<strong>b</strong>[i][j]记录了<strong>c</strong>[i][j]的来源，那么就可以根据<strong>b</strong>[i][j]数组倒推最优解。</p>
<p>如果<strong>b</strong>[i][j]=1，说明s1[i−1]=s2[j−1]，那么我们就可以递归输出print(i−1，j−1)；然后输出s1[i−1]。</p>
<p>如果<strong>b</strong>[i][j]=2，说明s1[i−1]≠s2[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，递归输出print(i，j−1)。</p>
<p>如果<strong>b</strong>[i][j]=3，说明s1[i−1]≠s2[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i−1][j]，递归输出print(i−1，j)。当i==0||j==0时，递归结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">print</span><span class="params">(<span class="type">int</span> I, <span class="type">int</span> j)</span><span class="comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[i][j]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s1[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">2</span>)</span><br><span class="line">              print(I,j<span class="number">-1</span>);</span><br><span class="line">          <span class="keyword">else</span> print(i<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-3-5-实战演练">4.3.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">*ons tint N=<span class="number">1002</span>;</span><br><span class="line"><span class="type">int</span> c[N][N],b[N][N];</span><br><span class="line"><span class="type">char</span> s1[N],s2[N];</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCSL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> I,j;</span><br><span class="line">     <span class="keyword">for</span>(I = <span class="number">1</span>;I &lt;= len1;i++)<span class="comment">//控制s1序列</span></span><br><span class="line">       <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= len2;j++)<span class="comment">//控制s2序列</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>])</span><br><span class="line">         &#123;<span class="comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span></span><br><span class="line">             c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">             b[i][j] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(c[i][j<span class="number">-1</span>]&gt;=c[i<span class="number">-1</span>][j])</span><br><span class="line">             &#123;</span><br><span class="line">                  c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">                  b[i][j] = <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                  c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">                  b[i][j] = <span class="number">3</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> I, <span class="type">int</span> j)</span><span class="comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]==<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         print(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;s1[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">2</span>)</span><br><span class="line">               print(I,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               print(i<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> I,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串s1：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串s2：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; s2;</span><br><span class="line">     len1 = <span class="built_in">strlen</span>(s1);<span class="comment">//计算两个字符串的长度</span></span><br><span class="line">     len2 = <span class="built_in">strlen</span>(s2); </span><br><span class="line">     <span class="keyword">for</span>(I = <span class="number">0</span>;I &lt;= len1;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始化第一列为0</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;= len2;j++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[<span class="number">0</span>][j]=<span class="number">0</span>;<span class="comment">//初始化第一行为0</span></span><br><span class="line">     &#125;</span><br><span class="line">     LCSL();   <span class="comment">//求解最长公共子序列</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1和s2的最长公共子序列长度是：&quot;</span>&lt;&lt;c[len1][len2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1和s2的最长公共子序列是：&quot;</span>;</span><br><span class="line">     print(len1,len2);   <span class="comment">//递归构造最长公共子序列最优解</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现和测试</p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入字符串s1：</span><br><span class="line">ABCADAB</span><br><span class="line">输入字符串s2：</span><br><span class="line">BACDBA</span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1和s2的最长公共子序列长度是：<span class="number">4</span></span><br><span class="line">s1和s2的最长公共子序列是：BADB</span><br></pre></td></tr></table></figure>
<h3 id="4-3-6-算法解析及优化拓展">4.3.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由于每个数组单元的计算耗费Ο(1)时间，如果两个字符串的长度分别是m、n，那么算法时间复杂度为Ο(m*n)。</p>
<p>（2）空间复杂度：空间复杂度主要为两个二维数组<strong>c</strong>[][]，<strong>b</strong>[][]，占用的空间为O(m*n)。</p>
<h4 id="2．算法优化拓展">2．算法优化拓展</h4>
<p>因为<strong>c</strong>[i][j]有3种来源：<strong>c</strong>[i−1][j−1]+1、<strong>c</strong>[i][j−1]、<strong>c</strong>[i−1][j]。我们可以利用<strong>c</strong>数组本身来判断来源于哪个值，从而不用<strong>b</strong>[][]，这样可以节省O(m<em>n)个空间。但因为<strong>c</strong>数组还是O(m</em>n)个空间，所有空间复杂度数量级仍然是O(m*n)，只是从常数因子上的改进。仍然是倒推的办法，如图4-17所示，读者可以想一想怎么做？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/297.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-17　最长公共子序列构造最优解（不用辅助数组）</b></center>
<h3 id="4-4-DNA基因鉴定——编辑距离">4.4　DNA基因鉴定——编辑距离</h3>
<p>我们经常会听说DNA亲子鉴定是怎么回事呢？人类的DNA由4个基本字母{A，C，G，T}构成，包含了多达30亿个字符。如果两个人的DNA序列相差0.1%，仍然意味着有300万个位置不同，所以我们通常看到的DNA亲子鉴定报告上结论有：相似度99.99%，不排除亲子关系。</p>
<p>怎么判断两个基因的相似度呢？生物学上给出了一种编辑距离的概念。</p>
<p>例如两个字符串FAMILY和FRAME，有两种对齐方式：</p>
<p>F　 -　 A　M　I　L　Y　　　　　　 -　 F　 A　M　I　L　Y</p>
<p>F　 R　A　M　E　　　　　　　　　 F　 R　 A　M　E</p>
<p>第1种对齐需要付出的代价：4，插入R，将I替换为E，删除L、Y。</p>
<p>第2种对齐需要付出的代价：5，插入R，将F替换为R，将I替换为E，删除L、Y。</p>
<p>编辑距离是指将一个字符串变换为另一个字符串所需要的最小编辑操作。</p>
<p>怎么找到两个字符串x[1，…，m]和y[1，…，n]的编辑距离呢？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/298.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-18　DNA基因鉴定</b></center>
<h3 id="4-4-1-问题分析">4.4.1　问题分析</h3>
<p>编辑距离是指将一个字符串变换为另一个字符串所需要的最小编辑操作。</p>
<p>给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的编辑距离。</p>
<p>例如：X=（A，B，C，D，A，B），Y=（B，D，C，A，B）。如果用穷举法，会有很多种对齐方式，暴力穷举的方法是不可取的。那么怎么找到编辑距离呢？</p>
<p>首先考虑能不能把原问题变成规模更小的子问题，如果可以，那就会容易得多。</p>
<p>要求两个字符串X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}的编辑距离，那么可以求其前缀X<sub class="my_markdown">i</sub>={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和Y<sub class="my_markdown">j</sub>={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离，当i=m，j=n时就得到了所有字符的编辑距离。</p>
<p>那么能不能用动态规划算法呢？</p>
<p>下面我们分析该问题是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<p>假设已经知道<strong>d</strong>[i][j]是X<sub class="my_markdown">i</sub>={x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和Y<sub class="my_markdown">j</sub>={y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离最优解。这个假设很重要，我们都是这样假设已经知道了最优解。</p>
<p>那么两个序列无论怎么对齐，其右侧只可能有如下3种对齐方式：</p>
<ul>
<li>如图4-19所示。需要删除x<sub class="my_markdown">i</sub>，付出代价1，那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub><sub>−1</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离再加1即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1。<strong>d</strong>[i−1][j]是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最优解。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/299.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-19　编辑距离对齐方式</b></center>
<p><strong>反证法证明：</strong> 设<strong>d</strong>[i−1][j]不是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最优解，那么它们一定存在一个最优解<strong>d’</strong>，<strong>d’</strong>&lt;<strong>d</strong>[i−1][j]。如果在X<sub class="my_markdown">i</sub><sub>−1</sub>的后面添加一个字符x<sub class="my_markdown">i</sub>，<strong>d’</strong>+1也是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解，因为<strong>d’</strong>+1&lt;<strong>d</strong>[i−1][j]+1=<strong>d</strong>[i][j]，所以<strong>d</strong>[i][j]不是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解，这与假设<strong>d</strong>[i][j]是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解矛盾，问题得证。</p>
<ul>
<li>如图4-20所示。需要插入y<sub class="my_markdown">j</sub>，付出代价1，那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub><sub>−1</sub>}的编辑距离再加1即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1。<strong>d</strong>[i][j−1]是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最优解。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/300.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-20　编辑距离对齐方式</b></center>
<p>同理可证。</p>
<ul>
<li>如图4-21所示。如果x<sub class="my_markdown">i</sub>=y<sub class="my_markdown">j</sub>，付出代价0，如果x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>，需要替换，付出代价1，我们用函数<strong>diff</strong>(i，j)来表达，x<sub class="my_markdown">i</sub>=y<sub class="my_markdown">j</sub>时，<strong>diff</strong>(i，j)=0；x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>时，<strong>diff</strong>(i，j)=1。那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub><sub>−1</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub><sub>−1</sub>}的编辑距离再加<strong>diff</strong>(i，j)即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+ <strong>diff</strong>(i，j)。<strong>d</strong>[i−1][j−1]是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最优解。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/301.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-21　编辑距离对齐方式</b></center>
<p>同理可证。</p>
<p>（2）建立最优值递归式</p>
<p>设<strong>d</strong>[i][j]表示X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的编辑距离，则<strong>d</strong>[i][j]取以上三者对齐方式的最小值。</p>
<p>编辑距离递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>
（3)自底向上计算最优值，并记录最优值和最优策略</p>
<p>i=1时：{x<sub class="my_markdown">1</sub>}和{y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p>
<p>i=2时：{x<sub class="my_markdown">2</sub>}和{y<sub>1</sub>，y<sub class="my_markdown">2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p>
<p>……</p>
<p>i=m时：{x<sub class="my_markdown">m</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p>
<p>（4）构造最优解</p>
<p>如果仅仅需要知道编辑距离是多少，上面的求解过程得到的编辑距离就是最优值。如果还想知道插入、删除、替换了哪些字母，就需要从<strong>d</strong>[i][j]表格中倒推，输出这些结果。</p>
<h3 id="4-4-2-算法设计">4.4.2　算法设计</h3>
<p>编辑距离问题满足动态规划的最优子结构性质，可以自底向上逐渐推出整体最优解。</p>
<p>（1）确定合适的数据结构</p>
<p>采用二维数组<strong>d</strong>[][]来记录编辑距离。</p>
<p>（2）初始化</p>
<p>输入两个字符串s<sub class="my_markdown">1</sub>、s<sub>2</sub>，初始化<strong>d</strong>[][]第一行为0，1，2，…，len2，第一列元素为0，1，2，…，len1。</p>
<p>（3）循环阶段</p>
<ul>
<li>i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li>
</ul>
<p>如果s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[j−1]，<strong>diff</strong>[i][j] = 0。</p>
<p>如果s<sub class="my_markdown">1</sub>[0] ≠s<sub>2</sub>[j−1]，则<strong>diff</strong>[i][j] =1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/302.gif" alt="code"></p>
<ul>
<li>i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li>
<li>以此类推，直到i &gt;len1时，算法结束，这时<strong>d</strong>[len1][len2]就是我们要的最优解。</li>
</ul>
<p>（4）构造最优解</p>
<p>从<strong>d</strong>[i][j]表格中倒推，输出插入、删除、替换了哪些字母。在此没有使用辅助数组，采用判断的方式倒推。</p>
<h3 id="4-4-3-完美图解">4.4.3　完美图解</h3>
<p>以字符串s<sub class="my_markdown">1</sub>=” FAMILY”，s<sub>2</sub>=” FRAME”为例。</p>
<p>（1）初始化</p>
<p>len1=6，len2=5，初始化<strong>d</strong>[][]第一行为0，1，2，…，5，第一列元素为0，1，2，…，6，如图4-22所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/303.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-22　编辑距离求解初始化</b></center>
<p>（2）i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“F”与“FRAME”分别比较一次。</p>
<p>如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j] = 1。按照递归公式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>
即取上面+1，左侧+1，左上角数值加<strong>diff</strong>[i][j]3个数当中的最小值，相等时取后者。</p>
<ul>
<li>j=1：F=F，<strong>diff</strong>[1][1]=0，左上角数值加<strong>diff</strong>[1][1]=0，左侧+1=上面+1=2，3个数当中的最小值，<strong>d</strong>[1][1] =0，如图4-23所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/304.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-23　编辑距离求解过程</b></center>
<ul>
<li>j=2：F≠R，<strong>diff</strong>[1][2]=1，左上角数值加<strong>diff</strong>[1][2]=2，左侧+1=1，上面+1=3，取3个数当中的最小值，<strong>d</strong>[1][2] =1，如图4-24所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/305.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-24　编辑距离求解过程</b></center>
<ul>
<li>j=3：F≠A，<strong>diff</strong>[1][3]=1，左上角数值加<strong>diff</strong>[1][3]=3，左侧+1=2，上面+1=4，取3个数当中的最小值，<strong>d</strong>[1][3] =2，如图4-25所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/306.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-25　编辑距离求解过程</b></center>
<ul>
<li>j=4：F≠M：<strong>diff</strong>[1][4]=1，左上角数值加<strong>diff</strong>[1][4]=4，左侧+1=3，上面+1=5，取3个数当中的最小值，<strong>d</strong>[1][4] =3，如图4-26所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/307.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-26　编辑距离求解过程</b></center>
<ul>
<li>j=5：F≠E，<strong>diff</strong>[1][5]=1，左上角数值加<strong>diff</strong>[1][5]=5，左侧+1=4，上面+1=6，取3个数当中的最小值，<strong>d</strong>[1][5] =4，如图4-27所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/308.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-27　编辑距离求解过程</b></center>
<p>（3）i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“A”与“FRAME”分别比较一次。</p>
<p>如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j] = 1。按照递归公式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>
即取上面+1，左侧+1，左上角数值加<strong>diff</strong>[i][j]3个数当中的最小值，相等时取后者。</p>
<p>填写完毕，如图4-28所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/309.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-28　编辑距离求解过程</b></center>
<p>（4）继续处理i=2，3，…，len1：s<sub class="my_markdown">1</sub>[i−1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2，处理结果如图4-29所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/310.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-29　编辑距离求解结果</b></center>
<p>（5）构造最优解</p>
<p>从右下角开始，逆向查找<strong>d</strong>[i][j]的来源： <strong>上面</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1）表示需要删除， <strong>左侧</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1）表示需要插入， <strong>左上角</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+<strong>diff</strong>[i][j]）要判断是否字符相等，如果不相等则需要替换，如果字符相等什么也不做，如图4-30所示。为什么是这样呢？不清楚的读者可以回看4.4.1节。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/311.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-30　编辑距离最优解构造过程</b></center>
<ul>
<li>首先读取右下角<strong>d</strong>[6][5]=4，s<sub class="my_markdown">1</sub>[5]≠s<sub>2</sub>[4]，<strong>d</strong>[6][5]来源于3个数当中的最小值：上面+1=4，左侧+1=5，左上角数值+<strong>diff</strong>[i][j]=4，相等时取后者。来源于左上角，需要替换操作。返回时输出s<sub class="my_markdown">1</sub>[5]替换为s<sub>2</sub>[4]，即“Y” <strong>替换</strong> 为“E”。</li>
<li>向左上角找<strong>d</strong>[5][4]=3，s<sub class="my_markdown">1</sub>[4]≠s<sub>2</sub>[3]。<strong>d</strong>[5][4]来源于3个数当中的最小值：上面+1=3，左侧+1=5，左上角数值+<strong>diff</strong>[i][j]=4。来源于上面，需要删除操作。返回时输出删除s<sub class="my_markdown">1</sub>[4]，即 <strong>删除</strong> “L”。</li>
<li>向上面找<strong>d</strong>[4][4]=2，s<sub class="my_markdown">1</sub>[3]≠s<sub>2</sub>[3]。<strong>d</strong>[4][4]来源于3个数当中的最小值：上面+1=2，左侧+1=4，左上角数值+<strong>diff</strong>[i][j]=3。来源于上面，需要删除操作。返回时输出删除s<sub class="my_markdown">1</sub>[3]，即 <strong>删除</strong> “I”。</li>
<li>向上面找<strong>d</strong>[3][4]=1，s<sub class="my_markdown">1</sub>[2]=s<sub>2</sub>[3]，不需操作。<strong>d</strong>[3][4]来源于上面+1=3，左侧+1=3，左上角数值+<strong>diff</strong>[i][j]=13个数当中的最小值。来源于左上角，因为字符相等什么也不做。返回时不输出。</li>
<li>向左上角找<strong>d</strong>[2][3]=1，s<sub class="my_markdown">1</sub>[1]=s<sub>2</sub>[2]，不需操作。<strong>d</strong>[2][3]来源于3个数当中的最小值：上面+1=3，左侧+1=2，左上角数值+<strong>diff</strong>[i][j]=1。来源于左上角，因为字符相等什么也不做。返回时不输出。</li>
<li>向左上角找<strong>d</strong>[1][2]=1，s<sub class="my_markdown">1</sub>[0]≠s<sub>2</sub>[1]。<strong>d</strong>[1][2]来源于3个数当中的最小值：上面+1=3，左侧+1=1，左上角数值+<strong>diff</strong>[i][j]=2。来源于左则，需要插入操作。返回时输出在第1个字符之后插入s<sub>2</sub>[1]，即 <strong>插入</strong> “R”。</li>
<li>向左则找<strong>d</strong>[1][1]=0，s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[0]。<strong>d</strong>[1][1]来源于3个数当中的最小值：上面+1=2，左侧+1=2，左上角数值+<strong>diff</strong>[i][j]=0。来源于左上角，因为字符相等什么也不做。返回时不输出。</li>
<li>行或列为0时，算法停止。</li>
</ul>
<h3 id="4-4-4-伪代码详解">4.4.4　伪代码详解</h3>
<p>编辑距离求解函数：首先计算两个字符串的长度，然后从i=1开始，比较s<sub class="my_markdown">1</sub>[0]和s<sub>2</sub>[]中的每一个字符，如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j]=1。因为这个值不需要记录，仅在公式表达时用数组表示，在程序设计时只用一个变量<strong>diff</strong>就可以了。</p>
<p>取上面+1（即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1），左侧+1（即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1），左上角数值+<strong>diff</strong>[i][j] （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+ <strong>diff</strong>[i][j]）三者当中的最小值，相等时取后者。</p>
<p>直到i&gt;len1时，算法结束，这时<strong>d</strong>[len1][len2]就是我们要的编辑距离。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">editdistance</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> len1 = <span class="built_in">strlen</span>(str1);      <span class="comment">//计算字符串长度</span></span><br><span class="line">     <span class="type">int</span> len2 = <span class="built_in">strlen</span>(str2); </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)      <span class="comment">//当第二个串长度为0，编辑距离初始化为i</span></span><br><span class="line">          d[i][<span class="number">0</span>]= i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=len2;j++)      <span class="comment">//当第一个串长度为0，编辑距离初始化为j</span></span><br><span class="line">          d[<span class="number">0</span>][j]=j;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt;=len1;i++)     <span class="comment">//遍历两个字符串</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> diff;<span class="comment">//判断str[i]是否等于str2[j],相等为0，不相等为1</span></span><br><span class="line">               <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]) <span class="comment">//相等</span></span><br><span class="line">                     diff = <span class="number">0</span> ;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                     diff = <span class="number">1</span> ;</span><br><span class="line">               <span class="type">int</span> temp = min(d[i<span class="number">-1</span>][j] + <span class="number">1</span>, d[i][j<span class="number">-1</span>] + <span class="number">1</span>);<span class="comment">//先两者取最小值</span></span><br><span class="line">               d[i][j] = min(temp, d[i<span class="number">-1</span>][j<span class="number">-1</span>] + diff);<span class="comment">//再取最小值，</span></span><br><span class="line">                     <span class="comment">//相当于三者取最小值d[i-1][j] + 1, d[i][j-1] + 1，d[i-1][j-1] + diff</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> d[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-4-5-实战演练">4.4.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> str1[N],str2[N];</span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">//d[i][j]表示str1前i个字符和str2前j个字符的编辑距离。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a&lt;b?a:b;<span class="comment">//返回较小的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">editdistance</span> <span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> len1 = <span class="built_in">strlen</span>(str1); <span class="comment">//计算字符串长度</span></span><br><span class="line">     <span class="type">int</span> len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)<span class="comment">//当第二个串长度为0，编辑距离初始化为i</span></span><br><span class="line">          d[i][<span class="number">0</span>]= i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=len2;j++)<span class="comment">//当第一个串长度为0，编辑距离初始化为j</span></span><br><span class="line">          d[<span class="number">0</span>][j]=j;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt;=len1;i++)<span class="comment">//遍历两个字符串</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> diff;<span class="comment">//判断str[i]是否等于str2[j],相等为0，不相等为1  </span></span><br><span class="line">               <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])<span class="comment">//相等</span></span><br><span class="line">                     diff = <span class="number">0</span> ;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                     diff = <span class="number">1</span> ;</span><br><span class="line">               <span class="type">int</span> temp = min(d[i<span class="number">-1</span>][j] + <span class="number">1</span>, d[i][j<span class="number">-1</span>] + <span class="number">1</span>);<span class="comment">//先两者取最小值</span></span><br><span class="line">               d[i][j] = min(temp, d[i<span class="number">-1</span>][j<span class="number">-1</span>] + diff);<span class="comment">//再取最小值，</span></span><br><span class="line">                     <span class="comment">//相当于三者取最小值d[i-1][j] + 1, d[i][j-1] + 1，d[i-1][j-1] + diff</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> d[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串str1：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串str2：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; str1&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;的编辑距离是：&quot;</span>&lt;&lt;editdistance (str1,str2);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入字符串str1：</span><br><span class="line">family</span><br><span class="line">输入字符串str2：</span><br><span class="line">frame</span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family和frame的编辑距离是：<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="4-4-6-算法解析及优化拓展">4.4.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4>
<p>（1）时间复杂度：算法有两个for循环，一个双重for循环。如果两个字符串的长度分别是m、n，前两个for循环时间复杂度为O(n)和O(m)，双重for循环时间复杂度为O(n<em>m)，所以总的时间复杂度为O(n</em>m)。</p>
<p>（2）空间复杂度：使用了<strong>d</strong>[][]数组，空间复杂度为O(n*m)。</p>
<h4 id="2．算法优化拓展-2">2．算法优化拓展</h4>
<p>大家可以动手实现构造最优解部分，可以直接倒推，也可以在程序开始使用辅助数组记录来源，然后倒推。</p>
<p>想一想还有没有更好的算法求解呢？</p>
<h3 id="4-5-长江一日游——游艇租赁">4.5　长江一日游——游艇租赁</h3>
<p>长江游艇俱乐部在长江上设置了n个游艇出租站，游客可以在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j），1≤i&lt;j≤n。试设计一个算法，计算从游艇出租站i到出租站j所需的最少租金。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/312.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-31　游艇租赁</b></center>
<h3 id="4-5-1-问题分析">4.5.1　问题分析</h3>
<p>长江游艇俱乐部在长江上设置了n个游艇出租站，游客可以在这些出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j）。现在要求出从游艇出租站1到游艇出租站n所需的最少的租金。</p>
<p>当要租用游艇从一个站到另外一个站时，中间可能经过很多站点，不同的停靠站策略就有不同的租金。那么我们可以考虑该问题，从第1站到第n站的最优解是否一定包含前n−1的最优解，即是否具有最优子结构和重叠性。如果是，就可以利用动态规划进行求解。</p>
<p>如果我们穷举所有的停靠策略，例如一共有10个站点，当求子问题4个站点的停靠策略时，子问题有（1，2，3，4），（2，3，4，5），（3，4，5，6），（4，5，6，7），（5，6，7，8），（6，7，8，9），（7，8，9，10）。如果再求其子问题3个站点的停靠策略，（1，2，3，4）产生两个子问题：（1，2，3），（2，3，4）。（2，3，4，5）产生两个子问题：（2，3，4），（3，4，5）。如果再继续求解子问题，会发现有大量的子问题重叠，其算法时间复杂度为2<sup class="my_markdown">n</sup>，暴力穷举的办法是很不可取的。</p>
<p>下面分析第i个站点到第j个站点（i，i+1，…，j）的最优解（最少租金）问题，考查是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>假设我们已经知道了在第k个站点停靠会得到最优解，那么原问题就变成了两个子问题：（i，i+1，…，k）、（k，k+1，…，j）。如图4-32所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/313.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-32　分解为两个子问题</b></center>
<ul>
<li>那么原问题的最优解是否包含子问题的最优解呢？</li>
</ul>
<p>假设第i个站点到第j个站点（i，i+1，…，j）的最优解是c，子问题（i，i+1，…，k）的最优解是a，子问题（k，k+1，…，j）的最优解是b，那么c=a+b，无论两个子问题的停靠策略如何都不影响它们的结果，因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</p>
<p><strong>反证法</strong> ：如果a不是最优的，子问题（i，i+1，…，k）存在一个最优解a’，a’&lt;a，那么a’+b &lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p>
<p>因此，该问题具有最优子结构性质。</p>
<p>（2）建立最优值的递归式</p>
<ul>
<li>用<strong>m</strong>[i][j]表示第i个站点到第j个站点（i，i+1，…，j）的最优值（最少租金），那么两个子问题：（i，i+1，…，k）、（k，k+1，…，j）对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k][j]。</li>
<li>游艇租金最优值递归式：</li>
</ul>
<p>当j=i时，只有1个站点，<strong>m</strong>[i][j]=0。</p>
<p>当j=i+1时，只有2个站点，<strong>m</strong>[i][j]= <strong>r</strong>[i][j]。</p>
<p>当j&gt;i+1时，有3个以上站点，<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/314.gif" style="width:319px;  height: 29px; "/>。</p>
<p>整理如下。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/315.gif" alt="code"><br>
（3)自底向上计算最优值，并记录</p>
<p>先求两个站点之间的最优值，再求3个站点之间的最优值，直到n个站点之间的最优值。</p>
<p>（4）构造最优解</p>
<p>上面得到的最优值只是第1个站点到第n个站点之间的最少租金，并不知道停靠了哪些站点，我们需要从记录表中还原，逆向构造出最优解。</p>
<h3 id="4-5-2-算法设计">4.5.2　算法设计</h3>
<p>采用自底向上的方法求最优值，分为不同规模的子问题，对于每一个小的子问题都求最优值，记录最优策略，具体策略如下。</p>
<p>（1）确定合适的数据结构</p>
<p>采用二维数组<strong>r</strong>[][]输入数据，二维数组<strong>m</strong>[][]存放各个子问题的最优值，二维数组<strong>s</strong>[][]存放各个子问题的最优决策（停靠站点）。</p>
<p>（2）初始化</p>
<p>根据递推公式，可以把<strong>m</strong>[i][j]初始化为<strong>r</strong>[i][j]，然后再找有没有比<strong>m</strong>[i][j]小的值，如果有，则记录该最优值和最优解即可。初始化为：<strong>m</strong>[i][j]=<strong>r</strong>[i][j]，<strong>s</strong>[i][j]=0，其中，i=1，2，…，n，j=i+1，i+2，…，n。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归关系式计算3个站点i，i+1，j（j=i+2）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，…，n−2。</li>
<li>按照递归关系式计算4个站点i，i+1，i+2，j（j=i+3）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，…，n−3。</li>
<li>以此类推，直到求出n个站点的最优值<strong>m</strong>[1][n]。</li>
</ul>
<p>（4）构造最优解</p>
<p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解。<strong>s</strong>[1][n]是第1个站点到第n个站点（1，2，…，n）的最优解的停靠站点，即停靠了第<strong>s</strong>[1][n]个站点，我们在递归构造两个子问题（1，2，…，k）和（k，k +1，…，n）的最优解停靠站点，一直递归到子问题只包含一个站点为止。</p>
<h3 id="4-5-3-完美图解">4.5.3　完美图解</h3>
<p>长江游艇俱乐部在长江上设置了6个游艇出租站，如图4-33所示。游客可以在这些出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j），如图4-34所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/316.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-33　游艇租赁地图</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/317.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-34　各站点之间的游艇租金</b></center>
<p>（1）初始化</p>
<p>节点数n=6，<strong>m</strong>[i][j]=<strong>r</strong>[i][j]，<strong>s</strong>[i][j]=0，其中，i=1，2，…，n，j=i+1，i+2，…，n。如图4-35所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/318.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-35　游艇租赁问题初始化</b></center>
<p>（2）计算3个站点i，i+1，j（j=i+2）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，4。</p>
<ul>
<li>i = 1，j=3：<strong>m</strong>[1][2]+ <strong>m</strong>[2][3]=5 &lt; <strong>m</strong>[1][3]=6，更新<strong>m</strong>[1][3]=5，<strong>s</strong>[1][3]=2。</li>
<li>i = 2，j=4：<strong>m</strong>[2][3]+ <strong>m</strong>[3][4]=6 &gt; <strong>m</strong>[2][4]=5，不做改变。</li>
<li>i = 3，j=5：<strong>m</strong>[3][4]+ <strong>m</strong>[4][5] =7&gt; <strong>m</strong>[3][5]=6，不做改变。</li>
<li>i = 4，j=6：<strong>m</strong>[4][5]+ <strong>m</strong>[5][6]=9 &gt; <strong>m</strong>[4][6]=8，不做改变。</li>
</ul>
<p>如图4-36所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/319.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-36　游艇租赁问题求解过程</b></center>
<p>（3）计算4个站点i，i+1，i+2，j（j=i+3）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3。</p>
<ul>
<li>i = 1，j=4：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/320.gif" style="width:273px;  height: 45px; "/>；原值<strong>m</strong>[1][4]=9，更新<strong>m</strong>[1][4]=7，<strong>s</strong>[1][4]=2。</p>
<ul>
<li>i =2，j=5：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/321.gif" style="width:282px;  height: 45px; "/>；原值<strong>m</strong>[2][5]=11，更新<strong>m</strong>[2][5]=9，<strong>s</strong>[2][5]=3。</p>
<ul>
<li>i =3，j=6：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/322.gif" style="width:282px;  height: 45px; "/>；原值<strong>m</strong>[3][6]=12，更新<strong>m</strong>[3][6]=11，<strong>s</strong>[3][6]=4。</p>
<p>如图4-37所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/323.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-37　游艇租赁问题求解过程</b></center>
<p>（4）计算5个站点i，i+1，i+2，i+3，j（j=i+4）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1、2。</p>
<ul>
<li>i = 1，j=5：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/324.gif" style="width:284px;  height: 67px; "/>；原值<strong>m</strong>[1][5]=15，更新<strong>m</strong>[1][5]=11，<strong>s</strong>[1][5]=2。</p>
<ul>
<li>i = 2，j=6：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/325.gif" style="width:284px;  height: 67px; "/>；原值<strong>m</strong>[2][6]=18，更新<strong>m</strong>[1][5]=13，<strong>s</strong>[2][6]=4。</p>
<p>如图4-38所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/326.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-38　游艇租赁问题求解过程</b></center>
<p>（5）计算6个站点i，i+1，i+2，i+3，i+4，j（j=i+4）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1。</p>
<ul>
<li>i = 1，j=6：</li>
</ul>
<p><img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/327.gif" style="width:284px;  height: 89px; "/>；原值<strong>m</strong>[1][6]=20，更新<strong>m</strong>[1][6]=15，<strong>s</strong>[1][6]=2。</p>
<p>如图4-39所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/328.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-39　游艇租赁问题求解过程</b></center>
<p>（6）构造最优解</p>
<p>根据存储表格<strong>s</strong>[][]中的数据来构造最优解，即停靠的站点。</p>
<p>首先输出出发站点1；读取<strong>s</strong>[1][6]=2，表示在2号站点停靠，即分解为两个子问题：（1，2）和（2，3，4，5，6）。</p>
<p>先看第一个子问题（1，2）：读取<strong>s</strong>[1][2]=0，表示没有停靠任何站点，直接到达2，输出2。</p>
<p>再看第二个子问题（2，3，4，5，6）：读取<strong>s</strong>[2][6]=4，表示在4号站点停靠，即分解为两个子问题：（2，3，4）和（4，5，6）。</p>
<p>先看子问题（2，3，4）：读取<strong>s</strong>[2][4]=0，表示没有停靠任何站点，直接到达4，输出4。</p>
<p>再看子问题（4，5，6）：读取<strong>s</strong>[4][6]=0，表示没有停靠任何站点，直接到达6，输出6。</p>
<p>最终答案是：1——2——4——6。</p>
<h3 id="4-5-4-伪代码详解">4.5.4　伪代码详解</h3>
<p>（1）最少租金求解函数</p>
<p>设计中n表示有n个出租站，设置二维数组<strong>m</strong>[][]，初始化时用来记录从i到j之间的租金<strong>r</strong>[][]，在不同规模的子问题（d=3，4，…，n）中，按照递推公式计算，如果比原值<strong>m</strong>[][]小，则更新<strong>m</strong>[][]，同时用<strong>s</strong>[][]记录停靠的站点号，直接最后得到的<strong>r</strong>[1][n]即为最后的结果。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,k,d;</span><br><span class="line">     <span class="keyword">for</span>(d=<span class="number">3</span>;d&lt;=n;d++) <span class="comment">//将问题分为小规模d</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-d+<span class="number">1</span>;i++)</span><br><span class="line">               &#123;</span><br><span class="line">                    j=i+d<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;j;k++)  <span class="comment">//记录每一个小规模内的最优解</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="type">int</span> temp;</span><br><span class="line">                         temp=m[i][k]+m[k][j];</span><br><span class="line">                         <span class="keyword">if</span>(temp&lt;m[i][j])</span><br><span class="line">                               &#123;</span><br><span class="line">                                 m[i][j]=temp;</span><br><span class="line">                                 s[i][j]=k;</span><br><span class="line">                               &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）最优解构造函数</p>
<p>根据<strong>s</strong>[][]数组构造最优解，<strong>s</strong>[i][j]将问题分解为两个子问题（i，…，<strong>s</strong>[i][j]）、（<strong>s</strong>[i][j]，…，j），递归求解这两个子问题。当<strong>s</strong>[i][j]=0时，说明中间没有经过任何站点，直达站点j，输入j，返回即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]==<span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&quot;</span>&lt;&lt;j;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j],j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-5-实战演练">4.5.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ms = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> r[ms][ms],m[ms][ms],s[ms][ms];    <span class="comment">//i到j站的租金</span></span><br><span class="line"><span class="type">int</span> n;            <span class="comment">//共有n个站点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,k,d;</span><br><span class="line">     <span class="keyword">for</span>(d=<span class="number">3</span>;d&lt;=n;d++) <span class="comment">//将问题分为小规模为d</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-d+<span class="number">1</span>;i++)</span><br><span class="line">              &#123;</span><br><span class="line">                   j=i+d<span class="number">-1</span>;</span><br><span class="line">                   <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;j;k++)  <span class="comment">//记录每一个小规模内的最优解</span></span><br><span class="line">                   &#123;</span><br><span class="line">                        <span class="type">int</span> temp;</span><br><span class="line">                        temp=m[i][k]+m[k][j];</span><br><span class="line">                        <span class="keyword">if</span>(temp&lt;m[i][j])</span><br><span class="line">                             &#123;</span><br><span class="line">                                m[i][j]=temp;</span><br><span class="line">                                s[i][j]=k;</span><br><span class="line">                             &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]==<span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&quot;</span>&lt;&lt;j;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j],j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入站点的个数 n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各站点之间的租金：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">cin</span>&gt;&gt;r[i][j];</span><br><span class="line">              m[i][j]=r[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">     rent();</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;花费的最少租金为：&quot;</span> &lt;&lt;m[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;最少租金经过的站点：&quot;</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">     print(<span class="number">1</span>,n);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现和测试</p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>Visual C++ 6.0</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入站点的个数n：<span class="number">6</span></span><br><span class="line">请依次输入各站点之间的租金：<span class="number">2</span> <span class="number">6</span> <span class="number">9</span> <span class="number">15</span> <span class="number">20</span> <span class="number">3</span> <span class="number">5</span> <span class="number">11</span> <span class="number">18</span> <span class="number">3</span> <span class="number">6</span> <span class="number">12</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">花费的最少租金为：<span class="number">15</span></span><br><span class="line">最少租金经过的站点：<span class="number">1</span>-<span class="number">-2</span>-<span class="number">-4</span>-<span class="number">-6</span></span><br></pre></td></tr></table></figure>
<h3 id="4-5-6-算法解析及优化拓展">4.5.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由程序可以得出：语句temp=<strong>m</strong>[i][k]+<strong>m</strong>[k][j]，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，最坏情况下时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p>
<p>（2）空间复杂度：该程序的输入数据的数组为<strong>r</strong>[][]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，该程序的空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h4 id="2．算法优化拓展-3">2．算法优化拓展</h4>
<p>如果只是想得到最优值（最少的租金），则不需要<strong>s</strong>[][]数组；<strong>m</strong>[][]数组也可以省略，直接在<strong>r</strong>[][]数组上更新即可，这样空间复杂度减少为O(1)。</p>
<h3 id="4-6-快速计算——矩阵连乘">4.6　快速计算——矩阵连乘</h3>
<p>给定n个矩阵{<strong>A</strong><sub class="my_markdown">1</sub>，<strong>A</strong> <sub class="my_markdown">2</sub>，<strong>A</strong><sub>3</sub>，…，<strong>A</strong> <sub class="my_markdown">n</sub>}，其中，<strong>A</strong> <sub class="my_markdown">i</sub> 和<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>（i=1，2，…，n−1）是可乘的。矩阵乘法如图4-40所示。用加括号的方法表示矩阵连乘的次序，不同的计算次序计算量（乘法次数）是不同的，找出一种加括号的方法，使得矩阵连乘的计算量最小。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/329.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-40　矩阵乘法</b></center>
<p>例如：</p>
<p><strong>A</strong><sub class="my_markdown">1</sub>是<strong>M</strong><sub>5×10</sub>的矩阵；</p>
<p><strong>A</strong><sub class="my_markdown">2</sub>是<strong>M</strong><sub>10×100</sub>的矩阵；</p>
<p><strong>A</strong><sub class="my_markdown">3</sub>是<strong>M</strong><sub>100×2</sub>的矩阵。</p>
<p>那么有两种加括号的方法：</p>
<p>（1）（<strong>A</strong><sub class="my_markdown">1</sub> <strong>A</strong><sub>2</sub>）<strong>A</strong><sub>3</sub>；</p>
<p>（2）<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub> <strong>A</strong><sub>3</sub>）。</p>
<p>第1种加括号方法运算量：5×10×100+5×100×2=6000。</p>
<p>第2种加括号方法运算量：10×100×2+5×10×2=2100。</p>
<p>可以看出，不同的加括号办法，矩阵乘法的运算次数可能有巨大的差别！</p>
<h3 id="4-6-1-问题分析">4.6.1　问题分析</h3>
<p>矩阵连乘问题就是对于给定n个连乘的矩阵，找出一种加括号的方法，使得矩阵连乘的计算量（乘法次数）最小。</p>
<p>看到这个问题，我们需要了解以下内容。</p>
<p>（1）什么是矩阵可乘？</p>
<p>如果两个矩阵， <strong>第1个矩阵的列等于第2个矩阵的行时，那么这两个矩阵是可乘的。</strong> 如图4-41所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/330.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-41　两个矩阵相乘</b></center>
<p>（2）矩阵相乘后的结果是什么？</p>
<p>从图4-41可以看出，两个矩阵相乘的结果矩阵，其行、列分别等于第1个矩阵的行、第2个矩阵的列。如果有很多矩阵相乘呢？如图4-42所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/331.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-42　多个矩阵相乘</b></center>
<p><strong>多个矩阵相乘的结果矩阵，其行、列分别等于第1个矩阵的行、最后1个矩阵的列。</strong> 而且无论矩阵的计算次序如何都不影响它们的结果矩阵。</p>
<p>（3）两个矩阵相乘需要多少次乘法？</p>
<p>例如两个矩阵<strong>A</strong><sub class="my_markdown">3×2</sub>、<strong>B</strong><sub>2×4</sub>相乘，结果为<strong>C</strong><sub>3×4</sub>要怎么计算呢？</p>
<p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第1列第1个数：1×2；</p>
<p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第1列第2个数：2×3；</p>
<p><strong>两者相加存放在C矩阵第1行第1列：1</strong> × <strong>2+2</strong> × <strong>3。</strong></p>
<p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第2列第1个数：1×4；</p>
<p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第2列第2个数：2×6；</p>
<p><strong>两者相加存放在C矩阵第1行第2列：1</strong> × <strong>4+2</strong> × <strong>6。</strong></p>
<p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第3列第1个数：1×5；</p>
<p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第3列第2个数：2×9；</p>
<p><strong>两者相加存放在C矩阵第1行第3列：1</strong> × <strong>5+2</strong> × <strong>9。</strong></p>
<p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第4列第1个数：1×8；</p>
<p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第4列第2个数：2×10；</p>
<p><strong>两者相加存放在C矩阵第1行第4列：1</strong> × <strong>8+2</strong> × <strong>10。</strong></p>
<p>其他行以此类推。</p>
<p>计算结果如图4-43所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/332.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-43　矩阵相乘运算</b></center>
<p>可以看出，结果矩阵中每个数都执行了两次乘法运算，有3×4=12个数，一共需要执行2×3×4=24次，两个矩阵<strong>A</strong><sub class="my_markdown">3×2</sub>、<strong>A</strong><sub>2×4</sub>相乘执行乘法运算的次数为3×2×4。因此，<strong>A</strong> <sub class="my_markdown">m</sub><sub>×n</sub>、<strong>A</strong> <sub class="my_markdown">n</sub><sub>×k</sub>相乘执行乘法运算的次数为m<em>n</em>k <strong>。</strong></p>
<p>如果穷举所有的加括号方法，那么加括号的所有方案是一个卡特兰数序列，其算法时间复杂度为2<sup class="my_markdown">n</sup>，是指数阶。因此穷举的办法是很糟的，那么能不能用动态规划呢？</p>
<p>下面分析矩阵连乘问题<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>假设我们已经知道了在第k个位置加括号会得到最优解，那么原问题就变成了两个子问题：（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>），（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>），如图4-44所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/333.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-44　分解为两个子问题</b></center>
<p>原问题的最优解是否包含子问题的最优解呢？</p>
<ul>
<li>假设<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>的乘法次数是c，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）的乘法次数是a，（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的乘法次数是b，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数是d，那么c=a+b+d，无论两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的计算次序如何，都不影响它们结果矩阵，两个结果矩阵相乘的乘法次数d不变。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li>
</ul>
<p><strong>反证法：</strong> 如果a不是最优的，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）存在一个最优解a’，a’&lt;a，那么，a’+b+d&lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p>
<p>因此，矩阵连乘问题具有最优子结构性质。</p>
<p>（2）建立最优值递归式</p>
<ul>
<li>用<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优值，那么两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]。剩下的只需要考查（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数了。</li>
<li>设矩阵<strong>A</strong> <sub class="my_markdown">m</sub>的行数为p<sub class="my_markdown">m</sub>，列数为q<sub class="my_markdown">m</sub>，m=i，i+1, …，j，且矩阵是可乘的，即相邻矩阵前一个矩阵的列等于下一个矩阵的行（q<sub class="my_markdown">m</sub>= p<sub class="my_markdown">m</sub><sub>+1</sub>）。（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）的结果是一个p<sub class="my_markdown">i</sub>×q<sub class="my_markdown">k</sub>矩阵，（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果是一个p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>矩阵，q<sub class="my_markdown">k</sub>= p<sub class="my_markdown">k</sub><sub>+1</sub>，两个结果矩阵相乘的乘法次数是p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。如图4-45所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/334.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-45　结果矩阵乘法次数</b></center>
<ul>
<li>矩阵连乘最优值递归式：</li>
</ul>
<p>当i=j时，只有一个矩阵，<strong>m</strong>[i][j]=0；</p>
<p>当i&gt;j时，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/335.gif" alt="code"><br>
如果用一维数组p[]来记录矩阵的行和列，第i个矩阵的行数存储在数组的第i−1位置，列数存储在数组的第i位置，那么p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>对应的数组元素相乘为p[i−1]<em>p[k]</em> p[j]，原递归式变为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/336.gif" alt="code"><br>
（3)自底向上计算并记录最优值</p>
<p>先求两个矩阵相乘的最优值，再求3个矩阵相乘的最优值，直到n个矩阵连乘的最优值。</p>
<p>（4）构造最优解</p>
<p>上面得到的最优值只是矩阵连乘的最小的乘法次数，并不知道加括号的次序，需要从记录表中还原加括号次序，构造出最优解，例如<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub>）。</p>
<p>这个问题是一个动态规划求矩阵连乘最小计算量的问题，将问题分为小规模的问题，自底向上，将规模放大，直到得到所求规模的问题的解。</p>
<h3 id="4-6-2-算法设计">4.6.2　算法设计</h3>
<p>采用自底向上的方法求最优值，对于每一个小规模的子问题都求最优值，并记录最优策略（加括号位置），具体算法设计如下。</p>
<p>（1）确定合适的数据结构</p>
<p>采用一维数组p[]来记录矩阵的行和列，第i个矩阵的行数存储在数组的第i−1位置，列数存储在数组的第i位置。二维数组<strong>m</strong>[][]来存放各个子问题的最优值，二维数组<strong>s</strong>[][]来存放各个子问题的最优决策(加括号的位置)。</p>
<p>（2）初始化</p>
<p>采用一维数组p[]来记录矩阵的行和列，<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，…，n。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归关系式计算2个矩阵<strong>A</strong> <sub class="my_markdown">i</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>相乘时的最优值，j=i+1，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，…，n−1。</li>
<li>按照递归关系式计算3个矩阵相乘<strong>A</strong> <sub class="my_markdown">i</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+2</sub>相乘时的最优值，j=i+2，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，…，n−2。</li>
<li>以此类推，直到求出n个矩阵相乘的最优值<strong>m</strong>[1][n]。</li>
</ul>
<p>（4）构造最优解</p>
<p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解。<strong>s</strong>[1][n] 表示<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>最优解的加括号位置，即（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]</sub>）（<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]+1</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>），我们在递归构造两个子问题（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]</sub>）、（<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]+1</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>）的最优解加括号位置，一直递归到子问题只包含一个矩阵为止。</p>
<h3 id="4-6-3-完美图解">4.6.3　完美图解</h3>
<p>现在我们假设有5个矩阵，如表4-1所示。</p>
<center class="my_markdown"><b class="my_markdown">表4-1　矩阵的规模</b></center>
<p>| 矩阵 | A<sub class="my_markdown">1</sub> | A<sub class="my_markdown">2</sub> | A<sub class="my_markdown">3</sub> | A<sub class="my_markdown">4</sub> | A<sub class="my_markdown">5</sub> |<br>
| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>
| 规模 | 3×5 | 5×10 | 10×8 | 8×2 | 2×4 |</p>
<p>（1）初始化</p>
<p>采用一维数组p[]记录矩阵的行和列，实际上只需要记录每个矩阵的行，再加上最后一个矩阵的列即可，如图4-46所示。<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，4，5。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/337.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-46　记录行列的数组p[]</b></center>
<p>最优值数组<strong>m</strong>[i][i]=0，最优决策数组<strong>s</strong>[i][i]=0，其中i= 1，2，3，4，5。如图4-47所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/338.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-47　**m**[][]和**s**[][]初始化</b></center>
<p>（2）计算两个矩阵相乘的最优值</p>
<p>规模r=2。根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p>
<ul>
<li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>：k=1，<strong>m</strong>[1][2]=min{ <strong>m</strong>[1][1]+ <strong>m</strong>[2][2]+p<sub>0</sub>p<sub class="my_markdown">1</sub>p<sub>2</sub>}=150；<strong>s</strong>[1][2]=1。</li>
<li><strong>A</strong><sub>2</sub>*<strong>A</strong><sub class="my_markdown">3</sub>：k=2，<strong>m</strong>[2][3]=min{ <strong>m</strong>[2][2]+ <strong>m</strong>[3][3]+p<sub class="my_markdown">1</sub>p<sub>2</sub>p<sub class="my_markdown">3</sub>}=400；<strong>s</strong>[2][3]=2。</li>
<li><strong>A</strong><sub class="my_markdown">3</sub>*<strong>A</strong><sub>4</sub>：k=3，<strong>m</strong>[3][4]=min{ <strong>m</strong>[3][3]+ <strong>m</strong>[4][4]+p<sub>2</sub>p<sub class="my_markdown">3</sub>p<sub>4</sub>}=160；<strong>s</strong>[3][4]=3。</li>
<li><strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：k=4，<strong>m</strong>[4][5]=min{ <strong>m</strong>[4][4]+ <strong>m</strong>[5][5]+p<sub class="my_markdown">3</sub>p<sub>4</sub>p<sub>5</sub>}=64； <strong>s</strong>[4][5]=4。</li>
</ul>
<p>计算完毕，如图4-48所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/340.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-48　**m**[][]和**s**[][]计算过程</b></center>
<p>（3）计算3个矩阵相乘的最优值</p>
<p>规模r=3。根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p>
<ul>
<li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/341.gif" alt="code"><br>
<strong>s</strong>[1][3]=2。</p>
<ul>
<li><strong>A</strong><sub class="my_markdown">2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/342.gif" alt="code"><br>
<strong>s</strong>[2][4]=2。</p>
<ul>
<li><strong>A</strong><sub class="my_markdown">3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/343.gif" alt="code"><br>
<strong>s</strong>[3][5]=4。</p>
<p>计算完毕，如图4-49所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/344.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-49　**m**[][]和**s**[][]计算过程</b></center>
<p>（4）计算4个矩阵相乘的最优值</p>
<p>规模r=4。根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/345.gif" alt="code"></p>
<ul>
<li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/346.gif" alt="code"><br>
<strong>s</strong>[1][4]=1。</p>
<ul>
<li><strong>A</strong><sub class="my_markdown">2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/347.gif" alt="code"><br>
<strong>s</strong>[2][5]=4。</p>
<p>计算完毕，如图4-50所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/348.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-50　**m**[][]和**s**[][]计算过程</b></center>
<p>（5）计算5个矩阵相乘的最优值</p>
<p>规模r=5。根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p>
<ul>
<li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/349.gif" alt="code"><br>
<strong>s</strong>[1][5]=4。</p>
<p>计算完毕，如图4-51所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/350.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-51**m**[][]和**s**[][]计算过程</b></center>
<p>（6）构造最优解</p>
<p>根据最优决策数组<strong>s</strong>[][]中的数据来构造最优解，即加括号的位置。</p>
<p>首先读取<strong>s</strong>[1][5]=4，表示在k=4的位置把矩阵分为两个子问题：（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）、<strong>A</strong><sub>5</sub>。</p>
<p>再看第一个子问题（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>），读取<strong>s</strong>[1][4]=1，表示在k=1的位置把矩阵分为两个子问题：<strong>A</strong><sub class="my_markdown">1</sub>、（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）。</p>
<p>子问题<strong>A</strong><sub class="my_markdown">1</sub>不用再分解，输出；子问题（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>），读取<strong>s</strong>[2][4]=2，表示在k=2的位置把矩阵分为两个子问题：<strong>A</strong><sub>2</sub>、（<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）。</p>
<p>子问题<strong>A</strong><sub class="my_markdown">2</sub>不用再分解，输出；子问题(<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>)，读取<strong>s</strong>[3][4]=3，表示在k=3的位置把矩阵分为两个子问题：<strong>A</strong><sub>3</sub>、<strong>A</strong><sub>4</sub>。这两个子问题都不用再分解，输出。</p>
<p>子问题<strong>A</strong><sub class="my_markdown">5</sub>不用再分解，输出。</p>
<p>最优解构造过程如图4-52所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/351.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-52　最优解构造过程</b></center>
<p>最优解为：（（<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub>（<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）））<strong>A</strong><sub>5</sub>）。</p>
<p>最优值为：314。</p>
<h3 id="4-6-4-伪代码详解">4.6.4　伪代码详解</h3>
<p>按照算法思想和设计，以下程序将矩阵的行和列存储在一维数组p[]，<strong>m</strong>[][]数组用于存储分成的各个子问题的最优值，<strong>s</strong>[][]数组用于存储各个子问题的决策点，然后在一个for循环里，将问题分为规模为r的子问题，求每个规模子问题的最优解，那么得到的<strong>m</strong>[1][n]就是最小的计算量。</p>
<p>（1）矩阵连乘求解函数</p>
<p>首先将数组<strong>m</strong>[][]，<strong>s</strong>[][]初始化为0，然后自底向上处理不同规模的子问题，r为问题的规模，r= 2；r &lt;= n；r++，当r= 2时，表示矩阵连乘的规模为2，即两个矩阵连乘。求解两个矩阵连乘的最优值和最优策略，根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/339.gif" alt="code"><br>
对每一个k值，求解<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/352.gif" style="width:332px;  height: 18px; "/>，找到最小值用<strong>m</strong>[i][j]记录，并用<strong>s</strong>[i][j]记录取得最小值的k值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">matrixchain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,r,k;</span><br><span class="line">     <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));   <span class="comment">// m[][]初始化所有元素为0，实际只需要对角线为0即可</span></span><br><span class="line">     <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));   <span class="comment">// s[][]初始化所有元素为0，实际只需要对角线为0即可</span></span><br><span class="line">     <span class="keyword">for</span>(r = <span class="number">2</span>; r &lt;= n; r++)  <span class="comment">//r为问题的规模，处理不同规模的子问题</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n-r+<span class="number">1</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j = i + r - <span class="number">1</span>;</span><br><span class="line">               m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];<span class="comment">//决策为k=i的乘法次数</span></span><br><span class="line">               s[i][j] = i;             <span class="comment">//子问题的最优策略是i;</span></span><br><span class="line">              <span class="keyword">for</span>(k = i+<span class="number">1</span> ; k &lt; j; k++) <span class="comment">//对从i+1到j的所有决策，求最优值</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                           m[i][j] = t;</span><br><span class="line">                           s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）最优解输出函数</p>
<p>根据存储表格<strong>s</strong>[][]中的数据来构造最优解，即加括号的位置。首先打印一个左括号，然后递归求解子问题print（i， <strong>s</strong>[i][j]），print（<strong>s</strong>[i][j]+1，j），再打印右括号，当i=j即只剩下一个矩阵时输出该矩阵即可。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( i == j )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-6-5-实战演练">4.6.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> msize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p[msize];</span><br><span class="line"><span class="type">int</span> m[msize][msize],s[msize][msize];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">matrixchain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,r,k;</span><br><span class="line">     <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">     <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">     <span class="keyword">for</span>(r = <span class="number">2</span>; r &lt;= n; r++)          <span class="comment">//不同规模的子问题</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n-r+<span class="number">1</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              j = i + r - <span class="number">1</span>;</span><br><span class="line">              m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];  <span class="comment">//决策为k=i的乘法次数</span></span><br><span class="line">              s[i][j] = i;            <span class="comment">//子问题的最优策略是i;</span></span><br><span class="line">              <span class="keyword">for</span>(k = i+<span class="number">1</span>; k &lt; j; k++) <span class="comment">//对从i到j的所有决策，求最优值，记录最优策略</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                          m[i][j] = t;</span><br><span class="line">                          s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( i == j )</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入矩阵的个数 n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="type">int</span> i ,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个矩阵的行数和最后一个矩阵的列数：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++ )</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">     matrixchain();</span><br><span class="line">     print(<span class="number">1</span>,n);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>Visual C++ 6.0</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入矩阵的个数 n：<span class="number">5</span></span><br><span class="line">请依次输入每个矩阵的行数和最后一个矩阵的列数：<span class="number">3</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((A[<span class="number">1</span>](A[<span class="number">2</span>](A[<span class="number">3</span>]A[<span class="number">4</span>])))A[<span class="number">5</span>]) </span><br><span class="line">最小计算量的值为：<span class="number">314</span></span><br></pre></td></tr></table></figure>
<h3 id="4-6-6-算法解析及优化拓展">4.6.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由程序可以得出：语句 t= <strong>m</strong>[i][k] + <strong>m</strong>[k+1][j] +p[i−1]*p[k]*p[j]，它是算法的基本语句，在3层for循环中嵌套。最坏情况下，该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p>
<p>（2）空间复杂度：该程序的输入数据的数组为p[]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，因此空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h4 id="2．算法优化拓展-4">2．算法优化拓展</h4>
<p>想一想，还有什么办法对算法进行改进，或者有什么更好的算法实现？</p>
<h3 id="4-7-切呀切披萨——最优三角剖分">4.7　切呀切披萨——最优三角剖分</h3>
<p>有一块多边形的披萨饼，上面有很多蔬菜和肉片，我们希望沿着两个不相邻的顶点切成小三角形，并且尽可能少地切碎披萨上面的蔬菜和肉片。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/353.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-53美味披萨</b></center>
<h3 id="4-7-1-问题分析">4.7.1　问题分析</h3>
<p>我们可以把披萨饼看作一个凸多边形，凸多边形是指多边形的任意两点的连线均落在多边形的内部或边界上。</p>
<p>（1）什么是凸多边形？</p>
<p>图4-54所示是一个凸多边形，图4-55所示不是凸多边形，因为v<sub class="my_markdown">1</sub>v<sub>3</sub>的连线落在了多边形的外部。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/354.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-54　凸多边形</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/355.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-55　非凸多边形</b></center>
<p>凸多边形不相邻的两个顶点的连线称为凸多边形的弦。</p>
<p>（2）什么是凸多边形三角剖分？</p>
<p>凸多边形的三角剖分是指将一个凸多边形 <strong>分割成互不相交的三角形的弦的集合</strong> 。图4-56所示的一个三角剖分是{ v<sub class="my_markdown">0</sub>v<sub>4</sub>，v<sub>1</sub>v<sub>3</sub>，v<sub>1</sub>v<sub>4</sub>}，另一个三角剖分是{ v<sub class="my_markdown">0</sub>v<sub>2</sub>，v<sub class="my_markdown">0</sub>v<sub>3</sub>，v<sub class="my_markdown">0</sub>v<sub>4</sub>}，一个凸多边形的三角剖分有很多种。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/356.jpg" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/357.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-56　凸多边形三角剖分</b></center>
<p>如果我们给定凸多边形及定义在边、弦上的权值，即任意两点之间定义一个数值作为权值。如图4-57所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/358.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-57　带权值的凸多边形</b></center>
<p>三角形上权值之和是指三角形的3条边上权值之和：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/359.gif" alt="code"><br>
如图4-58所示，。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/360.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/361.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-58　三角形权值之和</b></center>
<p>（3）什么是凸多边形最优三角剖分？</p>
<p>一个凸多边形的三角剖分有很多种，最优三角剖分就是划分的各三角形上权函数之和最小的三角剖分。</p>
<p>再回到切披萨的问题上来，我们可以把披萨看作一个凸多边形，任何两个顶点的连线对应的权值代表上面的蔬菜和肉片数，我们希望沿着两个不相邻的顶点切成小三角形，尽可能少地切碎披萨上面的蔬菜和肉片。那么，该问题可以归结为凸多边形的最优三角剖分问题。</p>
<p>假设把披萨看作一个凸多边形，标注各顶点为{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>}。那么怎么得到它的最优三角剖分呢？</p>
<p>首先分析该问题是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>假设已经知道了在第k个顶点切开会得到最优解，那么原问题就变成了两个子问题和一个三角形，子问题分别是{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}和{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">n</sub>}，三角形为v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>，如图4-59所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/362.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-59　凸多边形三角剖分子问题</b></center>
<p>那么原问题的最优解是否包含子问题的最优解呢？</p>
<ul>
<li>假设{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>}三角剖分的权值之和是c，{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}三角剖分的权值之和是a，{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">n</sub>}三角剖分的权函数之和是b，三角形v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>的权值之和是w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>），那么c=a+b+ w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>）。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li>
</ul>
<p><strong>反证法：</strong> 如果a不是最优的，{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}三角剖分一定存在一个最优解a’，a’&lt;a，那么a’+b+w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub>n</sub>）&lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p>
<p>因此，凸多边形的最优三角剖分问题具有最优子结构性质。</p>
<p>（2）建立最优值的递归式</p>
<ul>
<li>用<strong>m</strong>[i][j]表示凸多边形{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}三角剖分的最优值，那么两个子问题{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">k</sub>}、{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">j</sub>}对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]，如图4-60所示，剩下的就是三角形v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>的权值之和是w(v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>)。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/363.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-60　凸多边形三角剖分最优值</b></center>
<p>当i=j时，{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}就变成了{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub> }，是一条线段，不能形成一个三角形剖分，我们可以将其看作退化的多边形，其权值设置为0。</p>
<ul>
<li>凸多边形三角剖分最优解递归式：</li>
</ul>
<p>当i=j时，只是一个线段，<strong>m</strong>[i][j]=0。</p>
<p>当i&gt;j时，，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/364.gif" alt="code"><br>
。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/365.gif" alt="code"><br>
（3)自底向上计算并记录最优值</p>
<p>先求只有3个顶点凸多边形三角剖分的最优值，再求4个顶点凸多边形三角剖分的最优值，直到n个顶点凸多边形三角剖分的最优值。</p>
<p>（4）构造最优解</p>
<p>上面得到的最优值只是凸多边形三角剖分的三角形权值之和最小值，并不知道是怎样剖分的。我们需要从记录表中还原剖分次序，找到最优剖分的弦，由这些弦构造出最优解。</p>
<p>如图4-61所示，如果v<sub class="my_markdown">k</sub> 能够得到凸多边形{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}的最优三角剖分，那么我们就找到两条弦v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>和v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>，把这两条弦放在最优解集合里面，继续求解两个子问题最优三角剖分的弦。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/366.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-61　凸多边形三角剖分构造最优解</b></center>
<p>凸多边形最优三角剖分的问题，首先判断该问题是否具有最优子结构性质，有了这个性质就可以使用动态规划，然后分析问题找最优解的递归式，根据递归式自底向上求解，最后根据最优决策表格，构造出最优解。</p>
<h3 id="4-7-2-算法设计">4.7.2　算法设计</h3>
<p>凸多边形最优三角剖分满足动态规划的最优子结构性质，可以从自底向上逐渐推出整体的最优。</p>
<p>（1）确定合适的数据结构</p>
<p>采用二维数组<strong>g</strong>[][]记录各个顶点之间的连接权值，二维数组<strong>m</strong>[][]存放各个子问题的最优值，二维数组<strong>s</strong>[][]存放各个子问题的最优决策。</p>
<p>（2）初始化</p>
<p>输入顶点数n，然后依次输入各个顶点之间的连接权值存储在二维数组<strong>g</strong>[][]中，令n=n−1（顶点标号从v<sub class="my_markdown">0</sub>开始），<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，…，n。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归关系式计算3个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>}的最优三角剖分，j=i+1，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][ j]，i= 1，2，3，…，n−1。</li>
<li>按照递归关系式计算4个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>}的最优三角剖分，j=i+2，将最优值存入<strong>m</strong>[i][ j]，同时将最优策略记入<strong>s</strong>[i][ j]，i= 1，2，3，…，n−2。</li>
<li>以此类推，直到求出所有顶点 {v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>} 的最优三角剖分，并将最优值存入<strong>m</strong>[1][n]，将最优策略记入<strong>s</strong>[1][n]。</li>
</ul>
<p>（4）构造最优解</p>
<p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解，即输出凸多边形最优剖分的所有弦。<strong>s</strong>[1][n] 表示凸多边形{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>} 的最优三角剖分位置，如图4-62所示。</p>
<ul>
<li>如果子问题1为空，即没有一个顶点，说明v<sub class="my_markdown">0</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>是一条边，不是弦，不需输出，否则，输出该弦v<sub class="my_markdown">0</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>。</li>
<li>如果子问题2为空，即没有一个顶点，说明v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub> v<sub class="my_markdown">n</sub>是一条边，不是弦，不需输出，否则，输出该弦v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub> v<sub class="my_markdown">n</sub>。</li>
<li>递归构造两个子问题{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>}和{v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub> }，一直递归到子问题为空停止。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/367.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-62　凸多边形三角剖分构造最优解</b></center>
<h3 id="4-7-3-完美图解">4.7.3　完美图解</h3>
<p>以图4-63的凸多边形为例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/368.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-63　凸多边形</b></center>
<p>（1）初始化</p>
<p>顶点数n=6，令n=n−1=5（顶点标号从v<sub class="my_markdown">0</sub>开始），然后依次输入各个顶点之间的连接权值存储在邻接矩阵 <strong>g</strong> [i][j]中，其中i，j=0，1，2，3，4，5，如图4-64所示。<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i=1，2，3，4，5，如图4-65所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/369.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-64　凸多边形邻接矩阵</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/370.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-65　最优值和最优策略</b></center>
<p>（2）计算3个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，4。</p>
<p>根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/371.gif" alt="code"></p>
<ul>
<li>i=1，j=2：{v<sub class="my_markdown">0</sub>，v<sub class="my_markdown">1</sub>，v<sub class="my_markdown">2</sub>}</li>
<li>k=1：<strong>m</strong>[1][2]=min{<strong>m</strong>[1][1]+<strong>m</strong>[2][2]+w(v<sub class="my_markdown">0</sub>v<sub class="my_markdown">1</sub>v<sub class="my_markdown">2</sub>)}=8；<strong>s</strong>[1][2]=1。</li>
<li>i=2，j=3：{v<sub class="my_markdown">1</sub>，v<sub class="my_markdown">2</sub>，v<sub class="my_markdown">3</sub>}</li>
<li>k=2：<strong>m</strong>[2][3]=min{<strong>m</strong>[2][2]+<strong>m</strong>[3][3]+w (v<sub class="my_markdown">1</sub>v<sub class="my_markdown">2</sub>v<sub class="my_markdown">3</sub>)}=17；<strong>s</strong>[2][3]=2。</li>
<li>i=3，j=4：{v<sub class="my_markdown">2</sub>，v<sub class="my_markdown">3</sub>，v<sub>4</sub>}</li>
<li>k=3：<strong>m</strong>[3][4]=min{<strong>m</strong>[3][3]+<strong>m</strong>[4][4]+w (v<sub class="my_markdown">2</sub>v<sub class="my_markdown">3</sub>v<sub>4</sub>)}=35；<strong>s</strong>[3][4]=3。</li>
<li>i=4，j=5：{v<sub class="my_markdown">3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li>
<li>k=4：<strong>m</strong>[4][5]=min{<strong>m</strong>[4][4]+<strong>m</strong>[5][5]+w (v<sub class="my_markdown">3</sub>v<sub>4</sub>v<sub>5</sub>)}=20；<strong>s</strong>[4][5]=4。</li>
</ul>
<p>计算完毕，如图4-66所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/372.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-66　最优值和最优策略</b></center>
<p>（3）计算4个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3。</p>
<p>根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/364.gif" alt="code"></p>
<ul>
<li>i=1，j=3：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/373.gif" alt="code"><br>
<strong>s</strong>[1][3]=2。</p>
<ul>
<li>i=2，j=4：{v<sub class="my_markdown">1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/374.gif" alt="code"><br>
<strong>s</strong>[2][4]=3。</p>
<ul>
<li>i=3，j=5：{v<sub class="my_markdown">2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/375.gif" alt="code"><br>
<strong>s</strong>[3][5]=3。</p>
<p>计算完毕，如图4-67所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/376.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-67　最优值和最优策略</b></center>
<p>（4）计算5个顶点{v<sub class="my_markdown">i</sub><sub>-1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>，v<sub class="my_markdown">i</sub><sub>+3</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2。</p>
<p>根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/364.gif" alt="code"></p>
<ul>
<li>i=1，j=4：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/377.gif" alt="code"><br>
<strong>s</strong>[1][4]=3。</p>
<ul>
<li>i=2，j=5：{v<sub class="my_markdown">1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/378.gif" alt="code"><br>
<strong>s</strong>[2][5]=3。</p>
<p>计算完毕，如图4-68所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/379.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-68　最优值和最优策略</b></center>
<p>（5）计算6个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>，v<sub class="my_markdown">i</sub><sub>+3</sub>，v<sub class="my_markdown">i</sub><sub>+4</sub>}的最优三角剖分，j=i+4，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1。</p>
<p>根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/371.gif" alt="code"></p>
<ul>
<li>i=1，j=5：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li>
</ul>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/380.gif" alt="code"><br>
<strong>s</strong>[1][5]=3。</p>
<p>计算完毕，如图4-69所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/381.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-69　最优值和最优策略</b></center>
<p>（6）构造最优解</p>
<p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解，即输出凸多边形最优剖分的所有弦。<strong>s</strong>[1][5] 表示凸多边形{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub>5</sub>} 的最优三角剖分位置，从图4-69最优决策数组可以看出，<strong>s</strong>[1][5]=3，如图4-70所示。</p>
<ul>
<li>因为v<sub class="my_markdown">0</sub>～v<sub class="my_markdown">3</sub>中有结点，所以子问题1不为空，输出该弦v<sub class="my_markdown">0</sub>v<sub class="my_markdown">3</sub>。</li>
<li>因为v<sub class="my_markdown">3</sub>～v<sub>5</sub>中有结点，所以子问题2不为空，输出该弦v<sub class="my_markdown">3</sub>v<sub>5</sub>。</li>
<li>递归构造子问题1：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub class="my_markdown">3</sub>}，读取<strong>s</strong>[1][3]=2，如图4-71所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/382.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-70　构造最优解过程（原问题）</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/383.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-71　构造最优解过程（子问题1）</b></center>
<p>因为v<sub class="my_markdown">0</sub>～v<sub>2</sub>中有结点，所以子问题1’不为空，输出该弦v<sub class="my_markdown">0</sub>v<sub>2</sub>。</p>
<p>递归构造子问题1’：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub> }，读取s[1][2]=1，如图4-72所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/384.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-72　构造最优解过程（子问题1'）</b></center>
<p>因为v<sub class="my_markdown">0</sub>～v<sub>1</sub>中没有结点，子问题1’''为空，v<sub class="my_markdown">0</sub>v<sub>1</sub>是一条边，不是弦，不输出。</p>
<p>因为v<sub class="my_markdown">1</sub>～v<sub>2</sub>中没有结点，子问题2’''为空，v<sub class="my_markdown">1</sub>v<sub>2</sub>是一条边，不是弦，不输出。</p>
<p>递归构造子问题2’：{ v<sub class="my_markdown">2</sub>，v<sub>3</sub> }。</p>
<p>因为v<sub class="my_markdown">2</sub>～v<sub>3</sub>中没有结点，子问题2’为空，v<sub class="my_markdown">2</sub>v<sub>3</sub>是一条边，不是弦，不输出。</p>
<ul>
<li>递归构造子问题2：{v<sub class="my_markdown">3</sub>，v<sub>4</sub>，v<sub>5</sub>}，读取<strong>s</strong>[4][5]=4，如图4-73所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/385.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-73　构造最优解过程（子问题2）</b></center>
<p>因为v<sub class="my_markdown">3</sub>～v<sub>4</sub>中没有结点，子问题1’'为空，v<sub class="my_markdown">3</sub>v<sub>4</sub>是一条边，不是弦，不输出。</p>
<p>因为v<sub class="my_markdown">4</sub>～v<sub>5</sub>中没有结点，子问题2’'为空，v<sub class="my_markdown">4</sub>v<sub>5</sub>是一条边，不是弦，不输出。</p>
<p>因此，该凸多边形三角剖分最优解为：v<sub class="my_markdown">0</sub>v<sub>3</sub>，v<sub>3</sub>v<sub>5</sub>，v<sub class="my_markdown">0</sub>v<sub>2</sub>。</p>
<h3 id="4-7-4-伪代码详解">4.7.4　伪代码详解</h3>
<p>（1）凸多边形三角剖分求解函数</p>
<p>首先将数组<strong>m</strong>[][]、<strong>s</strong>[][]初始化为0，然后自底向上处理不同规模的子问题，d为i到j的规模，d=2；d&lt;=n；d++，当d=2时，实际上是3个点，因为<strong>m</strong>[i][j]表示的是{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">j</sub>}。求解3个顶点凸多边形三角剖分的最优值和最优策略，根据递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/371.gif" alt="code"><br>
对每一个k值，求解<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/386.gif" style="width:275px;  height: 20px; "/>，找到最小值后用<strong>m</strong>[i][j]记录，并用<strong>s</strong>[i][j]记录取得最小值的k值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Convexpolygontriangulation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n ; i++) <span class="comment">// 初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">         m[i][i] = <span class="number">0</span> ;</span><br><span class="line">         s[i][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span> ;d &lt;= n ; d++)  <span class="comment">//d为i到j的规模，d=2时，实际上是三个点</span></span><br><span class="line">                                  <span class="comment">//因为我们的m[i][j]表示的是&#123;vi-1，vi，vj&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n - d + <span class="number">1</span> ; i++) <span class="comment">//控制i值</span></span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = i + d - <span class="number">1</span> ;             <span class="comment">// j值</span></span><br><span class="line">           m[i][j] = m[i+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][i] + g[i][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">           s[i][j] = i ;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span> ;k &lt; j ; k++) <span class="comment">// 枚举划分点</span></span><br><span class="line">           &#123;</span><br><span class="line">                <span class="type">double</span> temp = m[i][k] + m[k+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][k] + g[k][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                     m[i][j] = temp ;      <span class="comment">// 更新最优值</span></span><br><span class="line">                     s[i][j] = k ;         <span class="comment">// 记录划分点</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>（2）最优解输出函数</p>
<p>我们首先从<strong>s</strong>[][]数组中读取<strong>s</strong>[i][j]，然后判断子问题1是否为空。若<strong>s</strong>[i][j]&gt;i，表示i到<strong>s</strong>[i][j]之间存在顶点，子问题1不为空，那么v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]</sub>是一条弦，输出{v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]</sub>}；判断子问题2是否为空，若j&gt;<strong>s</strong>[i][j]+1，表示<strong>s</strong>[i][j]+1到j之间存在顶点，子问题2不为空，那么v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]+1</sub> v<sub class="my_markdown">j</sub>是一条弦，输出{v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]+1</sub>v<sub class="my_markdown">j</sub>}。递归求解子问题1和子问题2，直到i=j时停止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> j)</span>                  <span class="comment">// 输出所有的弦</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i == j)  <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]&gt;i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">if</span>(j&gt;s[i][j]+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(i ,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span> ,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-7-5-实战演练">4.7.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M= <span class="number">1000</span> + <span class="number">5</span> ;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="type">int</span> s[M][M] ;</span><br><span class="line"><span class="type">double</span> m[M][M],g[M][M];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Convexpolygontriangulation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n ; i++)           <span class="comment">// 初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">         m[i][i] = <span class="number">0</span> ;</span><br><span class="line">         s[i][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span> ;d &lt;= n ; d++)        <span class="comment">//d为问题规模，d=2时，实际上是三个点</span></span><br><span class="line">                                        <span class="comment">//因为我们的m[i][j]表示的是&#123;vi-1，vi，vj&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n - d + <span class="number">1</span> ; i++)  <span class="comment">// 控制i值</span></span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = i + d - <span class="number">1</span> ;          <span class="comment">// j值</span></span><br><span class="line">           m[i][j] = m[i+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][i] + g[i][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">           s[i][j] = i ;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span> ;k &lt; j ; k++)     <span class="comment">// 枚举划分点</span></span><br><span class="line">           &#123;</span><br><span class="line">                <span class="type">double</span> temp = m[i][k] + m[k+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][k] + g[k][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                     m[i][j] = temp ;   <span class="comment">// 更新最优值</span></span><br><span class="line">                     s[i][j] = k ;      <span class="comment">// 记录划分点</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> j)</span>               <span class="comment">// 输出所有的弦</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i == j)  <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]&gt;i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">if</span>(j&gt;s[i][j]+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(i ,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span> ,j);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入顶点的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     n-- ;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各顶点的连接权值:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt;= n ; ++i)           <span class="comment">// 输入各个顶点之间的连接权值</span></span><br><span class="line">          <span class="keyword">for</span>( j = <span class="number">0</span> ;j &lt;= n ; ++j)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;g[i][j] ;</span><br><span class="line">     Convexpolygontriangulation ();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(<span class="number">1</span> ,n);                       <span class="comment">// 打印路径</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>算法实现和测试</strong></p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>Visual C++ 6.0</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span>  <span class="number">2</span>  <span class="number">3</span>   <span class="number">1</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">8</span>   <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">0</span>   <span class="number">10</span>  <span class="number">13</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">10</span>  <span class="number">0</span>   <span class="number">12</span>  <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  <span class="number">8</span>  <span class="number">13</span>  <span class="number">12</span>  <span class="number">0</span>   <span class="number">3</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>   <span class="number">5</span>   <span class="number">3</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54</span></span><br><span class="line">&#123; v0 v3 &#125;</span><br><span class="line">&#123; v3 v5 &#125;</span><br><span class="line">&#123; v0 v2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-7-6-算法解析及优化拓展">4.7.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-5">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由程序可以得出语句 t= <strong>m</strong>[i][k] + <strong>m</strong>[k+1][j] + <strong>g</strong>[i−1][i] + <strong>g</strong>[i][j] + <strong>g</strong>[i−1] [j]，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，最坏情况下时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p>
<p>（2）空间复杂度：该程序的输入数据的数组为<strong>g</strong>[][]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，因此空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h4 id="2．算法优化拓展-5">2．算法优化拓展</h4>
<p>这个问题尽管和矩阵连乘问题表达的含义不同，但递归式是完全相同的，那么程序代码就可以参考矩阵连乘的代码了。</p>
<p>想一想，还有什么办法对算法进行改进，或者有什么更好的算法实现？</p>
<h3 id="4-8-小石子游戏——石子合并">4.8　小石子游戏——石子合并</h3>
<p>一群小孩子在玩小石子游戏，游戏有两种玩法。</p>
<p>（1）路边玩法</p>
<p>有n堆石子堆放在路边，现要将石子有序地合并成一堆，规定每次只能移动相邻的两堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费（最小或最大）。</p>
<p>（2）操场玩法</p>
<p>一个圆形操场周围摆放着n堆石子，现要将石子有序地合并成一堆，规定每次只能移动相邻的两堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费（最小或最大）。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/387.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-74　小石子游戏</b></center>
<h3 id="4-8-1-问题分析">4.8.1　问题分析</h3>
<p>本题初看可以使用贪心法来解决，但是因为有必须相邻两堆才能合并这个条件在，用贪心法就无法保证每次都能取到所有堆中石子数最少（最多）的两堆。</p>
<p>下面以操场玩法为例：假设有n=6堆石子，每堆的石子个数分别为3、4、6、5、4、2。</p>
<p>如果使用贪心法求最小花费，应该是如下的合并步骤：</p>
<p>第1次合并 3 4 6 5 4 2　　 　2，3合并花费是5</p>
<p>第2次合并 5 4 6 5 4　　　　5，4合并花费是9</p>
<p>第3次合并 9 6 5 4　 　 　 　5，4合并花费是9</p>
<p>第4次合并 9 6 9 　　 　　　 9，6合并花费是15</p>
<p>第5次合并 15 9　 　　 　 　15，9合并花费是24</p>
<p>总得分＝5＋9＋9＋15＋24＝62</p>
<p>但是如果采用如下合并方法，却可以得到比上面花费更少的方法：</p>
<p>第1次合并 3 4 6 5 4 2　　　 3，4合并花费是7</p>
<p>第2次合并 7 6 5 4 2　　　 　7，6合并花费是13</p>
<p>第3次合并 13 5 4 2　　　　 4，2合并花费是6</p>
<p>第4次合并 13 5 6　　　　 　5，6合并花费是11</p>
<p>第5次合并 13 11　　　　　 13，11合并花费是24</p>
<p>总花费＝7＋13＋6＋11＋24＝61</p>
<p>显然利用贪心法来求解错误的，贪心算法在子过程中得出的解只是局部最优，而不能保证全局的值最优，因此本题不可以使用贪心法求解。</p>
<p>如果使用暴力穷举的办法，会有大量的子问题重复，这种做法是不可取的，那么是否可以使用动态规划呢？我们要分析该问题是否具有最优子结构性质，它是使用动态规划的必要条件。</p>
<h4 id="1．路边玩法">1．路边玩法</h4>
<p>如果n−1次合并的全局最优解包含了每一次合并的子问题的最优解，那么经这样的n−1次合并后的花费总和必然是最优的，因此我们就可以通过动态规划算法来求出最优解。</p>
<p>首先分析该问题是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>假设已经知道了在第k堆石子分开可以得到最优解，那么原问题就变成了两个子问题，子问题分别是{a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub>}和{ a<sub class="my_markdown">k</sub><sub>+1</sub>，…，a<sub class="my_markdown">j</sub>}，如图4-75所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/388.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-75　原问题分解为子问题</b></center>
<p>那么原问题的最优解是否包含子问题的最优解呢？</p>
<ul>
<li>假设已经知道了n堆石子合并起来的花费是c，子问题1{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub> }石子合并起来的花费是a，子问题2{ a<sub class="my_markdown">k</sub><sub>+1</sub>，…，a<sub class="my_markdown">j</sub>}石子合并起来的花费是b，{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">j</sub> }石子数量之和是w（i，j），那么c=a+b+ w（i，j）。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li>
</ul>
<p><strong>反证法：</strong> 如果a不是最优的，子问题1{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub> }一定存在一个最优解a’，a’&lt;a，那么a’+b+ w（i，j）&lt;c，这与我们的假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p>
<p>因此，路边玩法小石子合并游戏问题具有最优子结构性质。</p>
<p>（2）建立最优值递归式</p>
<p>设<strong>Min</strong>[i][j]代表从第i堆石子到第j堆石子合并的最小花费，<strong>Min</strong>[i][k]代表从第i堆石子到第k堆石子合并的最小花费，<strong>Min</strong>[k+1][j]代表从第k+1堆石子到第j堆石子合并的最小花费，w（i，j）代表从i堆到j堆的石子数量之和。列出递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/389.gif" alt="code"><br>
<strong>Max</strong>[i][j] 代表从第 i 堆石子到第 j 堆石子合并的最大花费，<strong>Max</strong>[i][k] 代表从第 i 堆石子到第 k堆石子合并的最大花费，<strong>Max</strong>[k+1][j] 代表从第 k+1堆石子到第 j 堆石子合并的最大花费，w（i，j)代表从i堆到j堆的石子数量之和。列出递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/390.gif" alt="code"></p>
<h4 id="2．操场玩法">2．操场玩法</h4>
<p>如果把路边玩法看作直线型石子合并问题，那么操场玩法就属于圆型石子合并问题。圆型石子合并经常转化为直线型来求。也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，如图4-76所示。然后就可以用线性的石子合并问题的方法求解，求最大值的方法和求最小值的方法是一样的。最后，从 <strong>规模是</strong> n <strong>的最优值</strong> 找出 <strong>最小值或最大值</strong> 即可。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/391.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-76　转化为规模为2n−1的直线型</b></center>
<h3 id="4-8-2-算法设计">4.8.2　算法设计</h3>
<h4 id="1．路边玩法-2">1．路边玩法</h4>
<p>假设有n堆石子，一字排开，合并相邻两堆的石子，每合并两堆石子有一个花费，最终合并后的最小花费和最大花费。</p>
<p>（1）确定合适的数据结构</p>
<p>采用一维数组a[i]来记录第i堆石子（a<sub class="my_markdown">i</sub>）的数量；sum[i]来记录前i堆（a<sub>1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">i</sub>）石子的总数量；二维数组<strong>Min</strong>[i][j]、<strong>Max</strong>[i][j]来记录第i堆到第j堆a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，…，a<sub class="my_markdown">i</sub>堆石子合并的最小花费和最大花费。</p>
<p>（2）初始化</p>
<p>输入石子的堆数n，然后依次输入各堆石子的数量存储在a[i]中，令<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归式计算2堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，…，n−1。</li>
<li>按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，…，n−2。</li>
<li>以此类推，直到求出所有堆{a<sub class="my_markdown">1</sub>，…，a<sub class="my_markdown">n</sub>}的最小花费和最大花费。</li>
</ul>
<p>（4）构造最优解</p>
<p><strong>Min</strong>[1][n]和<strong>Max</strong>[1][n]是n堆石子合并的最小花费和最大花费。如果还想知道具体的合并顺序，需要在求解的过程中记录最优决策，然后逆向构造最优解，可以使用类似矩阵连乘的构造方法，用括号来表达合并的先后顺序。</p>
<h4 id="2．操场玩法-2">2．操场玩法</h4>
<p>圆型石子合并经常转化为直线型来求，也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，然后就可以用线性的石子合并问题的方法求解，求最小花费和最大花费的方法是一样的。最后，从规模是n的最优值找出最小值即可。即要从规模为n的最优值<strong>Min</strong>[1][n]，<strong>Min</strong>[2][n+1]，<strong>Min</strong>[3][n+2]，…，<strong>Min</strong>[n][2n−1]中找最小值作为圆型石子合并的最小花费。</p>
<p>从 <strong>规模是</strong> n <strong>的最优值</strong> <strong>Max</strong>[1][n]，<strong>Max</strong>[2][n+1]，<strong>Max</strong>[3][n+2]，…，<strong>Max</strong>[n][2n−1] 中找 <strong>最大值</strong> 作为圆型石子合并的最大花费。</p>
<h3 id="4-8-3-完美图解">4.8.3　完美图解</h3>
<p>如图4-77所示，以6堆石子的路边玩法为例。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/392.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-77　6堆石子</b></center>
<p>（1）初始化</p>
<p>输入石子的堆数n，然后依次输入各堆石子的数量存储在a[i]中，如图4-78所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/393.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-78　石子数量</b></center>
<p><strong>Min</strong>[i][j]和<strong>Max</strong>[i][j]来记录第i堆到第j堆a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，…，a<sub class="my_markdown">i</sub>堆石子合并的最小花费和最大花费。令<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，如图4-79所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/394.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-79　最小花费和最大花费</b></center>
<p>sum[i]为前i堆石子数量总和，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n，如图4-80所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/395.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-80　前i堆石子数量总和</b></center>
<p>原递归公式中的w（i，j）代表从i堆到j堆的石子数量之和，可以用直接查表法sum[j] −sum[i−1]求解，如图4-81所示。这样就不用每次遇到w（i，j）都计算一遍了，这也是动态规划思想的显现！</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/396.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-81　sum[j]−sum[i−1]即为w（i，j）</b></center>
<p>（2）按照递归式计算两堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，4，5。如图4-82所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/397.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-82　最小花费和最大花费</b></center>
<ul>
<li>i=1，j=2：{a<sub class="my_markdown">1</sub>，a<sub>2</sub>}</li>
</ul>
<p>k=1：<strong>Min</strong>[1][2]=<strong>Min</strong>[1][1]+<strong>Min</strong>[2][2]+sum[2] −sum[0]=13；</p>
<p>**　 　 Max**[1][2]=<strong>Max</strong>[1][1]+<strong>Max</strong>[2][2]+sum[2] −sum[0]=13。</p>
<ul>
<li>i=2，j=3：{a<sub class="my_markdown">2</sub>，a<sub>3</sub>}</li>
</ul>
<p>k=2：<strong>Min</strong>[2][3]=<strong>Min</strong>[2][2]+<strong>Min</strong>[3][3]+sum[3] −sum[1]=14；</p>
<p>**　 　 Max**[2][3]=<strong>Max</strong>[2][2]+<strong>Max</strong>[3][3]+sum[3] −sum[1]=14。</p>
<ul>
<li>i=3，j=4：{a<sub class="my_markdown">3</sub>，a<sub>4</sub>}</li>
</ul>
<p>k=3：<strong>Min</strong>[3][4]=<strong>Min</strong>[3][3]+<strong>Min</strong>[4][4]+sum[4] −sum[2]=15；</p>
<p>**　 　 Max**[3][4]=<strong>Max</strong>[3][3]+<strong>Max</strong>[4][4]+sum[4] −sum[2]=15。</p>
<ul>
<li>i=4，j=5：{a<sub class="my_markdown">4</sub>，a<sub>5</sub>}</li>
</ul>
<p>k=4：<strong>Min</strong>[4][5]=<strong>Min</strong>[4][4]+<strong>Min</strong>[5][5]+sum[5] −sum[3]=11；</p>
<p>**　 　 Max**[4][5]=<strong>Max</strong>[4][4]+<strong>Max</strong>[5][5]+sum[5] −sum[3]=11。</p>
<ul>
<li>i=5，j=6：{a<sub class="my_markdown">5</sub>，a<sub>6</sub>}</li>
</ul>
<p>k=5：<strong>Min</strong>[5][6]=<strong>Min</strong>[5][5]+<strong>Min</strong>[6][6]+sum[6] −sum[4]=5；</p>
<p>**　 　 Max**[5][6]=<strong>Max</strong>[5][5]+<strong>Max</strong>[6][6]+sum[6] −sum[4]=5。</p>
<p>（3）按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，4，如图4-83所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/398.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-83　最小花费和最大花费</b></center>
<ul>
<li>i=1，j=3：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>}</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/399.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/400.gif" alt="code"><br>
<strong>Min</strong>[1][3]= 32；<strong>Max</strong>[1][3]=33。</p>
<ul>
<li>i=2，j=4：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>}</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/401.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/402.gif" alt="code"><br>
<strong>Min</strong>[2][4]= 37；<strong>Max</strong>[2][4]=38。</p>
<ul>
<li>i=3，j=5：{ a<sub class="my_markdown">3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/403.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/404.gif" alt="code"><br>
<strong>Min</strong>[3][5]= 28；<strong>Max</strong>[3][5]=32。</p>
<ul>
<li>i=4，j=6：{ a<sub class="my_markdown">4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/405.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/406.gif" alt="code"><br>
<strong>Min</strong>[4][6]= 19；<strong>Max</strong>[4][6]=25。</p>
<p>（4）按照递归式计算4堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>，a<sub class="my_markdown">i</sub><sub>+3</sub>}的最小花费和最大花费，i=1，2，3，如图4-84所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/407.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-84　最小花费和最大花费</b></center>
<ul>
<li>i=1，j=4：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>}</li>
</ul>
<p><strong>Min</strong>[1][4]= 56；<strong>Max</strong>[1][4]=66。</p>
<ul>
<li>i=2，j=5：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li>
</ul>
<p><strong>Min</strong>[2][5]=50；<strong>Max</strong>[2][5]=63。</p>
<ul>
<li>i=3，j=6：{ a<sub class="my_markdown">3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li>
</ul>
<p><strong>Min</strong>[3][6]=39；<strong>Max</strong>[3][6]=52。</p>
<p>（5）按照递归式计算5堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>，a<sub class="my_markdown">i</sub><sub>+3</sub>，a<sub class="my_markdown">i</sub><sub>+4</sub>}的最小花费和最大花费，i=1，2，如图4-85所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/414.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-85　最小花费和最大花费</b></center>
<ul>
<li>i=1，j=5：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li>
</ul>
<p><strong>Min</strong>[1][5]=71；<strong>Max</strong>[1][5]=96。</p>
<ul>
<li>i=2，j=6：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li>
</ul>
<p><strong>Min</strong>[2][6]=61；<strong>Max</strong>[3][6]=9。</p>
<p>（6）按照递归式计算6堆石子合并{a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}的最小花费和最大花费，如图4-86所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/419.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-86　最小花费和最大花费</b></center>
<ul>
<li>i=1，j=6：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li>
</ul>
<p><strong>Min</strong>[1][6]=84；<strong>Max</strong>[1][6]=129。</p>
<h3 id="4-8-4-伪代码详解">4.8.4　伪代码详解</h3>
<p>（1）路边玩法</p>
<p>首先初始化<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n。</p>
<p>循环阶段：</p>
<p>按照递归式计算2堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，…，n−1。</p>
<p>按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，…，n−2。</p>
<p>以此类推，直到求出所有堆{a<sub class="my_markdown">1</sub>，…，a<sub class="my_markdown">n</sub>}的最小花费和最大花费。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)               <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Min[i][j] = INF;          <span class="comment">//初始化为最大值</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;j; k++) &#123;  <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">                    Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）操场玩法</p>
<p>圆型石子合并经常转化为直线型来求，也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，然后就可以用线性的石子合并问题的方法求解，求最小花费和最大花费的方法是一样的。最后，从最优解中找出规模是n的最优解即可。</p>
<p>即要从规模为n的最优解<strong>Min</strong>[1][n]，<strong>Min</strong>[2][n+1]，<strong>Min</strong>[3][n+2]，…，<strong>Min</strong>[n][2n−1]中找最小值作为圆型石子合并的最小花费。</p>
<p>从<strong>Max</strong>[1][n]，<strong>Max</strong>[2][n+1]，<strong>Max</strong>[3][n+2]，…，<strong>Max</strong>[n][2n−1] 中找出最大值作为圆型石子合并的最大花费。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">              min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">              max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-8-5-实战演练">4.8.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> Min[N][N], Max[N][N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> min_Circular,max_Circular;</span><br><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Min[i][j] = INF;          <span class="comment">//初始化为最大值</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;j; k++) &#123;  <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">                    Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">              min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">              max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入石子的堆数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各堆的石子数:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">     straight(a, n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法（直线型）最小花费为：&quot;</span>&lt;&lt;Min[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法（直线型）最大花费为：&quot;</span>&lt;&lt;Max[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     Circular(a,n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法（圆型）最小花费为：&quot;</span>&lt;&lt;min_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法（圆型）最大花费为：&quot;</span>&lt;&lt;max_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现和测试</p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入石子的堆数 n：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">请依次输入各堆的石子数：</span><br><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路边玩法（直线型）最小花费为：<span class="number">84</span></span><br><span class="line">路边玩法（直线型）最大花费为：<span class="number">129</span></span><br><span class="line">操场玩法（圆型）最小花费为：<span class="number">81</span></span><br><span class="line">操场玩法（圆型）最大花费为：<span class="number">130</span></span><br></pre></td></tr></table></figure>
<h3 id="4-8-6-算法解析及优化拓展">4.8.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-6">1．算法复杂度分析</h4>
<p>（1）时间复杂度：由程序可以得出语句<strong>Min</strong>[i][j] = min(<strong>Min</strong>[i][j], <strong>Min</strong>[i][k] + <strong>Min</strong>[k+1][j] + tmp)，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p>
<p>（2）空间复杂度：该程序的辅助变量为<strong>Min</strong>[][]、<strong>Max</strong>[][]，空间复杂度取决于辅助空间，故空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h4 id="2．算法优化拓展-6">2．算法优化拓展</h4>
<p>对于石子合并问题，如果按照普通的区间动态规划进行求解，时间复杂度是O(n<sup class="my_markdown">3</sup>)，但最小值可以用四边形不等式（见附录F）优化。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/422.gif" alt="code"><br>
<strong>s</strong>[i][j]表示取得最优解<strong>Min</strong>[i][j]的最优策略位置。</p>
<p>k的取值范围缩小了很多，原来是区间[i，j)，现在变为区间[<strong>s</strong>[i][j−1]，<strong>s</strong>[i+1][j])。如图4-87所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/423.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-87　k的取值范围缩小</b></center>
<p>经过优化，算法时间复杂度可以减少至O(n<sup class="my_markdown">2</sup>)。</p>
<p>注意：最大值有一个性质，即总是在两个端点的最大者中取到。</p>
<p>即<strong>Max</strong>[i][j] = max(<strong>Max</strong>[i][j−1], <strong>Max</strong>[i+1][j]) + <strong>sum</strong>[i][j]</p>
<p>经过优化，算法时间复杂度也可以减少至O(n<sup class="my_markdown">2</sup>)。</p>
<p>优化后算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-6-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> Min[N][N], Max[N][N],s[N][N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> min_Circular,max_Circular;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Min</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)               <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)      <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;            <span class="comment">//枚举终点j</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];  <span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="type">int</span> i1=s[i][j<span class="number">-1</span>]&gt;i?s[i][j<span class="number">-1</span>]:i;</span><br><span class="line">               <span class="type">int</span> j1=s[i+<span class="number">1</span>][j]&lt;j?s[i+<span class="number">1</span>][j]:j;</span><br><span class="line">               Min[i][j]=Min[i][i1]+Min[i1+<span class="number">1</span>][j];</span><br><span class="line">               s[i][j]=i1;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i1+<span class="number">1</span>; k&lt;=j1; k++) <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    <span class="keyword">if</span>(Min[i][k]+ Min[k+<span class="number">1</span>][j]&lt;Min[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                         Min[i][j]=Min[i][k]+Min[k+<span class="number">1</span>][j];</span><br><span class="line">                         s[i][j]=k;</span><br><span class="line">                    &#125;</span><br><span class="line">               Min[i][j]+=tmp;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Max</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">if</span>(Max[i+<span class="number">1</span>][j]&gt;Max[i][j<span class="number">-1</span>])</span><br><span class="line">                   Max[i][j]=Max[i+<span class="number">1</span>][j]+tmp;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   Max[i][j]=Max[i][j<span class="number">-1</span>]+tmp;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)               <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>, s[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     get_Min(n);</span><br><span class="line">     get_Max(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">             min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">             max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入石子的堆数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各堆的石子数:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">     straight(a, n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法(直线型)最小花费为：&quot;</span>&lt;&lt;Min[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法(直线型)最大花费为：&quot;</span>&lt;&lt;Max[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     Circular(a,n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法(圆型)最小花费为：&quot;</span>&lt;&lt;min_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法(圆型)最大花费为：&quot;</span>&lt;&lt;max_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（1）时间复杂度：在get_Min()函数中，虽然有3层for循环语句，但并不是有3层for语句的执行次数就是O(n<sup class="my_markdown">3</sup>)，我们分析其执行次数为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/424.gif" alt="code"><br>
因为公式中的j=i+v−1，所以：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/425.gif" alt="code"><br>
故get_Min()的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<p>在get_Max()函数中，有两层for循环语句嵌套，时间复杂度也是O(n<sup class="my_markdown">2</sup>)。</p>
<p>（2）空间复杂度：空间复杂度取决于辅助空间，空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h3 id="4-9-大卖场购物车1——0-1背包问题">4.9　大卖场购物车1——0-1背包问题</h3>
<p>央视有一个大型娱乐节目——购物街，舞台上模拟超市大卖场，有很多货物，每个嘉宾分配一个购物车，可以尽情地装满购物车，购物车中装的货物价值最高者取胜。假设有n个物品和1个购物车，每个物品i对应价值为v<sub class="my_markdown">i</sub>，重量w<sub class="my_markdown">i</sub>，购物车的容量为W（你也可以将重量设定为体积）。每个物品只有1件，要么装入，要么不装入，不可拆分。在购物车不超重的情况下，如何选取物品装入购物车，使所装入的物品的总价值最大？最大价值是多少？装入了哪些物品？</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/426.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-88　大卖场购物车1</b></center>
<h3 id="4-9-1-问题分析">4.9.1　问题分析</h3>
<p>有n个物品和购物车的容量，每个物品的重量为w[i]，价值为v[i]，购物车的容量为W。选若干个物品放入购物车，使价值最大，可表示如下。</p>
<p>约束条件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/427.gif" alt="code"><br>
目标函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/428.gif" alt="code"><br>
问题归结为求解满足约束条件，使目标函数达到最大值的解向量X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，…，x<sub class="my_markdown">n</sub>}。</p>
<p>该问题就是经典的0-1背包问题，我们在第2章贪心算法中已经知道背包问题（可切割）可以用贪心算法求解，而0-1背包问题使用贪心算法有可能得不到最优解（参看2.4.6节）。因为物品的不可切割性，无法保证能够装满背包，所以采用每次装价值/重量比最高的贪心策略是不可行的。</p>
<p>那么是否能够使用动态规划呢？</p>
<p>首先分析该问题是否具有最优子结构性质。</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>假设已经知道了X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，…，x<sub class="my_markdown">n</sub>}是原问题{a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，那么原问题去掉第一个物品就变成了子问题{a<sub>2</sub>，a<sub>3</sub>，…，a<sub class="my_markdown">n</sub>}，如图4-89所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/429.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-89　原问题和子问题</b></center>
<p>子问题的约束条件和目标函数如下。</p>
<p>约束条件：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/430.gif" alt="code"><br>
目标函数：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/431.gif" alt="code"></p>
<ul>
<li>我们只需要证明：X’={x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}是子问题{a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，即证明了最优子结构性质。</li>
</ul>
<p><strong>反证法：</strong> 假设X’={ x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}不是子问题{ a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，{ y<sub class="my_markdown">2</sub>，…，y<sub class="my_markdown">n</sub>}是子问题的最优解，<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/432.gif" style="width:137px;  height: 50px; "/>，且满足约束条件<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/433.gif" style="width:163px;  height: 50px; "/>，我们将约束条件两边同时加上<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/434.gif" style="width:36px;  height: 12px; "/>，则变为<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/435.gif" style="width:164px;  height: 50px; "/>，目标函数两边同时加上<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/436.gif" style="width:32px;  height: 12px; "/>，则变为<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/437.gif" style="width:194px;  height: 51px; "/>，说明{x<sub>1</sub>，y<sub class="my_markdown">2</sub>，…，y<sub class="my_markdown">n</sub>}比{ x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}更优，{ x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}不是原问题{a<sub>1</sub>，a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，与假设X={x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}是原问题{a<sub>1</sub>，a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解矛盾。问题得证。</p>
<p>该问题是否具有最优子结构性质。</p>
<p>（2）建立最优值的递归式</p>
<p>可以对每个物品依次检查是否放入或者不放入，对于第i个物品的处理状态：</p>
<p>用<strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。</p>
<ul>
<li>不放入第i件物品，x<sub class="my_markdown">i</sub>=0，装入购物车的价值不增加。那么问题就转化为“前i−1件物品放入容量为j的背包中”，最大价值为<strong>c</strong>[i−1][j]。</li>
<li>放入第i件物品，x<sub class="my_markdown">i</sub>=1，装入购物车的价值增加v<sub class="my_markdown">i</sub>。</li>
</ul>
<p>那么问题就转化为“前i−1件物品放入容量为j−w[i]的购物车中”，此时能获得的最大价值就是<strong>c</strong>[i−1][j−w[i]]，再加上放入第i件物品获得的价值v[i]。即<strong>c</strong>[i−1][j−w[i]]+ v[i]。</p>
<p>购物车容量不足，肯定不能放入；购物车容量足，我们要看放入、不放入哪种情况获得的价值更大。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif/" alt="code"></p>
<h3 id="4-9-2-算法设计">4.9.2　算法设计</h3>
<p>有n个物品，每个物品的重量为w[i]，价值为v[i]，购物车的容量为W。选若干个物品放入购物车，在不超过容量的前提下使获得的价值最大。</p>
<p>（1）确定合适的数据结构</p>
<p>采用一维数组w[i]、v[i]来记录第i个物品的重量和价值；二维数组用<strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。</p>
<p>（2）初始化</p>
<p>初始化<strong>c</strong>[][]数组0行0列为0：<strong>c</strong>[0][j]=0，<strong>c</strong>[i][0] =0，其中i=0，1，2，…，n，j=0，1，2，…，W。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归式计算第1个物品的处理情况，得到<strong>c</strong>[1][j]，j=1，2，…，W。</li>
<li>按照递归式计算第2个物品的处理情况，得到<strong>c</strong>[2][j]，j=1，2，…，W。</li>
<li>以此类推，按照递归式计算第n个物品的处理情况，得到<strong>c</strong>[n][j]，j=1，2，…，W。</li>
</ul>
<p>（4）构造最优解</p>
<p><strong>c</strong>[n][W]就是不超过购物车容量能放入物品的最大价值。如果还想知道具体放入了哪些物品，就需要根据<strong>c</strong>[][]数组逆向构造最优解。我们可以用一维数组x[i]来存储解向量。</p>
<ul>
<li>首先i=n，j=W，如果<strong>c</strong>[i][j]&gt;<strong>c</strong>[i−1][j]，则说明第n个物品放入了购物车，令x[n]=1，j−=w[n]；如果<strong>c</strong>[i][j]≤<strong>c</strong>[i−1][j]，则说明第n个物品没有放入购物车，令x[n]=0。</li>
<li>i−−，继续查找答案。</li>
<li>直到i=1处理完毕。</li>
</ul>
<p>这时已经得到了解向量（x[1]，x[2]，…，x[n]），可以直接输出该解向量，也可以仅把x[i]=1的货物序号i输出。</p>
<h3 id="4-9-3-完美图解">4.9.3　完美图解</h3>
<p>假设现在有5个物品，每个物品的重量为（2，5，4，2，3），价值为（6，3，5，4，6），如图4-90所示。购物车的容量为10，求在不超过购物车容量的前提下，把哪些物品放入购物车，才能获得最大价值。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/439.jpg" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/440.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-90　物品的重量和价值</b></center>
<p>（1）初始化</p>
<p><strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。初始化<strong>c</strong>[][]数组0行0列为0：<strong>c</strong>[0][j]=0，<strong>c</strong>[i][0] =0，其中i=0，1，2，…，n，j=0，1，2，…，W。如图4-91所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/441.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-91　最大价值数组</b></center>
<p>按照递归式计算第1个物品（i=1）的处理情况，得到<strong>c</strong>[1][j]，j=1，2，…，W。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>
w[1]=2，v[1]=6，如图4-92所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/442.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-92　最大价值数组</b></center>
<ul>
<li>j=1时，<strong>c</strong>[1][1]=<strong>c</strong>[0][1]=0；</li>
<li>j=2时，<strong>c</strong>[1][2]=max{<strong>c</strong>[0][2]，<strong>c</strong>[0][0]+6}=6；</li>
<li>j=3时，<strong>c</strong>[1][3]=max{<strong>c</strong>[0][3]，<strong>c</strong>[0][1]+6}=6；</li>
<li>j=4时，<strong>c</strong>[1][4]=max{<strong>c</strong>[0][4]，<strong>c</strong>[0][2]+6}=6；</li>
<li>j=5时，<strong>c</strong>[1][5]=max{<strong>c</strong>[0][5]，<strong>c</strong>[0][3]+6}=6；</li>
<li>j=6时，<strong>c</strong>[1][6]=max{<strong>c</strong>[0][6]，<strong>c</strong>[0][4]+6}=6；</li>
<li>j=7时，<strong>c</strong>[1][7]=max{<strong>c</strong>[0][7]，<strong>c</strong>[0][5]+6}=6；</li>
<li>j=8时，<strong>c</strong>[1][8]=max{<strong>c</strong>[0][8]，<strong>c</strong>[0][6]+6}=6；</li>
<li>j=9时，<strong>c</strong>[1][9]=max{<strong>c</strong>[0][9]，<strong>c</strong>[0][7]+6}=6；</li>
<li>j=10时，<strong>c</strong>[1][10]=max{<strong>c</strong>[0][10]，<strong>c</strong>[0][8]+6}=6。</li>
</ul>
<p>（2）按照递归式计算第1个物品（i=2）的处理情况，得到<strong>c</strong>[2][j]，j=1，2，…，W。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>
w[2]=5，v[2]=3，如图4-93所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/443.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-93　最大价值数组</b></center>
<ul>
<li>j=1时，<strong>c</strong>[2][1]=<strong>c</strong>[1][1]=0；</li>
<li>j=2时，<strong>c</strong>[2][2]=<strong>c</strong>[1][2]=6；</li>
<li>j=3时，<strong>c</strong>[2][3]=<strong>c</strong>[1][3]=6；</li>
<li>j=4时，<strong>c</strong>[2][4]=<strong>c</strong>[1][4]=6；</li>
<li>j=5时，<strong>c</strong>[2][5]=max{<strong>c</strong>[1][5]，<strong>c</strong>[1][0]+3}=6；</li>
<li>j=6时，<strong>c</strong>[2][6]=max{<strong>c</strong>[1][6]，<strong>c</strong>[1][1]+3}=6；</li>
<li>j=7时，<strong>c</strong>[2][7]=max{<strong>c</strong>[1][7]，<strong>c</strong>[1][2]+3}=9；</li>
<li>j=8时，<strong>c</strong>[2][8]=max{<strong>c</strong>[1][8]，<strong>c</strong>[1][3]+3}=9；</li>
<li>j=9时，<strong>c</strong>[2][9]=max{<strong>c</strong>[1][9]，<strong>c</strong>[1][4]+3}=9；</li>
<li>j=10时，<strong>c</strong>[1][10]=max{<strong>c</strong>[1][10]，<strong>c</strong>[1][5]+3}=9。</li>
</ul>
<p>（3）按照递归式计算第1个物品（i=3）的处理情况，得到<strong>c</strong>[3][j]，j=1，2，…，W。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>
w[3]=4，v[3]=5，如图4-94所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/444.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-94　最大价值数组</b></center>
<ul>
<li>j=1时，<strong>c</strong>[3][1]=<strong>c</strong>[2][1]=0；</li>
<li>j=2时，<strong>c</strong>[3][2]=<strong>c</strong>[2][2]=6；</li>
<li>j=3时，<strong>c</strong>[3][3]=<strong>c</strong>[2][3]=6；</li>
<li>j=4时，<strong>c</strong>[3][4]=max{<strong>c</strong>[2][4]，<strong>c</strong>[2][0]+5}=6；</li>
<li>j=5时，<strong>c</strong>[3][5]=max{<strong>c</strong>[2][5]，<strong>c</strong>[2][1]+5}=6；</li>
<li>j=6时，<strong>c</strong>[3][6]=max{<strong>c</strong>[2][6]，<strong>c</strong>[2][2]+5}=11；</li>
<li>j=7时，<strong>c</strong>[3][7]=max{<strong>c</strong>[2][7]，<strong>c</strong>[2][3]+5}=11；</li>
<li>j=8时，<strong>c</strong>[3][8]=max{<strong>c</strong>[2][8]，<strong>c</strong>[2][4]+5}=11；</li>
<li>j=9时，<strong>c</strong>[3][9]=max{<strong>c</strong>[2][9]，<strong>c</strong>[2][5]+5}=11；</li>
<li>j=10时，<strong>c</strong>[3][10]=max{<strong>c</strong>[2][10]，<strong>c</strong>[2][6]+5}=11。</li>
</ul>
<p>（4）按照递归式计算第1个物品（i=4）的处理情况，得到<strong>c</strong>[4][j]，j=1，2，…，W。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>
w[4]=2，v[4]=4，如图4-95所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/445.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-95　最大价值数组</b></center>
<ul>
<li>j=1时，<strong>c</strong>[4][1]=c[3][1]=0；</li>
<li>j=2时，<strong>c</strong>[4][2]=max{<strong>c</strong>[3][2]，<strong>c</strong>[3][0]+4}=6；</li>
<li>j=3时，<strong>c</strong>[4][3]=max{<strong>c</strong>[3][3]，<strong>c</strong>[3][1]+4}=6；</li>
<li>j=4时，<strong>c</strong>[4][4]=max{<strong>c</strong>[3][4]，<strong>c</strong>[3][2]+4}=10；</li>
<li>j=5时，<strong>c</strong>[4][5]=max{<strong>c</strong>[3][5]，<strong>c</strong>[3][3]+4}=10；</li>
<li>j=6时，<strong>c</strong>[4][6]=max{<strong>c</strong>[3][6]，<strong>c</strong>[3][4]+4}=11；</li>
<li>j=7时，<strong>c</strong>[4][7]=max{<strong>c</strong>[3][7]，<strong>c</strong>[3][5]+4}=11；</li>
<li>j=8时，<strong>c</strong>[4][8]=max{<strong>c</strong>[3][8]，<strong>c</strong>[3][6]+4}=15；</li>
<li>j=9时，<strong>c</strong>[4][9]=max{<strong>c</strong>[3][9]，<strong>c</strong>[3][7]+4}=15；</li>
<li>j=10时，<strong>c</strong>[4][10]=max{<strong>c</strong>[3][10]，<strong>c</strong>[3][8]+4}=15。</li>
</ul>
<p>（5）按照递归式计算第1个物品（i=5）的处理情况，得到<strong>c</strong>[5][j]，j=1，2，…，W。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>
w[5]=3，v[5]=6，如图4-96所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/446.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-96　最大价值数组</b></center>
<ul>
<li>j=1时，<strong>c</strong>[5][1]=<strong>c</strong>[4][1]=0；</li>
<li>j=2时，<strong>c</strong>[5][2]=<strong>c</strong>[4][2]=6；</li>
<li>j=3时，<strong>c</strong>[5][3]=max{<strong>c</strong>[4][3]，<strong>c</strong>[4][0]+6}=6；</li>
<li>j=4时，<strong>c</strong>[5][4]=max{<strong>c</strong>[4][4]，<strong>c</strong>[4][1]+6}=10；</li>
<li>j=5时，<strong>c</strong>[5][5]=max{<strong>c</strong>[4][5]，<strong>c</strong>[4][2]+6}=12；</li>
<li>j=6时，<strong>c</strong>[5][6]=max{<strong>c</strong>[4][6]，<strong>c</strong>[4][3]+6}=12；</li>
<li>j=7时，<strong>c</strong>[5][7]=max{<strong>c</strong>[4][7]，<strong>c</strong>[4][4]+6}=16；</li>
<li>j=8时，<strong>c</strong>[5][8]=max{<strong>c</strong>[4][8]，<strong>c</strong>[4][5]+6}=16；</li>
<li>j=9时，<strong>c</strong>[5][9]=max{<strong>c</strong>[4][9]，<strong>c</strong>[4][6]+6}=17；</li>
<li>j=10时，<strong>c</strong>[5][10]=max{<strong>c</strong>[4][10]，<strong>c</strong>[4][7]+6}=17。</li>
</ul>
<p>（6）构造最优解</p>
<p>首先读取<strong>c</strong>[5][10]&gt;<strong>c</strong>[4][10]，说明第5个物品装入了购物车，即x[5]=1，j=10−w[5]=7；</p>
<p>去找<strong>c</strong>[4][7]=<strong>c</strong>[3][7]，说明第4个物品没装入购物车，即x[4]=0；</p>
<p>去找<strong>c</strong>[3][7]&gt;<strong>c</strong>[2][7]，说明第3个物品装入了购物车，即x[3]=1，j= j−w[3]=3；</p>
<p>去找<strong>c</strong>[2][3]=<strong>c</strong>[1][3]，说明第2个物品没装入购物车，即x[2]=0；</p>
<p>去找<strong>c</strong>[1][3]&gt;<strong>c</strong>[0][3]，说明第1个物品装入了购物车，即x[1]=1，j= j−w[1]=1。</p>
<p>如图4-97所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/447.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-97　最大价值数组</b></center>
<h3 id="4-9-5-实战演练">4.9.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 105</span></span><br><span class="line"><span class="type">int</span> c[M][maxn];         <span class="comment">//c[i][j] 表示前i个物品放入容量为j购物车获得的最大价值</span></span><br><span class="line"><span class="type">int</span> w[M],v[M];          <span class="comment">//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值</span></span><br><span class="line"><span class="type">int</span> x[M];               <span class="comment">//x[i]表示第i个物品是否放入购物车</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">int</span> i,j,n,W;       <span class="comment">//n表示n个物品，W表示购物车的容量</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入物品的个数n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入购物车的容量W：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个物品的重量w和价值v，用空格分开：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)  <span class="comment">//初始化第0列为0</span></span><br><span class="line">          c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=W;j++)  <span class="comment">//初始化第0行为0</span></span><br><span class="line">          c[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;= n;i++) <span class="comment">//计算c[i][j]</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">               <span class="keyword">if</span>(j&lt;w[i])  <span class="comment">//当物品的重量大于购物车的容量，则不放此物品</span></span><br><span class="line">                    c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">               <span class="keyword">else</span>    <span class="comment">//否则比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">                    c[i][j] = max(c[i<span class="number">-1</span>][j],c[i<span class="number">-1</span>][j-w[i]] + v[i]);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的最大价值为：&quot;</span>&lt;&lt;c[n][W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//逆向构造最优解</span></span><br><span class="line">     j=W;</span><br><span class="line">     <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">          <span class="keyword">if</span>(c[i][j]&gt;c[i<span class="number">-1</span>][j])</span><br><span class="line">          &#123;</span><br><span class="line">               x[i]=<span class="number">1</span>;</span><br><span class="line">               j-=w[i];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               x[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的物品为：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">if</span>(x[i]==<span class="number">1</span>)</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现和测试</p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>Visual C++ 6.0</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入物品的个数n：<span class="number">5</span></span><br><span class="line">请输入购物车的容量W：<span class="number">10</span></span><br><span class="line">请依次输入每个物品的重量w和价值v，用空格分开：</span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入购物车的最大价值为：<span class="number">17</span></span><br><span class="line">装入购物车的物品为：<span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-9-6-算法解析及优化拓展">4.9.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-7">1．算法复杂度分析</h4>
<p>（1）时间复杂度：算法中有主要的是两层嵌套的for循环，其时间复杂度为O(n*W)。</p>
<p>（2）空间复杂度：由于二维数组<strong>c</strong>[n][W]，所以空间复杂度为O(n*W)。</p>
<h4 id="2．算法优化拓展-7">2．算法优化拓展</h4>
<p>如何实现优化改进呢？首先有一个主循环i=1，2，…，N，每次算出来二维数组<strong>c</strong>[i][0～W]的所有值。那么，如果只用一个数组dp[0～W]，能不能保证第i次循环结束后dp[j]中表示的就是我们定义的状态<strong>c</strong>[i][j]呢？<strong>c</strong>[i][j]由<strong>c</strong>[i−1][j]和<strong>c</strong>[i−1] [j−w[i]]两个子问题递推而来，能否保证在递推<strong>c</strong>[i][j]时（也即在第i次主循环中递推dp[j]时）能够得到<strong>c</strong>[i−1][j]和<strong>c</strong>[i−1][j−w[i]]的值呢？事实上，这要求在每次主循环中以j=W，W−1，…，1，0的顺序倒推dp[j]，这样才能保证递推dp[j]时dp[j−<strong>c</strong>[i]]保存的是状态<strong>c</strong>[i −1][j−w[i]]的值。</p>
<p>伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.n </span><br><span class="line"><span class="keyword">for</span> j=W.<span class="number">.0</span> </span><br><span class="line">       dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，dp[j]=max{dp[j]，dp[j−w[i]]}就相当于转移方程<strong>c</strong>[i][j]=max{<strong>c</strong>[i−1][j]，<strong>c</strong>[i−1][j− w[i]]}，因为这里的dp[j−w[i]]就相当于原来的<strong>c</strong>[i−1][j−w[i]]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-7-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 105</span></span><br><span class="line"><span class="type">int</span> dp[maxn];    <span class="comment">//dp[j] 表示当前已放入容量为j的购物车获得的最大价值</span></span><br><span class="line"><span class="type">int</span> w[M],v[M];   <span class="comment">//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值</span></span><br><span class="line"><span class="type">int</span> x[M];        <span class="comment">//x[i]表示第i个物品是否放入购物车</span></span><br><span class="line"><span class="type">int</span> i,j,n,W;     <span class="comment">//n表示n个物品，W表示购物车的容量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">opt1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=W;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">               <span class="keyword">if</span>(j&gt;=w[i])  <span class="comment">//当购物车的容量大于等于物品的重量，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">                  dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入物品的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入购物车的容量W:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个物品的重量w和价值v,用空格分开:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)<span class="comment">//初始化第0行为0</span></span><br><span class="line">          dp[j]=<span class="number">0</span>;</span><br><span class="line">     opt1(n,W);</span><br><span class="line">     <span class="comment">//opt2(n,W);</span></span><br><span class="line">     <span class="comment">//opt3(n,W);</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的最大价值为:&quot;</span>&lt;&lt;dp[W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//测试dp[]数组结果</span></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;dp[j]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实我们可以缩小范围，因为只有当购物车的容量大于等于物品的重量时才要更新（dp[j] = max（dp[j],dp[j−w[i]]+v[i]）），如果当购物车的容量小于物品的重量时，则保持原来的值（相当于原来的<strong>c</strong>[i−1][j]）即可。因此第2个for语句可以是for(j=W；j&gt;=w[i]；j−−)，而不必搜索到j=0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">opt2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;= n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=W;j&gt;=w[i];j--)</span><br><span class="line">               <span class="comment">//当购物车的容量大于等于物品的重量，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">               dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们还可以再缩小范围，确定搜索的下界bound，搜索下界取w[i]与剩余容量的最大值，sum[n] −sum[i−1]表示i～n的物品重量之和。W−（sum[n] −sum[i−1]）表示剩余容量。</p>
<p>因为只有购物车容量超过下界时才要更新（dp[j] = max（dp[j]，dp[j−w[i]]+v[i]）），如果购物车容量小于下界，则保持原来的值（相当于原来的<strong>c</strong>[i−1][j]）即可。因此第2个for语句可以是for(j=W；j&gt;=bound；j−−)，而不必搜索到j=0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">opt3</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> sum[n];<span class="comment">//sum[i]表示从1~i的物品重量之和</span></span><br><span class="line">      sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">           sum[i]=sum[i<span class="number">-1</span>]+w[i];</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> bound=max(w[i],W-(sum[n]-sum[i<span class="number">-1</span>]));<span class="comment">//搜索下界，w[i]与剩余容量取最大值,sum[n]-sum[i-1]表示从i...n的物品重量之和</span></span><br><span class="line">           <span class="keyword">for</span>(j=W;j&gt;=bound;j--)</span><br><span class="line">               <span class="comment">//购物车容量大于等于下界，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">               dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-10-快速定位——最优二叉搜索树">4.10　快速定位——最优二叉搜索树</h3>
<p>给定n个关键字组成的有序序列S={s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">n</sub>}，关键字结点称为实结点。对每个关键字查找的概率是p<sub class="my_markdown">i</sub>，查找不成功的结点称为虚结点，对应{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">n</sub>}，每个虚结点的查找概率为q<sub class="my_markdown">i</sub>。e<sub>0</sub>表示小于s<sub class="my_markdown">1</sub>的值，e<sub class="my_markdown">n</sub>大于s<sub class="my_markdown">n</sub>的值。所有结点查找概率之和为1。求最小平均比较次数的二叉搜索树（最优二叉搜索树）。</p>
<p>举例说明：给定一个有序序列S={5，9，12，15，20，24}，这些数的查找概率分别是p<sub class="my_markdown">1</sub>、p<sub>2</sub>、p<sub>3</sub>、p<sub>4</sub>、p<sub>5</sub>、p<sub>6</sub>。在实际中，有可能有查找不成功的情况，例如要在序列中查找x=2，那么我们就会定位在5的前面，查找不成功，相当于落在了虚结点e<sub>0</sub>的位置。要在序列中查找x=18，那么就会定位在15～20，查找不成功，相当于落在了虚结点e<sub>4</sub>的位置。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/448.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-98　查找关键字</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/449.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-99　快速定位</b></center>
<h3 id="4-10-1-问题分析">4.10.1　问题分析</h3>
<p>无论是查找成功还是查找不成功，都需要若干次比较才能判断出结果，那么如何查找才能使平均比较次数最小呢？</p>
<ul>
<li>如果使用顺序查找，能不能使平均查找次数最小呢？</li>
<li>因为序列是有序的，顺序查找有点笨，折半查找怎样呢？</li>
<li>折半查找是在查找概率相等的情况下折半的，查找概率不等的情况又如何呢？</li>
<li>在有序、查找概率不同的情况下，采用二叉搜索树能否使平均比较次数最小呢？</li>
<li>如何构建最优二叉搜索树？</li>
</ul>
<p>首先我们要了解二叉搜索树。</p>
<p>二叉搜索树（Binary Search Tree，BST），又称为二叉查找树，它是一棵二叉树（每个结点最多有两个孩子），而且左子树结点&lt;根结点，右子树结点&gt;根结点。</p>
<p>最优二叉搜索树（Optimal Binary Search Tree，OBST）是搜索成本最低的二叉搜索树，即平均比较次数最少。</p>
<p>例如，关键字{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub>6</sub>}的搜索概率是{p<sub class="my_markdown">1</sub>，p<sub>2</sub>，…，p<sub>6</sub>}，查找不成功的结点{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub>6</sub>}的搜索概率为{q<sub>0</sub>，q<sub class="my_markdown">1</sub>，…，q<sub>6</sub>}，其对应的数值如表4-2所示。</p>
<center class="my_markdown"><b class="my_markdown">表4-2　查找概率</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/450.jpg" alt="code"><br>
接下来，我们通过构建不同的二叉搜索树来分别看其搜索成本（平均比较次数)。</p>
<p>第1种二叉搜索树如图4-100所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/451.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-100　二叉搜索数树1</b></center>
<p>首先分析关键字结点的搜索成本，搜索每一个关键字需要 <strong>比较的次数是其所在的深度+1</strong> 。例如关键字5，需要比较1次（深度为0），查找成功；关键字12，需要首先和树根5比较，比5大，找其右子树，和右子树的根9比较，比9大，找其右子树，和右子树的根12比较，相等，查找成功，比较了3次（结点12的深度为2）。因此每个关键字结点的搜索成本=（结点的深度+1）*搜索概率=(depth(s<sub class="my_markdown">i</sub>)+1)*p<sub class="my_markdown">i</sub>。</p>
<p>我们再看虚结点，即查找不成功的情况的搜索成本，每一个虚结点需要 <strong>比较的次数是其所在的深度</strong> 。虚结点e<sub class="my_markdown">0</sub>需要比较1次（深度为1），即和数据5比较，如果小于5，则落入虚结点e<sub class="my_markdown">0</sub>位置，查找失败。虚结点e<sub>1</sub>需要比较2次（深度为2），需要首先和树根5比较，比5大，找其右子树，和右子树的根9比较，比9小，找其左子树，则落入虚结点e<sub>1</sub>位置，查找失败，比较了2次（虚结点e<sub>1</sub>的深度为2）。因此每个虚结点的搜索成本=结点的深度*搜索概率=(depth(e<sub class="my_markdown">i</sub>))*q<sub class="my_markdown">i</sub>。</p>
<p>二叉搜索树1的搜索成本为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/452.gif" alt="code"><br>
图4-100的搜索成本为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/453.gif" alt="code"><br>
接下来看第2个二叉搜索树，如图4-101所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/454.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-101　二叉搜索数树2</b></center>
<p>图4-101的搜索成本为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/455.gif" alt="code"><br>
第1个二叉搜索树相当于顺序查找（高度最大），第2个二叉搜索树相当于折半查找（平衡树)，我们再看第3个二叉搜索树，如图4-102所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/456.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-102　二叉搜索数树3</b></center>
<p>图4-102的搜索成本为：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/457.gif" alt="code"><br>
第3个图搜索成本又降到了2.52，有没有可能继续降低呢？</p>
<p>可能很多人会想到，搜索概率大的离根越近，那么总的成本就会更低，这其实就是哈夫曼思想。但是因为二叉搜索树需要满足（左子树&lt;根，右子树&gt;根）的性质，那么每次选取时就不能保证一定搜索概率大的结点。所以哈夫曼思想无法构建最优二叉搜索树。那么怎么找到最优解呢？我们很难确定目前得到的就是最优解，如果采用暴力穷举所有的情况，一共有O(4<sup class="my_markdown">n</sup>/n<sup>3/2</sup>)棵不同的二叉搜索树，这可是指数级的数量！显然是不可取的。</p>
<p>那么如何才能构建一棵最优二叉搜索树呢？</p>
<p>我们来分析该问题是否具有最优子结构性质：</p>
<p>（1）分析最优解的结构特征</p>
<ul>
<li>原问题为有序序列{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">n</sub>}，对应虚结点是{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">n</sub>}。假设我们已经知道了s<sub class="my_markdown">k</sub>是二叉搜索树T(1，n)的根，那么原问题就变成了两个子问题：{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">k</sub><sub>-1</sub>}和{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">k</sub><sub>−1</sub>}构成的左子树T(1，k−1)，{s<sub class="my_markdown">k</sub><sub>+1</sub>，s<sub class="my_markdown">k</sub><sub>+2</sub>，…，s<sub class="my_markdown">n</sub>}和{e<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub><sub>+1</sub>，…，e<sub class="my_markdown">n</sub>}构成的右子树T(k+1，n)。如图4-103所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/458.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-103　原问题分解为子问题</b></center>
<ul>
<li>我们只需要证明：如果T(1，n)是最优二叉搜索树，那么它的左子树T(1，k−1)和右子树T(k+1，n)也是最优二叉搜索树。即证明了最优子结构性质。</li>
</ul>
<p><strong>反证法：</strong> 假设T’ (1，k−1)是比T(1，k−1)更优的二叉搜索树，则T’(1，k−1)的搜索成本比T(1，k−1)的搜索成本小，因此由T’ (1，k−1)、s<sub class="my_markdown">k</sub>、T(k+1，n) 组成的二叉搜索树T’ (1，n)的搜索成本比T(1，n)的搜索成本小。T’ (1，n)是最优二叉搜索树，与假设T(1，n)是最优二叉搜索树矛盾。问题得证。</p>
<p>（2）建立最优值的递归式</p>
<p>先看看原问题最优解和子问题最优解的关系：用<strong>c</strong>[i][j]表示{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，…，s<sub class="my_markdown">j</sub>}和{e<sub class="my_markdown">i</sub><sub>−1</sub>，e<sub class="my_markdown">i</sub>，…，e<sub class="my_markdown">j</sub>}构成的最优二叉搜索树的搜索成本。</p>
<ul>
<li>两个子问题（如图4-104所示）的搜索成本分别是<strong>c</strong>[i][k−1]和<strong>c</strong>[k+1][j]。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/459.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-104　两个子问题</b></center>
<p>子问题1包含的结点：{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，…，s<sub class="my_markdown">k</sub><sub>−1</sub>}和{e <sub class="my_markdown">i</sub><sub>−1</sub>，e<sub class="my_markdown">i</sub>，…，e<sub class="my_markdown">k</sub><sub>−1</sub>}。</p>
<p>子问题2包含的结点：{s<sub class="my_markdown">k</sub><sub>+1</sub>，s<sub class="my_markdown">k</sub><sub>+2</sub>，…，s<sub class="my_markdown">j</sub>}和{e<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub><sub>+1</sub>，…，e<sub class="my_markdown">j</sub>}。</p>
<ul>
<li>把两个子问题和s<sub class="my_markdown">k</sub>一起构建成一棵二叉搜索树，如图4-105所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/460.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-105　原问题和子问题</b></center>
<p>在构建的新树中，左子树和右子树中所有的结点深度增加了1，因为实结点搜索成本=（深度+1）<em>搜索概率p，虚结点搜索成本=深度</em>搜索概率q。</p>
<p>左子树和右子树中所有的结点深度增加了1，相当于搜索成本 <strong>增加了</strong> 这些结点的搜索概率之和， <strong>加上</strong> s<sub class="my_markdown">k</sub>结点的搜索成本p<sub class="my_markdown">k</sub>，总的增加成本用<strong>w</strong>[i][j]表示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/461.jpg" alt="code"><br>
所有结点顺序排列一起：{e<sub class="my_markdown">i</sub><sub>−1</sub>，s<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>，…，s<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub>，…，s<sub class="my_markdown">j</sub>，e<sub class="my_markdown">j</sub>}，它们的概率之和为：</p>
<p><strong>w</strong>[i][j]=q<sub class="my_markdown">i</sub><sub>−1</sub>+p<sub class="my_markdown">i</sub>+q<sub class="my_markdown">i</sub>+…+ p<sub class="my_markdown">k</sub>+q<sub class="my_markdown">k</sub>+…+p<sub class="my_markdown">j</sub>+q<sub class="my_markdown">j</sub></p>
<p>最优二叉搜索树的搜索成本为：</p>
<p><strong>c</strong>[i][j]= <strong>c</strong>[i][k−1]+<strong>c</strong>[k+1][j]+ <strong>w</strong>[i][j]</p>
<p>因为我们并不确定k的值到底是多少，因此在<img class="my_markdown" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/462.gif" style="width:73px;  height: 17px; "/>的范围内找最小值即可。</p>
<p>（3）因此最优二叉搜索树的最优值递归式：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/463.gif" alt="code"><br>
<strong>w</strong>[i][j]也可以使用递推的形式，而没有必要每次都从q<sub class="my_markdown">i</sub><sub>-1</sub>加到q<sub class="my_markdown">j</sub>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/464.gif" alt="code"><br>
这同样也是动态规划的查表法。</p>
<h3 id="4-10-2-算法设计">4.10.2　算法设计</h3>
<p>采用自底向上的方法求最优解，分为不同规模的子问题，对于每一个小的决策都求最优</p>
<p>（1）确定合适的数据结构</p>
<p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T(i，j)的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T(i，j)中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T(i，j)的根节点序号。</p>
<p>（2）初始化</p>
<p>输入实结点的个数n，然后依次输入实结点的搜索概率存储在p[i]中，依次输入虚结点的搜索概率存储在q[i]中。令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i= 1，2，3，…，n+1。</p>
<p>（3）循环阶段</p>
<ul>
<li>按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n。</li>
<li>按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n−1。</li>
<li>以此类推，直到求出所有元素{s<sub class="my_markdown">1</sub>，…，s<sub class="my_markdown">n</sub>} 的最优二叉搜索树搜索成本<strong>c</strong>[1][n]和最优策略<strong>s</strong>[1][n]。</li>
</ul>
<p>（4）构造最优解</p>
<ul>
<li>首先读取<strong>s</strong>[1][n]，令k=<strong>s</strong>[1][n]，输出s<sub class="my_markdown">k</sub>为最优二叉搜索树的根。</li>
<li>判断如果k−1&lt;1，表示虚结点e<sub class="my_markdown">k</sub><sub>−1</sub>是s<sub class="my_markdown">k</sub>的左子树；否则，递归求解左子树Construct_ Optimal_BST(1,k−1,1)。</li>
<li>判断如果k<strong>≥</strong>n，输出虚结点e<sub class="my_markdown">k</sub>是s<sub class="my_markdown">k</sub>的右孩子；否则，输出<strong>s</strong>[k+1][n]是s<sub class="my_markdown">k</sub>的右孩子，递归求解右子树Construct_Optimal_BST(k+1，n，1)。</li>
</ul>
<h3 id="4-10-3-完美图解">4.10.3　完美图解</h3>
<p>假设我们现在有6个关键字{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">6</sub>}的搜索概率是{p<sub class="my_markdown">1</sub>，p<sub>2</sub>，…，p<sub class="my_markdown">6</sub>}，查找不成功的结点{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">6</sub>}的搜索概率为{q<sub>0</sub>，q<sub class="my_markdown">1</sub>，…，q<sub class="my_markdown">6</sub>}，其对应的数值如图4-106和图4-107所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/465.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-106　实结点的搜索概率</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/466.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-107　虚结点的搜索概率</b></center>
<p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T(i，j)的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T(i，j)中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T(i，j)的根节点序号，即取得最小值时的k值。</p>
<p>（1）初始化</p>
<p>n=6，令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i=1，2，3，…，n+1，如图4-108所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/467.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-108　概率之和以及最优二叉树搜索成本</b></center>
<p>（2）按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=1：k=1。</li>
</ul>
<p>为了形象表达，我们把虚结点和实结点的搜索概率按顺序放在一起，用圆圈和阴影部分表示<strong>w</strong>[][]，如图4-109所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/470.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-109　概率之和**w**[1][1]</b></center>
<p><strong>w</strong>[1][1]= <strong>w</strong>[1][0]+p<sub class="my_markdown">1</sub>+q<sub class="my_markdown">1</sub>=0.06+0.04+0.08=0.18；</p>
<p><strong>c</strong>[1][1]= min{<strong>c</strong>[1][0]，<strong>c</strong>[2][1] }+ <strong>w</strong>[1][1] =0.18；</p>
<p><strong>s</strong>[1][1]=1。</p>
<ul>
<li>i=2，j=2：k=2。如图4-110所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/471.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-110　概率之和**w**[2][2]</b></center>
<p><strong>w</strong>[2][2]= <strong>w</strong>[2][1]+p<sub class="my_markdown">2</sub>+q<sub class="my_markdown">2</sub>=0.08+0.09+0.10=0.27；</p>
<p><strong>c</strong>[2][2]= min{<strong>c</strong>[2][1]，<strong>c</strong>[3][2] }+ <strong>w</strong>[2][2] =0.27；</p>
<p><strong>s</strong>[2][2]=2。</p>
<ul>
<li>i=3，j=3：k=3。如图4-111所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/472.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-111　概率之和**w**[3][3]</b></center>
<p><strong>w</strong>[3][3]= <strong>w</strong>[3][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.10+0.08+0.07=0.25；</p>
<p><strong>c</strong>[3][3]= min{<strong>c</strong>[3][2]，<strong>c</strong>[4][3] }+ <strong>w</strong>[3][3] =0.25；</p>
<p><strong>s</strong>[3][3]=3。</p>
<ul>
<li>i=4，j=4：k=4。如图4-112所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/473.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-112　概率之和**w**[4][4]</b></center>
<p><strong>w</strong>[4][4]= <strong>w</strong>[4][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.07+0.02+0.05=0.14；</p>
<p><strong>c</strong>[1][1]= min{<strong>c</strong>[1][0]，<strong>c</strong>[2][1] }+ <strong>w</strong>[1][1] =0.14；</p>
<p><strong>s</strong>[4][4]=4。</p>
<ul>
<li>i=5，j=5：k=5。如图4-113所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/474.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-113　概率之和**w**[5][5]</b></center>
<p><strong>w</strong>[5][5]= <strong>w</strong>[5][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.05+0.12+0.05=0.22；</p>
<p><strong>c</strong>[5][5]= min{<strong>c</strong>[5][4]，<strong>c</strong>[6][5] }+ <strong>w</strong>[5][5] =0.22；</p>
<p><strong>s</strong>[5][5]=5。</p>
<ul>
<li>i=6，j=6：k=6。如图4-114所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/475.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-114　概率之和**w**[6][6]</b></center>
<p><strong>w</strong>[6][6]= <strong>w</strong>[6][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.05+0.14+0.10=0.29；</p>
<p><strong>c</strong>[6][6]= min{<strong>c</strong>[6][5]，<strong>c</strong>[7][6] }+ <strong>w</strong>[6][6] =0.29；</p>
<p><strong>s</strong>[6][6]=6。</p>
<p>计算完毕，概率之和以及最优二叉树搜索成本如图4-115所示。最优策略如图4-116所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/476.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-115　概率之和以及最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/477.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-116　最优二叉树的最优策略</b></center>
<p>（3）按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n−1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=2。如图4-117所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/478.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-117　概率之和**w**[1][2]</b></center>
<p><strong>w</strong>[1][2]= <strong>w</strong>[1][1]+p<sub class="my_markdown">2</sub>+q<sub class="my_markdown">2</sub>=0.18+0.09+0.10=0.37；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/479.gif" alt="code"><br>
<strong>s</strong>[1][2]=2。</p>
<ul>
<li>i=2，j=3。如图4-118所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/480.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-118　概率之和**w**[2][3]</b></center>
<p><strong>w</strong>[2][3]= <strong>w</strong>[2][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.27+0.08+0.07=0.42；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/481.gif" alt="code"><br>
<strong>s</strong>[2][3]=2。</p>
<ul>
<li>i=3，j=4。如图4-119所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/482.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-119　概率之和**w**[3][4]</b></center>
<p><strong>w</strong>[3][4]= <strong>w</strong>[3][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.25+0.02+0.05=0.32；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/483.gif" alt="code"><br>
<strong>s</strong>[3][4]=3。</p>
<ul>
<li>i=4，j=5。如图4-120所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/484.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-120　概率之和**w**[4][5]</b></center>
<p><strong>w</strong>[4][5]= <strong>w</strong>[4][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.14+0.12+0.05=0.31；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/485.gif" alt="code"><br>
<strong>s</strong>[4][5]=5。</p>
<ul>
<li>i=5，j=6。如图4-121所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/486.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-121　概率之和**w**[5][6]</b></center>
<p><strong>w</strong>[5][6]= <strong>w</strong>[5][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.22+0.14+0.10=0.46；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/487.gif" alt="code"><br>
<strong>s</strong>[5][6]=6。</p>
<p>计算完毕。概率之和以及最优二叉树搜索成本如图4-122所示，最优策略如图4-123所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/488.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-122　概率之和以及最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/489.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-123　最优策略</b></center>
<p>（4）按照递归式计算元素规模是3的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>}（j=i+2）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，4。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=3。如图4-124所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/490.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-124　概率之和**w**[1][3]</b></center>
<p><strong>w</strong>[1][3]= <strong>w</strong>[1][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.37+0.08+0.07=0.52；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/491.gif" alt="code"><br>
<strong>s</strong>[1][3]=2。</p>
<ul>
<li>i=2，j=4。如图4-125所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/492.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-125　概率之和**w**[2][4]</b></center>
<p><strong>w</strong>[2][4]= <strong>w</strong>[2][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.42+0.02+0.05=0.49；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/493.gif" alt="code"><br>
<strong>s</strong>[2][4]=3。</p>
<ul>
<li>i=3，j=5。如图4-126所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/494.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-126　概率之和**w**[3][5]</b></center>
<p><strong>w</strong>[3][5]= <strong>w</strong>[3][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.32+0.12+0.05=0.49；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/495.gif" alt="code"><br>
<strong>s</strong>[3][5]=3。</p>
<ul>
<li>i=4，j=6。如图4-127所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/496.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-127　概率之和**w**[4][6]</b></center>
<p><strong>w</strong>[4][6]= <strong>w</strong>[4][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.31+0.14+0.10=0.55；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/497.gif" alt="code"><br>
<strong>s</strong>[4][6]=5。</p>
<p>计算完毕。概率之和以及最优二叉树搜索成本如图4-128所示，最优策略如图4-129所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/498.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-128　概率之和以及最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/499.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-129　最优策略</b></center>
<p>（5）按照递归式计算元素规模是4的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>}（j=i+3）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=4。如图4-130所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/500.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-130　概率之和**w**[1][4]</b></center>
<p><strong>w</strong>[1][4]= <strong>w</strong>[1][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.52+0.02+0.05=0.59；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/501.gif" alt="code"><br>
<strong>s</strong>[1][4]=2。</p>
<ul>
<li>i=2，j=5。如图4-131所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/502.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-131　概率之和**w**[2][5]</b></center>
<p><strong>w</strong>[2][5]= <strong>w</strong>[2][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.49+0.12+0.05=0.66；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/503.gif" alt="code"><br>
<strong>s</strong>[2][5]=3。</p>
<ul>
<li>i=3，j=6。如图4-132所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/504.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-132　概率之和**w**[3][6]</b></center>
<p><strong>w</strong>[3][6]= <strong>w</strong>[3][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.49+0.14+0.10=0.73；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/505.gif" alt="code"><br>
<strong>s</strong>[3][6]=5。</p>
<p>计算完毕。概率之和以及最优二叉树搜索成本如图4-133所示，最优策略如图4-134所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/506.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-133　概率之和以及最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/507.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-134　最优策略</b></center>
<p>（6）按照递归式计算元素规模是5的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>，s<sub class="my_markdown">i</sub><sub>+4</sub>}（j=i+4）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=5。如图4-135所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/508.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-135　概率之和**w**[1][5]</b></center>
<p><strong>w</strong>[1][5]= <strong>w</strong>[1][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.59+0.12+0.05=0.76；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/509.gif" alt="code"><br>
<strong>s</strong>[1][5]=3。</p>
<ul>
<li>i=2，j=6。如图4-136所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/510.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-136　概率之和**w**[2][6]</b></center>
<p><strong>w</strong>[2][6]= <strong>w</strong>[2][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.66+0.14+0.10=0.90；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/511.gif" alt="code"><br>
<strong>s</strong>[2][6]=5。</p>
<p>计算完毕。概率之和以及最优二叉树搜索成本如图4-137所示，最优策略如图4-138所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/512.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-137　概率之和以及最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/513.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-138　最优策略</b></center>
<p>（7）按照递归式计算元素规模是6的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>，s<sub class="my_markdown">i</sub><sub>+4</sub>，s<sub class="my_markdown">i</sub><sub>+5</sub>}（j=i+5）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p>
<ul>
<li>i=1，j=6。如图4-139所示。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/514.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-139　概率之和**w**[1][6]</b></center>
<p><strong>w</strong>[1][6]= <strong>w</strong>[1][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.76+0.14+0.10=1.00；</p>
<p>；</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/515.gif" alt="code"><br>
<strong>s</strong>[1][6]=5。</p>
<p>计算完毕。概率之和以及最优二叉树搜索成本如图4-140所示，最优策略如图4-141所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/516.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-140　概率之和和最优二叉树搜索成本</b></center>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/517.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-141　最优决策</b></center>
<p>（8）构造最优解</p>
<ul>
<li>首先读取<strong>s</strong>[1][6]=5，k=5，输出s<sub class="my_markdown">5</sub>为最优二叉搜索树的根。</li>
</ul>
<p>判断如果k−1<strong>≥</strong>1，读取<strong>s</strong>[1][4]=2，输出s<sub class="my_markdown">2</sub>为s<sub>5</sub>的左孩子；递归求解左子树T（1，4）；判断如果k&lt;6，读取<strong>s</strong>[6][6]=6，输出s<sub>6</sub>为s<sub>5</sub>的右孩子；递归求解右子树T（6，6），如图4-142所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/518.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-142　最优解构造过程</b></center>
<ul>
<li>递归求解左子树T（1，4）。</li>
</ul>
<p>首先读取<strong>s</strong>[1][4]=2，k=2。</p>
<p>判断如果k−1<strong>≥</strong>1，读取<strong>s</strong>[1][1]=1，输出s<sub class="my_markdown">1</sub>为s<sub>2</sub>的左孩子；判断如果k&lt;4，读取<strong>s</strong>[3][4]=3，输出s<sub>3</sub>为s<sub>2</sub>的右孩子；递归求解右子树T（3，4），如图4-143所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/519.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-143　最优解构造过程</b></center>
<ul>
<li>递归求解左子树T（1，1）。</li>
</ul>
<p>首先读取<strong>s</strong>[1][1]=1，k=1。</p>
<p>判断如果k−1&lt;1，输出e<sub class="my_markdown">0</sub>为s<sub>1</sub>的左孩子；判断如果k<strong>≥</strong>1，输出e<sub>1</sub>为s<sub>1</sub>的右孩子，如图4-144所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/520.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-144　最优解构造过程</b></center>
<ul>
<li>递归求解右子树T（3，4）。</li>
</ul>
<p>首先读取<strong>s</strong>[3][4]=3，k=3。</p>
<p>判断如果k−1&lt;3，输出e<sub class="my_markdown">2</sub>为s<sub>3</sub>的左孩子；判断如果k&lt;4，读取<strong>s</strong>[4][4]=4，输出s<sub>4</sub>为s<sub>3</sub>的右孩子；递归求解右子树T（4，4），如图4-145所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/521.png" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-145　最优解构造过程</b></center>
<ul>
<li>递归求解右子树T（4，4）。</li>
</ul>
<p>首先读取<strong>s</strong>[4][4]=4，k=4。</p>
<p>判断如果k−1&lt;4，输出e<sub class="my_markdown">3</sub>为s<sub>4</sub>的左孩子；判断如果k<strong>≥</strong>4，输出e<sub>4</sub>为s<sub>4</sub>的右孩子，如图4-146所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/522.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-146　最优解构造过程</b></center>
<ul>
<li>递归求解右子树T（6，6）。</li>
</ul>
<p>首先读取<strong>s</strong>[6][6]=6，k=6。</p>
<p>判断如果k−1&lt;6，输出e<sub class="my_markdown">5</sub>为s<sub>6</sub>的左孩子；判断如果k<strong>≥</strong>6，输出e<sub>6</sub>为s<sub>6</sub>的右孩子，如图4-147所示。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/523.jpg" alt="code"></p>
<center class="my_markdown"><b class="my_markdown">图4-147　最优解构造过程</b></center>
<h3 id="4-10-4-伪代码详解">4.10.4　伪代码详解</h3>
<p>（1）构建最优二叉搜索树</p>
<p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T（i，j）的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T（i，j）中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T（i，j）的根节点序号。首先初始化，令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i= 1，2，3，…，n+1。按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，…，n。按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，…，n−1。以此类推，直到求出所有元素{s<sub>1</sub>，…，s<sub class="my_markdown">n</sub>} 的最优二叉搜索树搜索成本<strong>c</strong>[1][n]和最优策略<strong>s</strong>[1][n]。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)                 <span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               c[i][j]=c[i][i<span class="number">-1</span>]+c[i+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i;                  <span class="comment">//初始化</span></span><br><span class="line">               <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=j;k++) <span class="comment">//选取i+1到i之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较，fabs(temp-c[i][j])&gt;1E-6表示两者不相等</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;        <span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）构造最优解</p>
<p>Construct_Optimal_BST(int i,int j,bool flag)表示构建从结点i到结点j的最优二叉搜索树。首次调用时，flag=0、i=1、j=n，表示首次构建，读取的第一个数值<strong>s</strong>[1][n]为树根，其他递归调用flag=1。</p>
<p>Construct_Optimal_BST(int i,int j,bool flag)：首先读取<strong>s</strong>[i][j]，令k=<strong>s</strong>[i][j]，判断如果k−1&lt;i，表示虚结点e<sub class="my_markdown">k</sub><sub>−1</sub>是s<sub class="my_markdown">k</sub>的左子树；否则，递归求解左子树Construct_Optimal_BST(i，k−1，1)。判断如果k<strong>≥</strong>j，输出虚结点e<sub class="my_markdown">k</sub>是s<sub class="my_markdown">k</sub>的右孩子；否则，输出<strong>s</strong>[k+1][j]是s<sub class="my_markdown">k</sub>的右孩子，递归求解右子树Construct_Optimal_BST(k +1，j，1)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-10-5-实战演练">4.10.5　实战演练</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>                            <span class="comment">//求绝对值函数需要引入该头文件</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> c[M][M],w[M][M],p[M],q[M];</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line"><span class="type">int</span> n,i,j,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)                 <span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               c[i][j]=c[i][i<span class="number">-1</span>]+c[i+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i;                  <span class="comment">//初始化</span></span><br><span class="line">               <span class="comment">//选取i+1到j之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较，fabs(temp-c[i][j])&gt;1E-6表示两者不相等</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;<span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入关键字的个数n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入每个关键字的搜索概率：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个虚结点的搜索概率：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">      Optimal_BST();</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最小的搜索成本为：&quot;</span>&lt;&lt;c[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最优二叉搜索树为：&quot;</span>;</span><br><span class="line">      Construct_Optimal_BST(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>算法实现和测试</p>
<p>（1）运行环境</p>
<p>Code::Blocks</p>
<p>Visual C++ 6.0</p>
<p>（2）输入</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入关键字的个数n：<span class="number">6</span></span><br><span class="line">请依次输入每个关键字的搜索概率：</span><br><span class="line"><span class="number">0.04</span> <span class="number">0.09</span> <span class="number">0.08</span> <span class="number">0.02</span> <span class="number">0.12</span> <span class="number">0.14</span></span><br><span class="line">请依次输入每个虚结点的搜索概率：</span><br><span class="line"><span class="number">0.06</span> <span class="number">0.08</span> <span class="number">0.10</span> <span class="number">0.07</span> <span class="number">0.05</span> <span class="number">0.05</span> <span class="number">0.10</span></span><br></pre></td></tr></table></figure>
<p>（3）输出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">最小的搜索成本为：<span class="number">2.52</span></span><br><span class="line">最优二叉搜索树为：</span><br><span class="line">S5 是根</span><br><span class="line">S2 is the left child of S5</span><br><span class="line">S1 is the left child of S2</span><br><span class="line">e0 is the left child of S1</span><br><span class="line">e1 is the right child of S1</span><br><span class="line">S3 is the right child of S2</span><br><span class="line">e2 is the left child of S3</span><br><span class="line">S4 is the right child of S3</span><br><span class="line">e3 is the left child of S4</span><br><span class="line">e4 is the right child of S4</span><br><span class="line">S6 is the right child of S5</span><br><span class="line">e5 is the left child of S6</span><br><span class="line">e6 is the right child of S6</span><br></pre></td></tr></table></figure>
<h3 id="4-10-6-算法解析及优化拓展">4.10.6　算法解析及优化拓展</h3>
<h4 id="1．算法复杂度分析-8">1．算法复杂度分析</h4>
<p>（1）时间复杂度：算法中有3层嵌套的for循环，其时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p>
<p>（2）空间复杂度：使用了3个二维数组求解<strong>c</strong>[i][j]、<strong>w</strong>[i][j]、<strong>s</strong>[i][j]，所以空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p>
<h4 id="2．算法优化拓展-8">2．算法优化拓展</h4>
<p>如果按照普通的区间动态规划进行求解，时间复杂度是O(n<sup class="my_markdown">3</sup>)，但可以用四边形不等式优化。</p>
<p>!/524.gif)<br>
<strong>s</strong>[i][j]表示取得最优解<strong>c</strong>[i][j]的最优策略位置。</p>
<p>k的取值范围缩小了很多，原来是区间[i，j]，现在变为区间[<strong>s</strong>[i][j−1]，<strong>s</strong>[i+1][j]]。经过优化，算法时间复杂度可以减少至O(n<sup class="my_markdown">2</sup>)，时间复杂度的计算可参看4.8.6节。</p>
<p>优化后算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-8-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>           <span class="comment">//求绝对值函数需要引入该头文件</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> c[M][M],w[M][M],p[M],q[M];</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line"><span class="type">int</span> n,i,j,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)<span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               <span class="type">int</span> i1=s[i][j<span class="number">-1</span>]&gt;i?s[i][j<span class="number">-1</span>]:i;</span><br><span class="line">               <span class="type">int</span> j1=s[i+<span class="number">1</span>][j]&lt;j?s[i+<span class="number">1</span>][j]:j;</span><br><span class="line">               c[i][j]=c[i][i1<span class="number">-1</span>]+c[i1+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i1;<span class="comment">//初始化</span></span><br><span class="line">               <span class="comment">//选取i1+1到j1之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               <span class="keyword">for</span>(k=i1+<span class="number">1</span>;k&lt;=j1;k++)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;<span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入关键字的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入每个关键字的搜索概率:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个虚结点的搜索概率:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">     Optimal_BST();</span><br><span class="line">     <span class="comment">// /*用于测试</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; w[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; c[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; s[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">// */用于测试</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最小的搜索成本为：&quot;</span>&lt;&lt;c[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最优二叉搜索树为：&quot;</span>;</span><br><span class="line">     Construct_Optimal_BST(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-11-动态规划算法秘籍">4.11　动态规划算法秘籍</h3>
<p>本章通过8个实例讲解了动态规划的解题过程。动态规划求解最优化问题时需要考虑两个性质：最优子结构和子问题重叠。只要满足最优子结构性质就可以使用动态规划，如果还具有子问题重叠，则更能彰显动态规划的优势。判断可以使用动态规划后，就可以分析其最优子结构特征，找到原问题和子问题的关系，从而得到最优解递归式。然后按照最优解递归式自底向上求解，采用备忘机制（查表法）有效解决子问题重叠，重复的子问题不需要重复求解，只需查表即可。</p>
<p>动态规划的关键总结如下。</p>
<p>（1）最优子结构判定</p>
<ul>
<li>作出一个选择。</li>
<li>假定已经知道了哪种选择是最优的。</li>
</ul>
<p>例如矩阵连乘问题，我们假设已经知道在第k个矩阵加括号是最优的，即(<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>)(<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>)。</p>
<ul>
<li>最优选择后会产生哪些子问题。</li>
</ul>
<p>例如矩阵连乘问题，我们作出最优选择后产生两个子问题：(<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>)，(<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>)。</p>
<ul>
<li>证明原问题的最优解包含其子问题的最优解。</li>
</ul>
<p>通常使用“剪切—粘贴”反证法。证明如果原问题的解是最优解，那么子问题的解也是最优解。反证：假定子问题的解不是最优解，那么就可以将它“剪切”掉，把最优解“粘贴”进去，从而得到一个比原问题最优解更优的解，这与前提原问题的解是最优解矛盾。得证。</p>
<p>例如：矩阵连乘问题，c=a+b+d，我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</p>
<p><strong>反证法：</strong> 如果a不是最优的，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）存在一个最优解a’，a’&lt;a，那么，a’+b+d&lt;c，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。因此，矩阵连乘问题具有最优子结构性质。</p>
<p>（2）如何得到最优解递归式</p>
<ul>
<li>分析原问题最优解和子问题最优解的关系。</li>
</ul>
<p>例如矩阵连乘问题，我们假设已经知道在第k个矩阵加括号是最优的，即（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>） （<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）。作出最优选择后产生两个子问题：（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>），（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）。如果我们用<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优解，那么两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）对应的最优解分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]。剩下的只需要考查（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数了，两个结果矩阵相乘的乘法次数是p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。</p>
<p>因此，原问题最优解和子问题最优解的关系为<strong>m</strong>[i][j]=<strong>m</strong>[i][k]+<strong>m</strong>[k+1][j]+ p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。</p>
<ul>
<li>考查有多少种选择。</li>
</ul>
<p>实质上，我们并不知道哪种选择是最优的，因此就需要考查有多少种选择，然后从这些选择中找到最优解。</p>
<p>例如矩阵连乘问题，加括号的位置k（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>），k的取值范围是{i，i+1，…，j−1}，即i≤k&lt;j，那么我们考查每一种选择，找到最优值。</p>
<ul>
<li>得到最优解递归式。</li>
</ul>
<p>例如矩阵连乘问题，<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优解，根据最优解和子问题最优解的关系，并考查所有的选择，找到最小值即为最优解。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/525.gif" alt="code"></p>
</article><div class="post-copyright"><div class="post-copyright__title"><span class="post-copyright-info"><h>《趣学算法》——第四章（动态规则)</h></span></div><div class="post-copyright__type"><span class="post-copyright-info"><a href="https://drie.cn/posts/f36a1c64.html">https://drie.cn/posts/f36a1c64.html</a></span></div><div class="post-copyright-m"><div class="post-copyright-m-info"><div class="post-copyright-a"><h>作者</h><div class="post-copyright-cc-info"><h>Drie🦋</h></div></div><div class="post-copyright-c"><h>发布于</h><div class="post-copyright-cc-info"><h>2024-07-04</h></div></div><div class="post-copyright-u"><h>更新于</h><div class="post-copyright-cc-info"><h>2024-07-04</h></div></div><div class="post-copyright-c"><h>许可协议</h><div class="post-copyright-cc-info"><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a rel="noopener" target="_blank" title="CC BY-NC-SA 4.0" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a></div></div></div></div></div><div class="tag_share"><div class="post-meta__tag-list"></div></div><link rel="stylesheet" href="/css/coin.css" media="defer" onload="this.media='all'"/><div class="post-reward"><button class="tip-button reward-button"><span class="tip-button__text">投喂作者</span><div class="coin-wrapper"><div class="coin"><div class="coin__middle"></div><div class="coin__back"></div><div class="coin__front"></div></div></div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://drie.cn/donate/simple/images/WeChanSQ.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/donate/simple/images/WeChanSQ.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://drie.cn/donate/simple/images/AliPayQR.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/donate/simple/images/AliPayQR.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></button></div><audio id="coinAudio" src="https://source.drie.cn/badge/aowu.m4a"></audio><script defer="defer" src="/js/coin.js"></script><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/8f61c33e.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/177.png" onerror="onerror=null;src='/assets/r2.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《趣学算法》—第三章（分治法）</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><svg class="meta_icon" style="width:22px;height:22px;position:relative;top:5px"><use xlink:href="#icon-mulu1"></use></svg><span style="font-weight:bold">目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">第四章  动态规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E7%A5%9E%E5%A5%87%E7%9A%84%E5%85%94%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">4.1　神奇的兔子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80"><span class="toc-text">4.2　动态规划基础</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-text">4.2.1　算法思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E7%AE%97%E6%B3%95%E8%A6%81%E7%B4%A0"><span class="toc-text">4.2.2　算法要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%A7%A3%E9%A2%98%E7%A7%98%E7%B1%8D"><span class="toc-text">4.2.3　解题秘籍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AD%A9%E5%AD%90%E6%9C%89%E5%A4%9A%E5%83%8F%E7%88%B8%E7%88%B8%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E7%9A%84%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97"><span class="toc-text">4.3　孩子有多像爸爸——最长的公共子序列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.3.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.3.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.3.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.3.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.3.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.3.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-DNA%E5%9F%BA%E5%9B%A0%E9%89%B4%E5%AE%9A%E2%80%94%E2%80%94%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB"><span class="toc-text">4.4　DNA基因鉴定——编辑距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.4.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.4.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.4.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.4.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.4.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.4.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-2"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-2"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E9%95%BF%E6%B1%9F%E4%B8%80%E6%97%A5%E6%B8%B8%E2%80%94%E2%80%94%E6%B8%B8%E8%89%87%E7%A7%9F%E8%B5%81"><span class="toc-text">4.5　长江一日游——游艇租赁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.5.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.5.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.5.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.5.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.5.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.5.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-3"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-3"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E5%BF%AB%E9%80%9F%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98"><span class="toc-text">4.6　快速计算——矩阵连乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.6.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.6.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.6.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.6.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.6.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.6.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-4"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-4"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E5%88%87%E5%91%80%E5%88%87%E6%8A%AB%E8%90%A8%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E4%B8%89%E8%A7%92%E5%89%96%E5%88%86"><span class="toc-text">4.7　切呀切披萨——最优三角剖分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.7.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.7.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.7.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.7.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.7.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.7.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-5"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-5"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-%E5%B0%8F%E7%9F%B3%E5%AD%90%E6%B8%B8%E6%88%8F%E2%80%94%E2%80%94%E7%9F%B3%E5%AD%90%E5%90%88%E5%B9%B6"><span class="toc-text">4.8　小石子游戏——石子合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.8.1　问题分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E8%B7%AF%E8%BE%B9%E7%8E%A9%E6%B3%95"><span class="toc-text">1．路边玩法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%93%8D%E5%9C%BA%E7%8E%A9%E6%B3%95"><span class="toc-text">2．操场玩法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.8.2　算法设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E8%B7%AF%E8%BE%B9%E7%8E%A9%E6%B3%95-2"><span class="toc-text">1．路边玩法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E6%93%8D%E5%9C%BA%E7%8E%A9%E6%B3%95-2"><span class="toc-text">2．操场玩法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.8.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.8.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.8.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.8.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-6"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-6"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-%E5%A4%A7%E5%8D%96%E5%9C%BA%E8%B4%AD%E7%89%A9%E8%BD%A61%E2%80%94%E2%80%940-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98"><span class="toc-text">4.9　大卖场购物车1——0-1背包问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.9.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.9.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.9.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.9.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.9.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-7"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-7"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-%E5%BF%AB%E9%80%9F%E5%AE%9A%E4%BD%8D%E2%80%94%E2%80%94%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">4.10　快速定位——最优二叉搜索树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-text">4.10.1　问题分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1"><span class="toc-text">4.10.2　算法设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-3-%E5%AE%8C%E7%BE%8E%E5%9B%BE%E8%A7%A3"><span class="toc-text">4.10.3　完美图解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-4-%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-text">4.10.4　伪代码详解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-5-%E5%AE%9E%E6%88%98%E6%BC%94%E7%BB%83"><span class="toc-text">4.10.5　实战演练</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-6-%E7%AE%97%E6%B3%95%E8%A7%A3%E6%9E%90%E5%8F%8A%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95"><span class="toc-text">4.10.6　算法解析及优化拓展</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1%EF%BC%8E%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-8"><span class="toc-text">1．算法复杂度分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%EF%BC%8E%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96%E6%8B%93%E5%B1%95-8"><span class="toc-text">2．算法优化拓展</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E7%A7%98%E7%B1%8D"><span class="toc-text">4.11　动态规划算法秘籍</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-color: transparent;"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>再看看那个光点，它就在这里，这是家园，这是我们 —— 你所爱的每一个人，你认识的一个人，你听说过的每一个人，曾经有过的每一个人，都在它上面度过他们的一生✨</div><div class="btn-xz-box"><a class="btn-xz" target="_blank" rel="noopener" href="https://stellarium.org/">点击开启星辰之旅</a></div></div></div><div class="t-t-r"><p class="ft-t t-l-t">猜你想看💡</p><ul class="ft-links"><li><a href="/posts/eec9786.html">魔改指南</a><a href="/box/nav/">网址导航</a></li><li><a href="/social/link/">我的朋友</a><a href="/comments/">留点什么</a></li><li><a href="/personal/about/">关于作者</a><a href="/archives/">文章归档</a></li><li><a href="/categories/">文章分类</a><a href="/tags/">文章标签</a></li><li><a href="/box/Gallery/">我的画廊</a><a href="/personal/bb/">我的唠叨</a></li><li><a href="/site/time/">建设进程</a><a href="/site/census/">网站统计</a></li></ul></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="https://drie.cn/" title="drie🦋"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://drie.cn/img/avatar.gif" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div><div class="img-group-item"><a href="javascript:void(0)" title="广告位招租"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://lskypro.acozycotage.net/LightPicture/2022/12/65307a5828af6790.webp" alt=""/></a></div></div></div></div><div class="copyright"><span><b>&copy;2023-2024</b></span><span><b>&nbsp;&nbsp;By Drie🦋</b></span></div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo_v6.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Frame-Hexo-blue.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly_v4.3.1"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Theme-Butterfly-6513df.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://vercel.com/" style="margin-inline:5px" title="本站采用多线部署，主线路托管于Vercel"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Hosted-Vercel-brightgreen.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://user.51.la/" style="margin-inline:5px" title="本站数据分析得益于51la技术支持"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/Analytics-51la-3db1eb.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://icp.gov.moe/?keyword=20246897" style="margin-inline:5px" title="本站已加入萌ICP豪华套餐，萌ICP备20246897号"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/萌ICP备-20246897-fe1384.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://bitiful.dogecast.com/buckets" style="margin-inline:5px" title="本网站经Service Worker分流至缤纷云对象存储"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://source.drie.cn/badge/Bucket-缤纷云-9c62da.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://www.netdun.net/" style="margin-inline:5px" title="本站使用网盾星球提供CDN加速与防护"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/badge/CDN-网盾星球-fff2cc.svg" alt=""/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" title="本网站源码由Github提供存储仓库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=" https://source.drie.cn/badge/Source-Github-d021d6.svg" alt=""/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><a class="icon-V hidden" onclick="switchNightMode()" title="浅色和深色模式转换"><svg width="25" height="25" viewBox="0 0 1024 1024"><use id="modeicon" xlink:href="#icon-moon"></use></svg></a><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button><button class="share" type="button" title="右键模式" onclick="changeMouseMode()"><i class="fas fa-mouse"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog right_side"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button class="share" type="button" title="分享链接" onclick="share()"><i class="fas fa-share-nodes"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><span id="percent">0<span>%</span></span></button><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.baidu.com/s?wd=&quot;+window.getSelection().toString());window.location.reload();"><i class="fa fa-search"></i><span>百度搜索</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-post"><a class="rightMenu-item" href="#post-comment"><i class="fas fa-comment"></i><span>空降评论</span></a><a class="rightMenu-item" href="javascript:rmf.copyWordsLink()"><i class="fa fa-link"></i><span>复制本文地址</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:randomPost()"><i class="fa fa-paper-plane"></i><span>随便逛逛</span></a><a class="rightMenu-item" href="javascript:switchNightMode();"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="/personal/about/"><i class="fa fa-info-circle"></i><span>关于博客</span></a><a class="rightMenu-item" href="javascript:toggleWinbox();"><i class="fas fa-cog"></i><span>美化设置</span></a><a class="rightMenu-item" href="javascript:rmf.fullScreen();"><i class="fas fa-expand"></i><span>切换全屏</span></a><a class="rightMenu-item" href="javascript:window.print();"><i class="fa-solid fa-print"></i><span>打印页面</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://source.drie.cn/js/fancybox.umd.min.js"></script><script src="https://source.drie.cn/js/instantpage.min.js" type="module"></script><script src="https://source.drie.cn/js/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script async="async">var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())
setTimeout(function(){preloader.endLoading();}, 5000);
document.getElementById('loading-box').addEventListener('click',()=> {preloader.endLoading()})</script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [ ['$','$'], ["\\(","\\)"]],
      tags: 'ams'
    },
    chtml: {
      scale: 1.2
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, ''],
        insertScript: [200, () => {
          document.querySelectorAll('mjx-container:not\([display]\)').forEach(node => {
            const target = node.parentNode
            if (target.nodeName.toLowerCase() === 'li') {
              target.parentNode.classList.add('has-jax')
            } else {
              target.classList.add('has-jax')
            }
          });
        }, '', false]
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typeset()
}</script><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://twikoo.drie.cn/',
      region: '',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://twikoo.drie.cn/',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.staticfile.org/twikoo/1.6.8/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://source.drie.cn/js/jquery.min.js"></script><script async src="https://source.drie.cn/js/vue.min.js"></script><script async src="https://source.drie.cn/js/index.js"></script><script async src="https://source.drie.cn/js/clipboard.min.js"></script><script defer type="text/javascript" src="https://source.drie.cn/js/sweetalert2.all.js"></script><script async src="https://source.drie.cn/js/pace.min.js"></script><script defer src="https://source.drie.cn/js/winbox.bundle.min.js"></script><script async src="https://source.drie.cn/js/font_3586335_hsivh70x0fm.js"></script><script async src="https://source.drie.cn/js/font_3636804_gr02jmjr3y9.js"></script><script async src="https://source.drie.cn/js/font_3612150_kfv55xn3u2g.js"></script><script async src="https://source.drie.cn/js/Gold-ingot.js"></script><canvas id="universe"></canvas><canvas id="snow"></canvas><script defer src="/js/drie.js"></script><link rel="stylesheet" href="https://source.drie.cn/js/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://source.drie.cn/js/APlayer.min.js"></script><script src="https://source.drie.cn/js/Meting.min.js"></script><script src="https://source.drie.cn/js/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show","#web_bg",".js-pjax","#bibi","body > title","#app","#tag-echarts","#posts-echart","#categories-echarts"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://drie.cn/categories/算法/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍡 小Dの算法学习笔记 (4)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://drie.cn/categories/演示/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍥 小Dの案例演示笔记 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="https://drie.cn/categories/" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(33.333333333333336% - 5px);background: #e9e9e9;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: var(--text-bg-hover)}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/f36a1c64.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/312.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-04</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/f36a1c64.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》——第四章（动态规则)</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/f36a1c64.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/177.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-03</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》—第三章（分治法）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/8f61c33e.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/105.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-02</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》——第二章（贪心算法）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/7177a99d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/img/default_cover_16.webp" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">Markdown语法与外挂标签写法汇总</a><div class="blog-slider__text">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/2013454d.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt=""><img width="48" height="48" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://source.drie.cn/qxsf-images/60.png" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2024-07-01</span><a class="blog-slider__title" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt="">《趣学算法》——第一章（算法之美）</a><div class="blog-slider__text">再怎么看我也不知道怎么描述它的啦！</div><a class="blog-slider__button" onclick="pjax.loadUrl(&quot;posts/87ab2347.html&quot;);" href="javascript:void(0);" alt="">详情       </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = '/';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://source.drie.cn/js/swiper.min.js"></script><script defer data-pjax src="https://source.drie.cn/js/swiper_init.js"></script><div class="js-pjax"><script async="async">var arr = document.getElementsByClassName('recent-post-item');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script><script async="async">var arr = document.getElementsByClassName('card-widget');
for(var i = 0;i<arr.length;i++){
    arr[i].classList.add('wow');
    arr[i].classList.add('animate__zoomIn');
    arr[i].setAttribute('data-wow-duration', '2s');
    arr[i].setAttribute('data-wow-delay', '200ms');
    arr[i].setAttribute('data-wow-offset', '30');
    arr[i].setAttribute('data-wow-iteration', '1');
  }</script></div><script defer src="https://source.drie.cn/js/wow.min.js"></script><script defer src="https://source.drie.cn/js/wow_init.js"></script><script data-pjax src="https://source.drie.cn/js/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('gitZone');
      var item_html = '<div class="recent-post-item" id="gitcalendarBar" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 320px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('gitZone') && (location.pathname ==='/site/census/'|| '/site/census/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("/api?null",['#d9e0df', '#c6e0dc', '#a8dcd4', '#9adcd2', '#89ded1', '#77e0d0', '#5fdecb', '#47dcc6', '#39dcc3', '#1fdabe', '#00dab9'],'null')
    }
  </script><!-- hexo injector body_end end --></body></html>