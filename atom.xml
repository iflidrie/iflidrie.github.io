<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Drie🦋</title>
  
  
  <link href="https://drie.cn/atom.xml" rel="self"/>
  
  <link href="https://drie.cn/"/>
  <updated>2024-07-04T03:27:11.918Z</updated>
  <id>https://drie.cn/</id>
  
  <author>
    <name>Drie🦋</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《趣学算法》——第四章（动态规则)</title>
    <link href="https://drie.cn/posts/f36a1c64.html"/>
    <id>https://drie.cn/posts/f36a1c64.html</id>
    <published>2024-07-04T02:16:25.000Z</published>
    <updated>2024-07-04T03:27:11.918Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第四章-动态规划">第四章  动态规划</h3><p>前面讲的分治法是将原问题分解为若干个规模较小、形式相同的子问题，然后求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，那么用分治法就重复求解了很多子问题，根本显现不了分治的优势，反而降低了算法效率。那该怎么办呢？</p><p>动态规划闪亮登场了！</p><h3 id="4-1-神奇的兔子序列">4.1　神奇的兔子序列</h3><p>公元1202年，意大利数学家列昂纳多•斐波那契（Leonardo Fibonacci）在《算盘全书》（Liber Abaci）中描述了一个神奇的兔子序列，这就是著名的斐波那契序列。</p><p>假设第1个月有1对刚诞生的兔子，第2个月进入成熟期，第3个月开始生育兔子，而1对成熟的兔子每月会生1对兔子，兔子永不死去……那么，由1对初生兔子开始，12个月后会有多少对兔子呢？如果是N对初生的兔子开始，M月后又会有多少对兔子呢？</p><p>第1个月，兔子①没有繁殖能力，所以还是 <strong>1</strong> 对。</p><p>第2个月，兔子①进入成熟期，仍然是 <strong>1</strong> 对。</p><p>第3个月，兔子①生了1对小兔②，于是这个月共有2对（ <strong>1+1=2</strong> ）兔子。</p><p>第4个月，兔子①又生了1对小兔③。兔子②进入成熟期。共有3对（ <strong>1+2=3</strong> ）兔子。</p><p>第5个月，兔子①又生了1对小兔④，兔子②也生下了1对小兔⑤。兔子③进入成熟期。共有5对（ <strong>2+3=5</strong> ）兔子。</p><p>第6个月，兔子①②③各生下了1对小兔。兔子④⑤进入成熟期。新生3对兔子加上原有的5对兔子，这个月共有8对（ <strong>3+5=8</strong> ）兔子。</p><p>……</p><p>这个数列有十分明显的特点，从第3个月开始，当月的兔子数=上月兔子数+本月新生小兔子数，而本月新生的兔子正好是上上月的兔子数，即当月的兔子数=前两月兔子之和。</p><p><img src="https://source.drie.cn/qxsf-images/279.gif" alt="code"><br>我们仅以F(6)为例，如图4-1所示。</p><p><img src="https://source.drie.cn/qxsf-images/280.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-1　F(6)的递归树</b></center><p>从图4-1可以看出，有大量的结点重复（子问题重叠），F(4)、F(3)、F(2)、F(1)均重复计算多次。</p><h3 id="4-2-动态规划基础">4.2　动态规划基础</h3><p>动态规划是1957年理查德•贝尔曼在《Dynamic Programming》一书中提出来的，可能有的读者不知道这个人，但他的一个算法你可能听说过，他和莱斯特•福特一起提出了求解最短路径的Bellman-Ford 算法，该算法解决了Dijkstra算法不能处理的负权值边的问题。</p><p>《Dynamic Programming》中的“Programming”不是编程的意思，而是指一种表格处理法。我们把每一步得到的子问题结果存储在表格里，每次遇到该子问题时不需要再求解一遍，只需要查询表格即可。</p><h3 id="4-2-1-算法思想">4.2.1　算法思想</h3><p>动态规划也是一种分治思想，但与分治算法不同的是，分治算法是把原问题分解为若干子问题，自顶向下求解各子问题，合并子问题的解，从而得到原问题的解。动态规划也是把原问题分解为若干子问题，然后自底向上，先求解最小的子问题，把结果存储在表格中，再求解大的子问题时，直接从表格中查询小的子问题的解，避免重复计算，从而提高算法效率。</p><h3 id="4-2-2-算法要素">4.2.2　算法要素</h3><p>什么问题可以使用动态规划呢？我们首先要分析问题是否具有以下两个性质：</p><p>（1）最优子结构</p><p>最优子结构性质是指问题的最优解包含其子问题的最优解。最优子结构是使用动态规划的最基本条件，如果不具有最优子结构性质，就不可以使用动态规划解决。</p><p>（2）子问题重叠</p><p>子问题重叠是指在求解子问题的过程中，有大量的子问题是重复的，那么只需要求解一次，然后把结果存储在表中，以后使用时可以直接查询，不需要再次求解。子问题重叠不是使用动态规划的必要条件，但问题存在子问题重叠更能够充分彰显动态规划的优势。</p><h3 id="4-2-3-解题秘籍">4.2.3　解题秘籍</h3><p>遇到一个实际问题，如何采用动态规划来解决呢？</p><p>（1）分析最优解的结构特征。</p><p>（2）建立最优值的递归式。</p><p>（3）自底向上计算最优值，并记录。</p><p>（4）构造最优解。</p><p>以神奇的兔子序列问题为例。</p><p>（1）分析最优解的结构特征</p><p>我们通过分析发现，前两个月都是1对兔子，而从第3个月开始，当月的兔子数等于前两个月的兔子数，如果把每个月的兔子数看作一个最小的子问题，那么求解第n个月的兔子数，包含了第n−1个月的兔子数和第n−2个月的兔子数这两个子问题。</p><p>（2）根据最优解结构特征，建立递归式</p><p><img src="https://source.drie.cn/qxsf-images/279.gif" alt="code"><br>（3)自底向上计算最优值</p><p>看到递归式，我们也很难立即求解F(n)，如果直接递归调用将会产生大量的子问题重复，那怎么办呢？动态规划提供了一个好办法，自底向上求解，记录结果，重复的问题只需求解一次即可，如图4-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/281.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-2　F(6)的递归树自底向上求解</b></center><p>例如：</p><p>F(1)=1</p><p>F(2)=1</p><p>F(3)= F(2)+F(1)=2</p><p>F(4)= F(3)+F(2)=3</p><p>F(5)= F(4)+F(3)=5</p><p>F(6)= F(5)+F(4)=8</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Fib2</span><span class="params">(<span class="type">int</span> n)</span> </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> F[n+<span class="number">1</span>];</span><br><span class="line">  F[<span class="number">1</span>]=<span class="number">1</span>；</span><br><span class="line">  F[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">      F[i]=F[i<span class="number">-1</span>]+F[i<span class="number">-2</span>];</span><br><span class="line">  <span class="keyword">return</span> F[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）构造最优解</p><p>本题中自底向上求解到树根就是我们要的最优解。</p><p>在众多的算法中，很多读者觉得动态规划是比较难的算法，为什么呢？难在递归式！</p><p>很多复杂问题，很难找到相应的递归式。实际上，一旦得到递归式，那算法就已经实现了99%，剩下的程序实现就非常简单了。那么后面的例子就重点讲解遇到一个问题怎么找到它的递归式。</p><p>蛇打三寸，一招致命。</p><h3 id="4-3-孩子有多像爸爸——最长的公共子序列">4.3　孩子有多像爸爸——最长的公共子序列</h3><p>假设爸爸对应的基因序列为X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}，孩子对应的基因序列Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，那么怎么找到他们有多少相似的基因呢？</p><p>如果按照严格递增的顺序，从爸爸的基因序列X中取出一些值，组成序列Z={x<sub class="my_markdown">i</sub><sub>1</sub>，x<sub class="my_markdown">i</sub><sub>2</sub>，x<sub class="my_markdown">i</sub><sub>3</sub>，…，x<sub class="my_markdown">ik</sub>}，其中下标{i<sub>1</sub>，i<sub>2</sub>，i<sub>3</sub>，…，i<sub class="my_markdown">k</sub> }是一个严格递增的序列。那么就说Z是X的子序列，Z中元素的个数就是该子序列的长度。</p><p>X和Y的公共子序列是指该序列既是X的子序列，也是Y的子序列。</p><p>最长公共子序列问题是指：给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的一个最长的公共子序列。</p><p><img src="https://source.drie.cn/qxsf-images/282.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-3　人类基因序列</b></center><h3 id="4-3-1-问题分析">4.3.1　问题分析</h3><p>给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的一个最长的公共子序列。</p><p>例如：X=（A，B，C，B，A，D，B），Y=（B，C，B，A，A，C），那么最长公共子序列是B，C，B，A。</p><p>如何找到最长公共子序列呢？</p><p>如果使用暴力搜索方法，需要穷举X的所有子序列，检查每个子序列是否也是Y的子序列，记录找到的最长公共子序列。X的子序列有2<sup class="my_markdown">m</sup>个，因此暴力求解的方法时间复杂度为指数阶，这是我们避之不及的爆炸性时间复杂度。</p><p>那么能不能用动态规划算法呢？</p><p>下面分析该问题是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><p>假设已经知道Z<sub class="my_markdown">k</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub>}是X<sub class="my_markdown">m</sub>={x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y<sub class="my_markdown">n</sub>={y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}的最长公共子序列。这个假设很重要，我们都是这样假设已经知道了最优解。</p><p>那么可以分3种情况讨论。</p><ul><li>x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>= z<sub class="my_markdown">k</sub>：那么Z<sub><em>k</em>−1</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub><sub>−1</sub>}是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，如图4-4所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/283.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-4　最长公共子序列</b></center><p><strong>反证法证明</strong>  <strong>：</strong> 如果Z<sub class="my_markdown">k</sub><sub>−1</sub>={z<sub>1</sub>，z<sub>2</sub>，z<sub>3</sub>，…，z<sub class="my_markdown">k</sub><sub>−1</sub>}不是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub><sub>−1</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub><sub>−1</sub>|。如果在X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的后面添加一个相同的字符x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>，则z<sub class="my_markdown">k</sub>=x<sub class="my_markdown">m</sub>=y<sub class="my_markdown">n</sub>，|M+{z<sub class="my_markdown">k</sub>}|&gt;|Z<sub class="my_markdown">k</sub><sub>−1</sub>+{z<sub class="my_markdown">k</sub>}|=|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p><ul><li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>，x<sub class="my_markdown">m</sub>≠ z<sub class="my_markdown">k</sub>：我们可以把x<sub class="my_markdown">m</sub>去掉，那么Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，如图4-5所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/284.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-5　最长公共子序列</b></center><p><strong>反证法证明：</strong> 如果Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub><sub>−1</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub>|。如果我们在X<sub class="my_markdown">m</sub><sub>−1</sub>的后面添加一个字符x<sub class="my_markdown">m</sub>，那么M也是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，因为|M|&gt;|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p><ul><li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>，y<sub class="my_markdown">n</sub>≠ z<sub class="my_markdown">k</sub>：我们可以把y<sub class="my_markdown">n</sub>去掉，那么Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，如图4-6所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/285.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-6　最长公共子序列</b></center><p><strong>反证法证明：</strong> 如果Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，那么它们一定存在一个最长公共子序列。设M为X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub><sub>−1</sub>的最长公共子序列，M的长度大于Z<sub class="my_markdown">k</sub>的长度，即|M|&gt;|Z<sub class="my_markdown">k</sub>|。如果我们在Y<sub class="my_markdown">n</sub><sub>−1</sub>的后面添加一个字符y<sub class="my_markdown">n</sub>，那么M也是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，因为|M|&gt;|Z<sub class="my_markdown">k</sub>|，那么Z<sub class="my_markdown">k</sub>不是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列，这与假设Z<sub class="my_markdown">k</sub>是X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列矛盾，问题得证。</p><p>（2）建立最优值的递归式。</p><p>设<strong>c</strong>[i][j]表示X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最长公共子序列长度。</p><ul><li>x<sub class="my_markdown">m</sub>= y<sub class="my_markdown">n</sub>= z<sub class="my_markdown">k</sub>：那么<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1；</li><li>x<sub class="my_markdown">m</sub>≠y<sub class="my_markdown">n</sub>：那么我们只需要求解X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最长公共子序列和X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最长公共子序列，比较它们的长度哪一个更大，就取哪一个值。即<strong>c</strong>[i][j]= max{<strong>c</strong>[i][j−1], <strong>c</strong>[i−1][j]}。</li><li>最长公共子序列长度递归式：</li></ul><p><img src="https://source.drie.cn/qxsf-images/286.jpg" alt="code"><br>（3)底向上计算最优值，并记录最优值和最优策略</p><p>i=1时：{x<sub class="my_markdown">1</sub>}和{y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>i=2时：{x<sub class="my_markdown">2</sub>}和{y<sub>1</sub>，y<sub class="my_markdown">2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>……</p><p>i=m时：{x<sub class="my_markdown">m</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录最长公共子序列长度。</p><p>（4）构造最优解</p><p>上面的求解过程只是得到了最长公共子序列长度，并不知道最长公共子序列是什么，那怎么办呢？</p><p>例如，现在已经求出<strong>c</strong>[m][n]=5，表示X<sub class="my_markdown">m</sub>和Y<sub class="my_markdown">n</sub>的最长公共子序列长度是5，那么这个5是怎么得到的呢？我们可以反向追踪5是从哪里来的。根据递推式，有如下情况。</p><p>x<sub class="my_markdown">i</sub>= y<sub class="my_markdown">j</sub>时：<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1；</p><p>x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>时：<strong>c</strong>[i][j]= max{<strong>c</strong>[i][j−1], <strong>c</strong>[i−1][j]}；</p><p>那么<strong>c</strong>[i][j]的来源一共有3个：<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1，<strong>c</strong>[i][j]= <strong>c</strong>[i][j−1]，<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j]。在第3步自底向上计算最优值时，用一个辅助数组<strong>b</strong> [i][j]记录这3个来源：</p><p><strong>c</strong>[i][j]= <strong>c</strong>[i−1][j−1]+1，<strong>b</strong>[i][j]=1；</p><p><strong>c</strong>[i][j]= c[i][j−1]，<strong>b</strong>[i][j]=2；</p><p><strong>c</strong>[i][j]= c[i−1][j]，<strong>b</strong>[i][j]=3。</p><p>这样就可以根据<strong>b</strong>[m][n]反向追踪最长公共子序列，当<strong>b</strong>[i][j]=1时，输出x<sub class="my_markdown">i</sub>；当<strong>b</strong> [i][j]=2时，追踪<strong>c</strong>[i][j−1]；当<strong>b</strong>[i][j]=3时，追踪<strong>c</strong>[i−1][j]，直到i=0或j=0停止。</p><h3 id="4-3-2-算法设计">4.3.2　算法设计</h3><p>最长公共子序列问题满足动态规划的最优子结构性质，可以自底向上逐步得到最优解。</p><p>（1）确定合适的数据结构</p><p>采用二维数组<strong>c</strong>[][]来记录最长公共子序列的长度，二维数组<strong>b</strong>[][]来记录最长公共子序列的长度的来源，以便算法结束时倒推求解得到该最长公共子序列。</p><p>（2）初始化</p><p>输入两个字符串s<sub class="my_markdown">1</sub>、s<sub>2</sub>，初始化<strong>c</strong>[][]第一行第一列元素为0。</p><p>（3）循环阶段</p><ul><li>i = 1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li></ul><p>如果s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[j−1]，<strong>c</strong>[i][j] = <strong>c</strong>[i−1][j−1]+1；并记录最优策略来源<strong>b</strong>[i][j]=1；</p><p>如果s<sub class="my_markdown">1</sub>[0] ≠s<sub>2</sub>[j−1]，则公共子序列的长度为<strong>c</strong>[i][j−1]和<strong>c</strong>[i−1][j]中的最大值，如果<strong>c</strong>[i][j−1]≥<strong>c</strong>[i−1][j]，则<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，最优策略来源<strong>b</strong>[i][j]=2；否则<strong>c</strong>[i][j]= <strong>c</strong>[i−1][j]，最优策略来源<strong>b</strong>[i][j]=3。</p><ul><li>i = 2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li><li>以此类推，直到i &gt; len1时，算法结束，这时<strong>c</strong>[len1][len2]就是最长公共序列的长度。</li></ul><p>（4）构造最优解</p><p>根据最优决策信息数组<strong>b</strong>[][]递归构造最优解，即输出最长公共子序列。因为我们在求最长公共子序列长度<strong>c</strong>[i][j]的过程中，用<strong>b</strong>[i][j]记录了<strong>c</strong>[i][j]的来源，那么就可以根据<strong>b</strong>[i][j]数组倒推最优解。</p><p>如果<strong>b</strong>[i][j]=1，说明s<sub class="my_markdown">1</sub>[i−1]=s<sub>2</sub>[j−1]，那么就可以递归求解print(i−1, j−1)；然后输出s<sub class="my_markdown">1</sub>[i−1]。</p><p><strong>注意：</strong> 如果先输出，后递归求解print(i−1,j−1)，则输出的结果是倒序。</p><p>如果<strong>b</strong>[i][j]=2，说明s<sub class="my_markdown">1</sub>[i−1]≠s<sub>2</sub>[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，递归求解print(i, j−1)。</p><p>如果<strong>b</strong>[i][j]=3，说明s<sub class="my_markdown">1</sub>[i−1]≠s<sub>2</sub>[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i−1][j]，递归求解print(i−1, j)。当i==0 || j==0时，递归结束。</p><h3 id="4-3-3-完美图解">4.3.3　完美图解</h3><p>以字符串s<sub class="my_markdown">1</sub>=“ABCADAB”，s<sub>2</sub>=“BACDBA”为例。</p><p>（1）初始化</p><p>len1=7，len2=6，初始化<strong>c</strong>[][]第一行、第一列元素为0，如图4-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/287.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-7　**c**[][]初始化</b></center><p>（2）i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“A”与“BACDBA”分别比较一次。</p><p>如果字符相等，<strong>c</strong>[i][j]取左上角数值加1，记录最优值来源<strong>b</strong>[i][j]=1。</p><p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果<strong>c</strong>[i][j]的值来源于左侧<strong>b</strong>[i][j]=2，来源于上面<strong>b</strong>[i][j]=3。</p><ul><li>j=1：A≠B，左侧=上面，取左侧数值，<strong>c</strong>[1][1]= 0，最优策略来源<strong>b</strong>[1][1]=2，如图4-8所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/288.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-8　最长公共子序列求解过程</b></center><ul><li>j=2：A=A，则取左上角数值加1，<strong>c</strong>[1][2]= <strong>c</strong>[0][1]+1=2，最优策略来源<strong>b</strong>[1][2] =1，如图4-9所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/289.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-9　最长公共子序列求解过程</b></center><ul><li>j=3：A≠C，左侧≥上面，取左侧数值，<strong>c</strong>[1][3]= 1，最优策略来源<strong>b</strong>[1][3] =2，如图4-10所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/290.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-10　最长公共子序列求解过程</b></center><ul><li>j= 4：A≠D，左侧≥上面，取左侧数值，<strong>c</strong>[1][4]= 1，最优策略来源<strong>b</strong>[1][4] =2，如图4-11所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/291.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-11　最长公共子序列求解过程</b></center><ul><li>j=5：A≠B，左侧≥上面，取左侧数值，<strong>c</strong>[1][5]=1，最优策略来源<strong>b</strong>[1][5]=2，如图4-12所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/292.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-12　最长公共子序列求解过程</b></center><ul><li>j=6：A=A，则取左上角数值加1，<strong>c</strong>[1][6]=1，最优策略来源<strong>b</strong>[1][6]=1，如图4-13所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/293.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-13　最长公共子序列求解过程</b></center><p>（3）i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“B”与“BACDBA”分别比较一次。</p><p>如果字符相等，<strong>c</strong>[i][j]取左上角数值加1，记录最优值来源<strong>b</strong>[i][j]=1。</p><p>如果字符不等，取左侧和上面数值中的最大值。如果左侧和上面数值相等，默认取左侧数值。如果<strong>c</strong>[i][j]的值来源于左侧<strong>b</strong>[i][j]=2，来源于上面<strong>b</strong>[i][j]=3，如图4-14所示。</p><p><img src="https://source.drie.cn/qxsf-images/294.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-14　最长公共子序列求解过程</b></center><p>（4）继续处理i=2，3，…，len1：s<sub class="my_markdown">1</sub>[i−1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。处理结果如图4-15所示。</p><p><img src="https://source.drie.cn/qxsf-images/295.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-15　最长公共子序列求解结果</b></center><p><strong>c</strong>[][]右下角的值即为最长公共子序列的长度。<strong>c</strong>[7][6]=4，即字符串s<sub class="my_markdown">1</sub>=“ABCADAB”，s<sub>2</sub>=“BACDBA”的最长公共子序列的长度为4。</p><p>那么最长公共子序列包含哪些字符呢？</p><p>（5）构造最优解</p><p>首先读取<strong>b</strong>[7][6]=2，说明来源为2，向左找<strong>b</strong>[7][5]；</p><p><strong>b</strong>[7][5]=1，向左上角找<strong>b</strong>[6][4]，返回时输出s[6]=“B”；</p><p><strong>b</strong>[6][4]=3，向上找<strong>b</strong>[5][4]；</p><p><strong>b</strong>[5][4]=1，向左上角找<strong>b</strong>[4][3]，返回时输出s[4]=“D”；</p><p><strong>b</strong>[4][3]=2，向左找<strong>b</strong>[4][2]；</p><p><strong>b</strong>[4][2]=1，向左上角找<strong>b</strong>[3][1]，返回时输出s[3]=“C”；</p><p><strong>b</strong>[3][1]=3，向上找<strong>b</strong>[2][1]；</p><p><strong>b</strong>[2][1]=1，向左上角找，返回时输出s[1]=“B”；</p><p><strong>b</strong>[1][0]中列为0，算法停止，返回，输出最长公共子序列为BCDB，如图4-16所示。</p><p><img src="https://source.drie.cn/qxsf-images/296.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-16　最长公共子序列构造最优解</b></center><h3 id="4-3-4-伪代码详解">4.3.4　伪代码详解</h3><p>（1）最长公共子序列求解函数</p><p>首先计算两个字符串的长度，然后从i=1开始，s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>中的每一个字符比较。</p><p>如果当前字符相同，则公共子序列的长度为<strong>c</strong>[i−1][j−1]+1，并记录最优策略来源<strong>b</strong>[i][j] = 1。</p><p>如果当前字符不相同，则公共子序列的长度为<strong>c</strong>[i][j−1]和<strong>c</strong>[i−1][j]中的最大值，如果<strong>c</strong>[i][j−1]≥<strong>c</strong>[i−1][j]，则最优策略来源<strong>b</strong>[i][j]=2；如果<strong>c</strong>[i][j−1]&lt;<strong>c</strong>[i−1][j]，则最优策略来源<strong>b</strong>[i][j]=3。直到i&gt; len1时，算法结束，这时<strong>c</strong>[len1][len2]就是我们要的最长公共序列长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">LCSL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> I,j;</span><br><span class="line">    <span class="keyword">for</span>(I = <span class="number">1</span>;I &lt;= len1;i++)    <span class="comment">//控制s1序列</span></span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= len2;j++)  <span class="comment">//控制s2序列</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>])    <span class="comment">//字符下标从0开始</span></span><br><span class="line">        &#123;   <span class="comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span></span><br><span class="line">            c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            b[i][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i][j<span class="number">-1</span>]&gt;=c[i<span class="number">-1</span>][j]) <span class="comment">//两者找最大值，并记录最优策略来源</span></span><br><span class="line">            &#123;</span><br><span class="line">                  c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">                  b[i][j] = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                  c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">                  b[i][j] = <span class="number">3</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）最优解输出函数</p><p>输出最优解仍然使用倒推法。因为我们在求最长公共子序列长度<strong>c</strong>[i][j]的过程中，用<strong>b</strong>[i][j]记录了<strong>c</strong>[i][j]的来源，那么就可以根据<strong>b</strong>[i][j]数组倒推最优解。</p><p>如果<strong>b</strong>[i][j]=1，说明s1[i−1]=s2[j−1]，那么我们就可以递归输出print(i−1，j−1)；然后输出s1[i−1]。</p><p>如果<strong>b</strong>[i][j]=2，说明s1[i−1]≠s2[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i][j−1]，递归输出print(i，j−1)。</p><p>如果<strong>b</strong>[i][j]=3，说明s1[i−1]≠s2[j−1]且最优解来源于<strong>c</strong>[i][j]=<strong>c</strong>[i−1][j]，递归输出print(i−1，j)。当i==0||j==0时，递归结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Void <span class="title function_">print</span><span class="params">(<span class="type">int</span> I, <span class="type">int</span> j)</span><span class="comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(b[i][j]==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        print(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;s1[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">2</span>)</span><br><span class="line">              print(I,j<span class="number">-1</span>);</span><br><span class="line">          <span class="keyword">else</span> print(i<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-5-实战演练">4.3.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line">*ons tint N=<span class="number">1002</span>;</span><br><span class="line"><span class="type">int</span> c[N][N],b[N][N];</span><br><span class="line"><span class="type">char</span> s1[N],s2[N];</span><br><span class="line"><span class="type">int</span> len1,len2;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LCSL</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> I,j;</span><br><span class="line">     <span class="keyword">for</span>(I = <span class="number">1</span>;I &lt;= len1;i++)<span class="comment">//控制s1序列</span></span><br><span class="line">       <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= len2;j++)<span class="comment">//控制s2序列</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span>(s1[i<span class="number">-1</span>]==s2[j<span class="number">-1</span>])</span><br><span class="line">         &#123;<span class="comment">//如果当前字符相同，则公共子序列的长度为该字符前的最长公共序列+1</span></span><br><span class="line">             c[i][j] = c[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">             b[i][j] = <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="keyword">if</span>(c[i][j<span class="number">-1</span>]&gt;=c[i<span class="number">-1</span>][j])</span><br><span class="line">             &#123;</span><br><span class="line">                  c[i][j] = c[i][j<span class="number">-1</span>];</span><br><span class="line">                  b[i][j] = <span class="number">2</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">else</span></span><br><span class="line">             &#123;</span><br><span class="line">                  c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">                  b[i][j] = <span class="number">3</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> I, <span class="type">int</span> j)</span><span class="comment">//根据记录下来的信息构造最长公共子序列（从b[i][j]开始递推）</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">     <span class="keyword">if</span>(b[i][j]==<span class="number">1</span>)</span><br><span class="line">     &#123;</span><br><span class="line">         print(i<span class="number">-1</span>,j<span class="number">-1</span>);</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;s1[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span>(b[i][j]==<span class="number">2</span>)</span><br><span class="line">               print(I,j<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">               print(i<span class="number">-1</span>,j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> I,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串s1：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; s1;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串s2：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; s2;</span><br><span class="line">     len1 = <span class="built_in">strlen</span>(s1);<span class="comment">//计算两个字符串的长度</span></span><br><span class="line">     len2 = <span class="built_in">strlen</span>(s2); </span><br><span class="line">     <span class="keyword">for</span>(I = <span class="number">0</span>;I &lt;= len1;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][<span class="number">0</span>]=<span class="number">0</span>;<span class="comment">//初始化第一列为0</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt;= len2;j++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[<span class="number">0</span>][j]=<span class="number">0</span>;<span class="comment">//初始化第一行为0</span></span><br><span class="line">     &#125;</span><br><span class="line">     LCSL();   <span class="comment">//求解最长公共子序列</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1和s2的最长公共子序列长度是：&quot;</span>&lt;&lt;c[len1][len2]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1和s2的最长公共子序列是：&quot;</span>;</span><br><span class="line">     print(len1,len2);   <span class="comment">//递归构造最长公共子序列最优解</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现和测试</p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入字符串s1：</span><br><span class="line">ABCADAB</span><br><span class="line">输入字符串s2：</span><br><span class="line">BACDBA</span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s1和s2的最长公共子序列长度是：<span class="number">4</span></span><br><span class="line">s1和s2的最长公共子序列是：BADB</span><br></pre></td></tr></table></figure><h3 id="4-3-6-算法解析及优化拓展">4.3.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析">1．算法复杂度分析</h4><p>（1）时间复杂度：由于每个数组单元的计算耗费Ο(1)时间，如果两个字符串的长度分别是m、n，那么算法时间复杂度为Ο(m*n)。</p><p>（2）空间复杂度：空间复杂度主要为两个二维数组<strong>c</strong>[][]，<strong>b</strong>[][]，占用的空间为O(m*n)。</p><h4 id="2．算法优化拓展">2．算法优化拓展</h4><p>因为<strong>c</strong>[i][j]有3种来源：<strong>c</strong>[i−1][j−1]+1、<strong>c</strong>[i][j−1]、<strong>c</strong>[i−1][j]。我们可以利用<strong>c</strong>数组本身来判断来源于哪个值，从而不用<strong>b</strong>[][]，这样可以节省O(m<em>n)个空间。但因为<strong>c</strong>数组还是O(m</em>n)个空间，所有空间复杂度数量级仍然是O(m*n)，只是从常数因子上的改进。仍然是倒推的办法，如图4-17所示，读者可以想一想怎么做？</p><p><img src="https://source.drie.cn/qxsf-images/297.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-17　最长公共子序列构造最优解（不用辅助数组）</b></center><h3 id="4-4-DNA基因鉴定——编辑距离">4.4　DNA基因鉴定——编辑距离</h3><p>我们经常会听说DNA亲子鉴定是怎么回事呢？人类的DNA由4个基本字母{A，C，G，T}构成，包含了多达30亿个字符。如果两个人的DNA序列相差0.1%，仍然意味着有300万个位置不同，所以我们通常看到的DNA亲子鉴定报告上结论有：相似度99.99%，不排除亲子关系。</p><p>怎么判断两个基因的相似度呢？生物学上给出了一种编辑距离的概念。</p><p>例如两个字符串FAMILY和FRAME，有两种对齐方式：</p><p>F　 -　 A　M　I　L　Y　　　　　　 -　 F　 A　M　I　L　Y</p><p>F　 R　A　M　E　　　　　　　　　 F　 R　 A　M　E</p><p>第1种对齐需要付出的代价：4，插入R，将I替换为E，删除L、Y。</p><p>第2种对齐需要付出的代价：5，插入R，将F替换为R，将I替换为E，删除L、Y。</p><p>编辑距离是指将一个字符串变换为另一个字符串所需要的最小编辑操作。</p><p>怎么找到两个字符串x[1，…，m]和y[1，…，n]的编辑距离呢？</p><p><img src="https://source.drie.cn/qxsf-images/298.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-18　DNA基因鉴定</b></center><h3 id="4-4-1-问题分析">4.4.1　问题分析</h3><p>编辑距离是指将一个字符串变换为另一个字符串所需要的最小编辑操作。</p><p>给定两个序列X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}，找出X和Y的编辑距离。</p><p>例如：X=（A，B，C，D，A，B），Y=（B，D，C，A，B）。如果用穷举法，会有很多种对齐方式，暴力穷举的方法是不可取的。那么怎么找到编辑距离呢？</p><p>首先考虑能不能把原问题变成规模更小的子问题，如果可以，那就会容易得多。</p><p>要求两个字符串X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">m</sub>}和Y={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}的编辑距离，那么可以求其前缀X<sub class="my_markdown">i</sub>={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和Y<sub class="my_markdown">j</sub>={y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离，当i=m，j=n时就得到了所有字符的编辑距离。</p><p>那么能不能用动态规划算法呢？</p><p>下面我们分析该问题是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><p>假设已经知道<strong>d</strong>[i][j]是X<sub class="my_markdown">i</sub>={x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和Y<sub class="my_markdown">j</sub>={y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离最优解。这个假设很重要，我们都是这样假设已经知道了最优解。</p><p>那么两个序列无论怎么对齐，其右侧只可能有如下3种对齐方式：</p><ul><li>如图4-19所示。需要删除x<sub class="my_markdown">i</sub>，付出代价1，那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub><sub>−1</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub>}的编辑距离再加1即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1。<strong>d</strong>[i−1][j]是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最优解。</li></ul><p><img src="https://source.drie.cn/qxsf-images/299.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-19　编辑距离对齐方式</b></center><p><strong>反证法证明：</strong> 设<strong>d</strong>[i−1][j]不是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub>的最优解，那么它们一定存在一个最优解<strong>d’</strong>，<strong>d’</strong>&lt;<strong>d</strong>[i−1][j]。如果在X<sub class="my_markdown">i</sub><sub>−1</sub>的后面添加一个字符x<sub class="my_markdown">i</sub>，<strong>d’</strong>+1也是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解，因为<strong>d’</strong>+1&lt;<strong>d</strong>[i−1][j]+1=<strong>d</strong>[i][j]，所以<strong>d</strong>[i][j]不是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解，这与假设<strong>d</strong>[i][j]是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的最优解矛盾，问题得证。</p><ul><li>如图4-20所示。需要插入y<sub class="my_markdown">j</sub>，付出代价1，那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub><sub>−1</sub>}的编辑距离再加1即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1。<strong>d</strong>[i][j−1]是X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最优解。</li></ul><p><img src="https://source.drie.cn/qxsf-images/300.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-20　编辑距离对齐方式</b></center><p>同理可证。</p><ul><li>如图4-21所示。如果x<sub class="my_markdown">i</sub>=y<sub class="my_markdown">j</sub>，付出代价0，如果x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>，需要替换，付出代价1，我们用函数<strong>diff</strong>(i，j)来表达，x<sub class="my_markdown">i</sub>=y<sub class="my_markdown">j</sub>时，<strong>diff</strong>(i，j)=0；x<sub class="my_markdown">i</sub>≠y<sub class="my_markdown">j</sub>时，<strong>diff</strong>(i，j)=1。那么我们只需要求解子问题{x<sub>1</sub>，x<sub>2</sub>，x<sub>3</sub>，…，x<sub class="my_markdown">i</sub><sub>−1</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">j</sub><sub>−1</sub>}的编辑距离再加<strong>diff</strong>(i，j)即可，即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+ <strong>diff</strong>(i，j)。<strong>d</strong>[i−1][j−1]是X<sub class="my_markdown">i</sub><sub>−1</sub>和Y<sub class="my_markdown">j</sub><sub>−1</sub>的最优解。</li></ul><p><img src="https://source.drie.cn/qxsf-images/301.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-21　编辑距离对齐方式</b></center><p>同理可证。</p><p>（2）建立最优值递归式</p><p>设<strong>d</strong>[i][j]表示X<sub class="my_markdown">i</sub>和Y<sub class="my_markdown">j</sub>的编辑距离，则<strong>d</strong>[i][j]取以上三者对齐方式的最小值。</p><p>编辑距离递归式：</p><p><img src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>（3)自底向上计算最优值，并记录最优值和最优策略</p><p>i=1时：{x<sub class="my_markdown">1</sub>}和{y<sub class="my_markdown">1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p><p>i=2时：{x<sub class="my_markdown">2</sub>}和{y<sub>1</sub>，y<sub class="my_markdown">2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p><p>……</p><p>i=m时：{x<sub class="my_markdown">m</sub>}和{y<sub>1</sub>，y<sub>2</sub>，y<sub>3</sub>，…，y<sub class="my_markdown">n</sub>}中的字符一一比较，按递归式求解并记录编辑距离。</p><p>（4）构造最优解</p><p>如果仅仅需要知道编辑距离是多少，上面的求解过程得到的编辑距离就是最优值。如果还想知道插入、删除、替换了哪些字母，就需要从<strong>d</strong>[i][j]表格中倒推，输出这些结果。</p><h3 id="4-4-2-算法设计">4.4.2　算法设计</h3><p>编辑距离问题满足动态规划的最优子结构性质，可以自底向上逐渐推出整体最优解。</p><p>（1）确定合适的数据结构</p><p>采用二维数组<strong>d</strong>[][]来记录编辑距离。</p><p>（2）初始化</p><p>输入两个字符串s<sub class="my_markdown">1</sub>、s<sub>2</sub>，初始化<strong>d</strong>[][]第一行为0，1，2，…，len2，第一列元素为0，1，2，…，len1。</p><p>（3）循环阶段</p><ul><li>i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li></ul><p>如果s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[j−1]，<strong>diff</strong>[i][j] = 0。</p><p>如果s<sub class="my_markdown">1</sub>[0] ≠s<sub>2</sub>[j−1]，则<strong>diff</strong>[i][j] =1。</p><p><img src="https://source.drie.cn/qxsf-images/302.gif" alt="code"></p><ul><li>i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。</li><li>以此类推，直到i &gt;len1时，算法结束，这时<strong>d</strong>[len1][len2]就是我们要的最优解。</li></ul><p>（4）构造最优解</p><p>从<strong>d</strong>[i][j]表格中倒推，输出插入、删除、替换了哪些字母。在此没有使用辅助数组，采用判断的方式倒推。</p><h3 id="4-4-3-完美图解">4.4.3　完美图解</h3><p>以字符串s<sub class="my_markdown">1</sub>=” FAMILY”，s<sub>2</sub>=” FRAME”为例。</p><p>（1）初始化</p><p>len1=6，len2=5，初始化<strong>d</strong>[][]第一行为0，1，2，…，5，第一列元素为0，1，2，…，6，如图4-22所示。</p><p><img src="https://source.drie.cn/qxsf-images/303.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-22　编辑距离求解初始化</b></center><p>（2）i=1：s<sub class="my_markdown">1</sub>[0]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“F”与“FRAME”分别比较一次。</p><p>如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j] = 1。按照递归公式：</p><p><img src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>即取上面+1，左侧+1，左上角数值加<strong>diff</strong>[i][j]3个数当中的最小值，相等时取后者。</p><ul><li>j=1：F=F，<strong>diff</strong>[1][1]=0，左上角数值加<strong>diff</strong>[1][1]=0，左侧+1=上面+1=2，3个数当中的最小值，<strong>d</strong>[1][1] =0，如图4-23所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/304.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-23　编辑距离求解过程</b></center><ul><li>j=2：F≠R，<strong>diff</strong>[1][2]=1，左上角数值加<strong>diff</strong>[1][2]=2，左侧+1=1，上面+1=3，取3个数当中的最小值，<strong>d</strong>[1][2] =1，如图4-24所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/305.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-24　编辑距离求解过程</b></center><ul><li>j=3：F≠A，<strong>diff</strong>[1][3]=1，左上角数值加<strong>diff</strong>[1][3]=3，左侧+1=2，上面+1=4，取3个数当中的最小值，<strong>d</strong>[1][3] =2，如图4-25所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/306.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-25　编辑距离求解过程</b></center><ul><li>j=4：F≠M：<strong>diff</strong>[1][4]=1，左上角数值加<strong>diff</strong>[1][4]=4，左侧+1=3，上面+1=5，取3个数当中的最小值，<strong>d</strong>[1][4] =3，如图4-26所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/307.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-26　编辑距离求解过程</b></center><ul><li>j=5：F≠E，<strong>diff</strong>[1][5]=1，左上角数值加<strong>diff</strong>[1][5]=5，左侧+1=4，上面+1=6，取3个数当中的最小值，<strong>d</strong>[1][5] =4，如图4-27所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/308.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-27　编辑距离求解过程</b></center><p>（3）i=2：s<sub class="my_markdown">1</sub>[1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2。即“A”与“FRAME”分别比较一次。</p><p>如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j] = 1。按照递归公式：</p><p><img src="https://source.drie.cn/qxsf-images/302.gif" alt="code"><br>即取上面+1，左侧+1，左上角数值加<strong>diff</strong>[i][j]3个数当中的最小值，相等时取后者。</p><p>填写完毕，如图4-28所示。</p><p><img src="https://source.drie.cn/qxsf-images/309.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-28　编辑距离求解过程</b></center><p>（4）继续处理i=2，3，…，len1：s<sub class="my_markdown">1</sub>[i−1]与s<sub>2</sub>[j−1]比较，j=1，2，3，…，len2，处理结果如图4-29所示。</p><p><img src="https://source.drie.cn/qxsf-images/310.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-29　编辑距离求解结果</b></center><p>（5）构造最优解</p><p>从右下角开始，逆向查找<strong>d</strong>[i][j]的来源： <strong>上面</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1）表示需要删除， <strong>左侧</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1）表示需要插入， <strong>左上角</strong> （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+<strong>diff</strong>[i][j]）要判断是否字符相等，如果不相等则需要替换，如果字符相等什么也不做，如图4-30所示。为什么是这样呢？不清楚的读者可以回看4.4.1节。</p><p><img src="https://source.drie.cn/qxsf-images/311.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-30　编辑距离最优解构造过程</b></center><ul><li>首先读取右下角<strong>d</strong>[6][5]=4，s<sub class="my_markdown">1</sub>[5]≠s<sub>2</sub>[4]，<strong>d</strong>[6][5]来源于3个数当中的最小值：上面+1=4，左侧+1=5，左上角数值+<strong>diff</strong>[i][j]=4，相等时取后者。来源于左上角，需要替换操作。返回时输出s<sub class="my_markdown">1</sub>[5]替换为s<sub>2</sub>[4]，即“Y” <strong>替换</strong> 为“E”。</li><li>向左上角找<strong>d</strong>[5][4]=3，s<sub class="my_markdown">1</sub>[4]≠s<sub>2</sub>[3]。<strong>d</strong>[5][4]来源于3个数当中的最小值：上面+1=3，左侧+1=5，左上角数值+<strong>diff</strong>[i][j]=4。来源于上面，需要删除操作。返回时输出删除s<sub class="my_markdown">1</sub>[4]，即 <strong>删除</strong> “L”。</li><li>向上面找<strong>d</strong>[4][4]=2，s<sub class="my_markdown">1</sub>[3]≠s<sub>2</sub>[3]。<strong>d</strong>[4][4]来源于3个数当中的最小值：上面+1=2，左侧+1=4，左上角数值+<strong>diff</strong>[i][j]=3。来源于上面，需要删除操作。返回时输出删除s<sub class="my_markdown">1</sub>[3]，即 <strong>删除</strong> “I”。</li><li>向上面找<strong>d</strong>[3][4]=1，s<sub class="my_markdown">1</sub>[2]=s<sub>2</sub>[3]，不需操作。<strong>d</strong>[3][4]来源于上面+1=3，左侧+1=3，左上角数值+<strong>diff</strong>[i][j]=13个数当中的最小值。来源于左上角，因为字符相等什么也不做。返回时不输出。</li><li>向左上角找<strong>d</strong>[2][3]=1，s<sub class="my_markdown">1</sub>[1]=s<sub>2</sub>[2]，不需操作。<strong>d</strong>[2][3]来源于3个数当中的最小值：上面+1=3，左侧+1=2，左上角数值+<strong>diff</strong>[i][j]=1。来源于左上角，因为字符相等什么也不做。返回时不输出。</li><li>向左上角找<strong>d</strong>[1][2]=1，s<sub class="my_markdown">1</sub>[0]≠s<sub>2</sub>[1]。<strong>d</strong>[1][2]来源于3个数当中的最小值：上面+1=3，左侧+1=1，左上角数值+<strong>diff</strong>[i][j]=2。来源于左则，需要插入操作。返回时输出在第1个字符之后插入s<sub>2</sub>[1]，即 <strong>插入</strong> “R”。</li><li>向左则找<strong>d</strong>[1][1]=0，s<sub class="my_markdown">1</sub>[0]=s<sub>2</sub>[0]。<strong>d</strong>[1][1]来源于3个数当中的最小值：上面+1=2，左侧+1=2，左上角数值+<strong>diff</strong>[i][j]=0。来源于左上角，因为字符相等什么也不做。返回时不输出。</li><li>行或列为0时，算法停止。</li></ul><h3 id="4-4-4-伪代码详解">4.4.4　伪代码详解</h3><p>编辑距离求解函数：首先计算两个字符串的长度，然后从i=1开始，比较s<sub class="my_markdown">1</sub>[0]和s<sub>2</sub>[]中的每一个字符，如果字符相等，<strong>diff</strong>[i][j]=0，否则<strong>diff</strong>[i][j]=1。因为这个值不需要记录，仅在公式表达时用数组表示，在程序设计时只用一个变量<strong>diff</strong>就可以了。</p><p>取上面+1（即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j]+1），左侧+1（即<strong>d</strong>[i][j]=<strong>d</strong>[i][j−1]+1），左上角数值+<strong>diff</strong>[i][j] （即<strong>d</strong>[i][j]=<strong>d</strong>[i−1][j−1]+ <strong>diff</strong>[i][j]）三者当中的最小值，相等时取后者。</p><p>直到i&gt;len1时，算法结束，这时<strong>d</strong>[len1][len2]就是我们要的编辑距离。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">editdistance</span><span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> len1 = <span class="built_in">strlen</span>(str1);      <span class="comment">//计算字符串长度</span></span><br><span class="line">     <span class="type">int</span> len2 = <span class="built_in">strlen</span>(str2); </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)      <span class="comment">//当第二个串长度为0，编辑距离初始化为i</span></span><br><span class="line">          d[i][<span class="number">0</span>]= i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=len2;j++)      <span class="comment">//当第一个串长度为0，编辑距离初始化为j</span></span><br><span class="line">          d[<span class="number">0</span>][j]=j;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt;=len1;i++)     <span class="comment">//遍历两个字符串</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> diff;<span class="comment">//判断str[i]是否等于str2[j],相等为0，不相等为1</span></span><br><span class="line">               <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>]) <span class="comment">//相等</span></span><br><span class="line">                     diff = <span class="number">0</span> ;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                     diff = <span class="number">1</span> ;</span><br><span class="line">               <span class="type">int</span> temp = min(d[i<span class="number">-1</span>][j] + <span class="number">1</span>, d[i][j<span class="number">-1</span>] + <span class="number">1</span>);<span class="comment">//先两者取最小值</span></span><br><span class="line">               d[i][j] = min(temp, d[i<span class="number">-1</span>][j<span class="number">-1</span>] + diff);<span class="comment">//再取最小值，</span></span><br><span class="line">                     <span class="comment">//相当于三者取最小值d[i-1][j] + 1, d[i][j-1] + 1，d[i-1][j-1] + diff</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> d[len1][len2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-5-实战演练">4.4.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">char</span> str1[N],str2[N];</span><br><span class="line"><span class="type">int</span> d[N][N]; <span class="comment">//d[i][j]表示str1前i个字符和str2前j个字符的编辑距离。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">min</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a&lt;b?a:b;<span class="comment">//返回较小的值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">editdistance</span> <span class="params">(<span class="type">char</span> *str1, <span class="type">char</span> *str2)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> len1 = <span class="built_in">strlen</span>(str1); <span class="comment">//计算字符串长度</span></span><br><span class="line">     <span class="type">int</span> len2 = <span class="built_in">strlen</span>(str2);</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=len1;i++)<span class="comment">//当第二个串长度为0，编辑距离初始化为i</span></span><br><span class="line">          d[i][<span class="number">0</span>]= i;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=len2;j++)<span class="comment">//当第一个串长度为0，编辑距离初始化为j</span></span><br><span class="line">          d[<span class="number">0</span>][j]=j;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i &lt;=len1;i++)<span class="comment">//遍历两个字符串</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len2;j++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> diff;<span class="comment">//判断str[i]是否等于str2[j],相等为0，不相等为1  </span></span><br><span class="line">               <span class="keyword">if</span>(str1[i<span class="number">-1</span>] == str2[j<span class="number">-1</span>])<span class="comment">//相等</span></span><br><span class="line">                     diff = <span class="number">0</span> ;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                     diff = <span class="number">1</span> ;</span><br><span class="line">               <span class="type">int</span> temp = min(d[i<span class="number">-1</span>][j] + <span class="number">1</span>, d[i][j<span class="number">-1</span>] + <span class="number">1</span>);<span class="comment">//先两者取最小值</span></span><br><span class="line">               d[i][j] = min(temp, d[i<span class="number">-1</span>][j<span class="number">-1</span>] + diff);<span class="comment">//再取最小值，</span></span><br><span class="line">                     <span class="comment">//相当于三者取最小值d[i-1][j] + 1, d[i][j-1] + 1，d[i-1][j-1] + diff</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> d[len1][len2];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串str1：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; str1;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入字符串str2：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; str2;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; str1&lt;&lt; <span class="string">&quot;和&quot;</span>&lt;&lt;str2&lt;&lt;<span class="string">&quot;的编辑距离是：&quot;</span>&lt;&lt;editdistance (str1,str2);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入字符串str1：</span><br><span class="line">family</span><br><span class="line">输入字符串str2：</span><br><span class="line">frame</span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">family和frame的编辑距离是：<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="4-4-6-算法解析及优化拓展">4.4.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4><p>（1）时间复杂度：算法有两个for循环，一个双重for循环。如果两个字符串的长度分别是m、n，前两个for循环时间复杂度为O(n)和O(m)，双重for循环时间复杂度为O(n<em>m)，所以总的时间复杂度为O(n</em>m)。</p><p>（2）空间复杂度：使用了<strong>d</strong>[][]数组，空间复杂度为O(n*m)。</p><h4 id="2．算法优化拓展-2">2．算法优化拓展</h4><p>大家可以动手实现构造最优解部分，可以直接倒推，也可以在程序开始使用辅助数组记录来源，然后倒推。</p><p>想一想还有没有更好的算法求解呢？</p><h3 id="4-5-长江一日游——游艇租赁">4.5　长江一日游——游艇租赁</h3><p>长江游艇俱乐部在长江上设置了n个游艇出租站，游客可以在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j），1≤i&lt;j≤n。试设计一个算法，计算从游艇出租站i到出租站j所需的最少租金。</p><p><img src="https://source.drie.cn/qxsf-images/312.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-31　游艇租赁</b></center><h3 id="4-5-1-问题分析">4.5.1　问题分析</h3><p>长江游艇俱乐部在长江上设置了n个游艇出租站，游客可以在这些出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j）。现在要求出从游艇出租站1到游艇出租站n所需的最少的租金。</p><p>当要租用游艇从一个站到另外一个站时，中间可能经过很多站点，不同的停靠站策略就有不同的租金。那么我们可以考虑该问题，从第1站到第n站的最优解是否一定包含前n−1的最优解，即是否具有最优子结构和重叠性。如果是，就可以利用动态规划进行求解。</p><p>如果我们穷举所有的停靠策略，例如一共有10个站点，当求子问题4个站点的停靠策略时，子问题有（1，2，3，4），（2，3，4，5），（3，4，5，6），（4，5，6，7），（5，6，7，8），（6，7，8，9），（7，8，9，10）。如果再求其子问题3个站点的停靠策略，（1，2，3，4）产生两个子问题：（1，2，3），（2，3，4）。（2，3，4，5）产生两个子问题：（2，3，4），（3，4，5）。如果再继续求解子问题，会发现有大量的子问题重叠，其算法时间复杂度为2<sup class="my_markdown">n</sup>，暴力穷举的办法是很不可取的。</p><p>下面分析第i个站点到第j个站点（i，i+1，…，j）的最优解（最少租金）问题，考查是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><ul><li>假设我们已经知道了在第k个站点停靠会得到最优解，那么原问题就变成了两个子问题：（i，i+1，…，k）、（k，k+1，…，j）。如图4-32所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/313.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-32　分解为两个子问题</b></center><ul><li>那么原问题的最优解是否包含子问题的最优解呢？</li></ul><p>假设第i个站点到第j个站点（i，i+1，…，j）的最优解是c，子问题（i，i+1，…，k）的最优解是a，子问题（k，k+1，…，j）的最优解是b，那么c=a+b，无论两个子问题的停靠策略如何都不影响它们的结果，因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</p><p><strong>反证法</strong> ：如果a不是最优的，子问题（i，i+1，…，k）存在一个最优解a’，a’&lt;a，那么a’+b &lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p><p>因此，该问题具有最优子结构性质。</p><p>（2）建立最优值的递归式</p><ul><li>用<strong>m</strong>[i][j]表示第i个站点到第j个站点（i，i+1，…，j）的最优值（最少租金），那么两个子问题：（i，i+1，…，k）、（k，k+1，…，j）对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k][j]。</li><li>游艇租金最优值递归式：</li></ul><p>当j=i时，只有1个站点，<strong>m</strong>[i][j]=0。</p><p>当j=i+1时，只有2个站点，<strong>m</strong>[i][j]= <strong>r</strong>[i][j]。</p><p>当j&gt;i+1时，有3个以上站点，<img class="my_markdown" src="https://source.drie.cn/qxsf-images/314.gif" style="width:319px;  height: 29px; "/>。</p><p>整理如下。</p><p><img src="https://source.drie.cn/qxsf-images/315.gif" alt="code"><br>（3)自底向上计算最优值，并记录</p><p>先求两个站点之间的最优值，再求3个站点之间的最优值，直到n个站点之间的最优值。</p><p>（4）构造最优解</p><p>上面得到的最优值只是第1个站点到第n个站点之间的最少租金，并不知道停靠了哪些站点，我们需要从记录表中还原，逆向构造出最优解。</p><h3 id="4-5-2-算法设计">4.5.2　算法设计</h3><p>采用自底向上的方法求最优值，分为不同规模的子问题，对于每一个小的子问题都求最优值，记录最优策略，具体策略如下。</p><p>（1）确定合适的数据结构</p><p>采用二维数组<strong>r</strong>[][]输入数据，二维数组<strong>m</strong>[][]存放各个子问题的最优值，二维数组<strong>s</strong>[][]存放各个子问题的最优决策（停靠站点）。</p><p>（2）初始化</p><p>根据递推公式，可以把<strong>m</strong>[i][j]初始化为<strong>r</strong>[i][j]，然后再找有没有比<strong>m</strong>[i][j]小的值，如果有，则记录该最优值和最优解即可。初始化为：<strong>m</strong>[i][j]=<strong>r</strong>[i][j]，<strong>s</strong>[i][j]=0，其中，i=1，2，…，n，j=i+1，i+2，…，n。</p><p>（3）循环阶段</p><ul><li>按照递归关系式计算3个站点i，i+1，j（j=i+2）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，…，n−2。</li><li>按照递归关系式计算4个站点i，i+1，i+2，j（j=i+3）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，…，n−3。</li><li>以此类推，直到求出n个站点的最优值<strong>m</strong>[1][n]。</li></ul><p>（4）构造最优解</p><p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解。<strong>s</strong>[1][n]是第1个站点到第n个站点（1，2，…，n）的最优解的停靠站点，即停靠了第<strong>s</strong>[1][n]个站点，我们在递归构造两个子问题（1，2，…，k）和（k，k +1，…，n）的最优解停靠站点，一直递归到子问题只包含一个站点为止。</p><h3 id="4-5-3-完美图解">4.5.3　完美图解</h3><p>长江游艇俱乐部在长江上设置了6个游艇出租站，如图4-33所示。游客可以在这些出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i到游艇出租站j之间的租金为<strong>r</strong>（i，j），如图4-34所示。</p><p><img src="https://source.drie.cn/qxsf-images/316.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-33　游艇租赁地图</b></center><p><img src="https://source.drie.cn/qxsf-images/317.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-34　各站点之间的游艇租金</b></center><p>（1）初始化</p><p>节点数n=6，<strong>m</strong>[i][j]=<strong>r</strong>[i][j]，<strong>s</strong>[i][j]=0，其中，i=1，2，…，n，j=i+1，i+2，…，n。如图4-35所示。</p><p><img src="https://source.drie.cn/qxsf-images/318.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-35　游艇租赁问题初始化</b></center><p>（2）计算3个站点i，i+1，j（j=i+2）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，4。</p><ul><li>i = 1，j=3：<strong>m</strong>[1][2]+ <strong>m</strong>[2][3]=5 &lt; <strong>m</strong>[1][3]=6，更新<strong>m</strong>[1][3]=5，<strong>s</strong>[1][3]=2。</li><li>i = 2，j=4：<strong>m</strong>[2][3]+ <strong>m</strong>[3][4]=6 &gt; <strong>m</strong>[2][4]=5，不做改变。</li><li>i = 3，j=5：<strong>m</strong>[3][4]+ <strong>m</strong>[4][5] =7&gt; <strong>m</strong>[3][5]=6，不做改变。</li><li>i = 4，j=6：<strong>m</strong>[4][5]+ <strong>m</strong>[5][6]=9 &gt; <strong>m</strong>[4][6]=8，不做改变。</li></ul><p>如图4-36所示。</p><p><img src="https://source.drie.cn/qxsf-images/319.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-36　游艇租赁问题求解过程</b></center><p>（3）计算4个站点i，i+1，i+2，j（j=i+3）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3。</p><ul><li>i = 1，j=4：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/320.gif" style="width:273px;  height: 45px; "/>；原值<strong>m</strong>[1][4]=9，更新<strong>m</strong>[1][4]=7，<strong>s</strong>[1][4]=2。</p><ul><li>i =2，j=5：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/321.gif" style="width:282px;  height: 45px; "/>；原值<strong>m</strong>[2][5]=11，更新<strong>m</strong>[2][5]=9，<strong>s</strong>[2][5]=3。</p><ul><li>i =3，j=6：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/322.gif" style="width:282px;  height: 45px; "/>；原值<strong>m</strong>[3][6]=12，更新<strong>m</strong>[3][6]=11，<strong>s</strong>[3][6]=4。</p><p>如图4-37所示。</p><p><img src="https://source.drie.cn/qxsf-images/323.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-37　游艇租赁问题求解过程</b></center><p>（4）计算5个站点i，i+1，i+2，i+3，j（j=i+4）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1、2。</p><ul><li>i = 1，j=5：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/324.gif" style="width:284px;  height: 67px; "/>；原值<strong>m</strong>[1][5]=15，更新<strong>m</strong>[1][5]=11，<strong>s</strong>[1][5]=2。</p><ul><li>i = 2，j=6：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/325.gif" style="width:284px;  height: 67px; "/>；原值<strong>m</strong>[2][6]=18，更新<strong>m</strong>[1][5]=13，<strong>s</strong>[2][6]=4。</p><p>如图4-38所示。</p><p><img src="https://source.drie.cn/qxsf-images/326.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-38　游艇租赁问题求解过程</b></center><p>（5）计算6个站点i，i+1，i+2，i+3，i+4，j（j=i+4）的最优值，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1。</p><ul><li>i = 1，j=6：</li></ul><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/327.gif" style="width:284px;  height: 89px; "/>；原值<strong>m</strong>[1][6]=20，更新<strong>m</strong>[1][6]=15，<strong>s</strong>[1][6]=2。</p><p>如图4-39所示。</p><p><img src="https://source.drie.cn/qxsf-images/328.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-39　游艇租赁问题求解过程</b></center><p>（6）构造最优解</p><p>根据存储表格<strong>s</strong>[][]中的数据来构造最优解，即停靠的站点。</p><p>首先输出出发站点1；读取<strong>s</strong>[1][6]=2，表示在2号站点停靠，即分解为两个子问题：（1，2）和（2，3，4，5，6）。</p><p>先看第一个子问题（1，2）：读取<strong>s</strong>[1][2]=0，表示没有停靠任何站点，直接到达2，输出2。</p><p>再看第二个子问题（2，3，4，5，6）：读取<strong>s</strong>[2][6]=4，表示在4号站点停靠，即分解为两个子问题：（2，3，4）和（4，5，6）。</p><p>先看子问题（2，3，4）：读取<strong>s</strong>[2][4]=0，表示没有停靠任何站点，直接到达4，输出4。</p><p>再看子问题（4，5，6）：读取<strong>s</strong>[4][6]=0，表示没有停靠任何站点，直接到达6，输出6。</p><p>最终答案是：1——2——4——6。</p><h3 id="4-5-4-伪代码详解">4.5.4　伪代码详解</h3><p>（1）最少租金求解函数</p><p>设计中n表示有n个出租站，设置二维数组<strong>m</strong>[][]，初始化时用来记录从i到j之间的租金<strong>r</strong>[][]，在不同规模的子问题（d=3，4，…，n）中，按照递推公式计算，如果比原值<strong>m</strong>[][]小，则更新<strong>m</strong>[][]，同时用<strong>s</strong>[][]记录停靠的站点号，直接最后得到的<strong>r</strong>[1][n]即为最后的结果。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">rent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,k,d;</span><br><span class="line">     <span class="keyword">for</span>(d=<span class="number">3</span>;d&lt;=n;d++) <span class="comment">//将问题分为小规模d</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-d+<span class="number">1</span>;i++)</span><br><span class="line">               &#123;</span><br><span class="line">                    j=i+d<span class="number">-1</span>;</span><br><span class="line">                    <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;j;k++)  <span class="comment">//记录每一个小规模内的最优解</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="type">int</span> temp;</span><br><span class="line">                         temp=m[i][k]+m[k][j];</span><br><span class="line">                         <span class="keyword">if</span>(temp&lt;m[i][j])</span><br><span class="line">                               &#123;</span><br><span class="line">                                 m[i][j]=temp;</span><br><span class="line">                                 s[i][j]=k;</span><br><span class="line">                               &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）最优解构造函数</p><p>根据<strong>s</strong>[][]数组构造最优解，<strong>s</strong>[i][j]将问题分解为两个子问题（i，…，<strong>s</strong>[i][j]）、（<strong>s</strong>[i][j]，…，j），递归求解这两个子问题。当<strong>s</strong>[i][j]=0时，说明中间没有经过任何站点，直达站点j，输入j，返回即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]==<span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&quot;</span>&lt;&lt;j;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j],j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-5-实战演练">4.5.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ms = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> r[ms][ms],m[ms][ms],s[ms][ms];    <span class="comment">//i到j站的租金</span></span><br><span class="line"><span class="type">int</span> n;            <span class="comment">//共有n个站点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">rent</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,k,d;</span><br><span class="line">     <span class="keyword">for</span>(d=<span class="number">3</span>;d&lt;=n;d++) <span class="comment">//将问题分为小规模为d</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-d+<span class="number">1</span>;i++)</span><br><span class="line">              &#123;</span><br><span class="line">                   j=i+d<span class="number">-1</span>;</span><br><span class="line">                   <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;j;k++)  <span class="comment">//记录每一个小规模内的最优解</span></span><br><span class="line">                   &#123;</span><br><span class="line">                        <span class="type">int</span> temp;</span><br><span class="line">                        temp=m[i][k]+m[k][j];</span><br><span class="line">                        <span class="keyword">if</span>(temp&lt;m[i][j])</span><br><span class="line">                             &#123;</span><br><span class="line">                                m[i][j]=temp;</span><br><span class="line">                                s[i][j]=k;</span><br><span class="line">                             &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">              &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]==<span class="number">0</span> )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--&quot;</span>&lt;&lt;j;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j],j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入站点的个数 n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各站点之间的租金：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=n;++j)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">cin</span>&gt;&gt;r[i][j];</span><br><span class="line">              m[i][j]=r[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">     rent();</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;花费的最少租金为：&quot;</span> &lt;&lt;m[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;最少租金经过的站点：&quot;</span>&lt;&lt;<span class="number">1</span>;</span><br><span class="line">     print(<span class="number">1</span>,n);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现和测试</p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入站点的个数n：<span class="number">6</span></span><br><span class="line">请依次输入各站点之间的租金：<span class="number">2</span> <span class="number">6</span> <span class="number">9</span> <span class="number">15</span> <span class="number">20</span> <span class="number">3</span> <span class="number">5</span> <span class="number">11</span> <span class="number">18</span> <span class="number">3</span> <span class="number">6</span> <span class="number">12</span> <span class="number">5</span> <span class="number">8</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">花费的最少租金为：<span class="number">15</span></span><br><span class="line">最少租金经过的站点：<span class="number">1</span>-<span class="number">-2</span>-<span class="number">-4</span>-<span class="number">-6</span></span><br></pre></td></tr></table></figure><h3 id="4-5-6-算法解析及优化拓展">4.5.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以得出：语句temp=<strong>m</strong>[i][k]+<strong>m</strong>[k][j]，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，最坏情况下时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p><p>（2）空间复杂度：该程序的输入数据的数组为<strong>r</strong>[][]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，该程序的空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h4 id="2．算法优化拓展-3">2．算法优化拓展</h4><p>如果只是想得到最优值（最少的租金），则不需要<strong>s</strong>[][]数组；<strong>m</strong>[][]数组也可以省略，直接在<strong>r</strong>[][]数组上更新即可，这样空间复杂度减少为O(1)。</p><h3 id="4-6-快速计算——矩阵连乘">4.6　快速计算——矩阵连乘</h3><p>给定n个矩阵{<strong>A</strong><sub class="my_markdown">1</sub>，<strong>A</strong> <sub class="my_markdown">2</sub>，<strong>A</strong><sub>3</sub>，…，<strong>A</strong> <sub class="my_markdown">n</sub>}，其中，<strong>A</strong> <sub class="my_markdown">i</sub> 和<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>（i=1，2，…，n−1）是可乘的。矩阵乘法如图4-40所示。用加括号的方法表示矩阵连乘的次序，不同的计算次序计算量（乘法次数）是不同的，找出一种加括号的方法，使得矩阵连乘的计算量最小。</p><p><img src="https://source.drie.cn/qxsf-images/329.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-40　矩阵乘法</b></center><p>例如：</p><p><strong>A</strong><sub class="my_markdown">1</sub>是<strong>M</strong><sub>5×10</sub>的矩阵；</p><p><strong>A</strong><sub class="my_markdown">2</sub>是<strong>M</strong><sub>10×100</sub>的矩阵；</p><p><strong>A</strong><sub class="my_markdown">3</sub>是<strong>M</strong><sub>100×2</sub>的矩阵。</p><p>那么有两种加括号的方法：</p><p>（1）（<strong>A</strong><sub class="my_markdown">1</sub> <strong>A</strong><sub>2</sub>）<strong>A</strong><sub>3</sub>；</p><p>（2）<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub> <strong>A</strong><sub>3</sub>）。</p><p>第1种加括号方法运算量：5×10×100+5×100×2=6000。</p><p>第2种加括号方法运算量：10×100×2+5×10×2=2100。</p><p>可以看出，不同的加括号办法，矩阵乘法的运算次数可能有巨大的差别！</p><h3 id="4-6-1-问题分析">4.6.1　问题分析</h3><p>矩阵连乘问题就是对于给定n个连乘的矩阵，找出一种加括号的方法，使得矩阵连乘的计算量（乘法次数）最小。</p><p>看到这个问题，我们需要了解以下内容。</p><p>（1）什么是矩阵可乘？</p><p>如果两个矩阵， <strong>第1个矩阵的列等于第2个矩阵的行时，那么这两个矩阵是可乘的。</strong> 如图4-41所示。</p><p><img src="https://source.drie.cn/qxsf-images/330.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-41　两个矩阵相乘</b></center><p>（2）矩阵相乘后的结果是什么？</p><p>从图4-41可以看出，两个矩阵相乘的结果矩阵，其行、列分别等于第1个矩阵的行、第2个矩阵的列。如果有很多矩阵相乘呢？如图4-42所示。</p><p><img src="https://source.drie.cn/qxsf-images/331.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-42　多个矩阵相乘</b></center><p><strong>多个矩阵相乘的结果矩阵，其行、列分别等于第1个矩阵的行、最后1个矩阵的列。</strong> 而且无论矩阵的计算次序如何都不影响它们的结果矩阵。</p><p>（3）两个矩阵相乘需要多少次乘法？</p><p>例如两个矩阵<strong>A</strong><sub class="my_markdown">3×2</sub>、<strong>B</strong><sub>2×4</sub>相乘，结果为<strong>C</strong><sub>3×4</sub>要怎么计算呢？</p><p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第1列第1个数：1×2；</p><p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第1列第2个数：2×3；</p><p><strong>两者相加存放在C矩阵第1行第1列：1</strong> × <strong>2+2</strong> × <strong>3。</strong></p><p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第2列第1个数：1×4；</p><p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第2列第2个数：2×6；</p><p><strong>两者相加存放在C矩阵第1行第2列：1</strong> × <strong>4+2</strong> × <strong>6。</strong></p><p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第3列第1个数：1×5；</p><p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第3列第2个数：2×9；</p><p><strong>两者相加存放在C矩阵第1行第3列：1</strong> × <strong>5+2</strong> × <strong>9。</strong></p><p><strong>A</strong>矩阵第1行第1个数 * <strong>B</strong>矩阵第4列第1个数：1×8；</p><p><strong>A</strong>矩阵第1行第2个数 * <strong>B</strong>矩阵第4列第2个数：2×10；</p><p><strong>两者相加存放在C矩阵第1行第4列：1</strong> × <strong>8+2</strong> × <strong>10。</strong></p><p>其他行以此类推。</p><p>计算结果如图4-43所示。</p><p><img src="https://source.drie.cn/qxsf-images/332.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-43　矩阵相乘运算</b></center><p>可以看出，结果矩阵中每个数都执行了两次乘法运算，有3×4=12个数，一共需要执行2×3×4=24次，两个矩阵<strong>A</strong><sub class="my_markdown">3×2</sub>、<strong>A</strong><sub>2×4</sub>相乘执行乘法运算的次数为3×2×4。因此，<strong>A</strong> <sub class="my_markdown">m</sub><sub>×n</sub>、<strong>A</strong> <sub class="my_markdown">n</sub><sub>×k</sub>相乘执行乘法运算的次数为m<em>n</em>k <strong>。</strong></p><p>如果穷举所有的加括号方法，那么加括号的所有方案是一个卡特兰数序列，其算法时间复杂度为2<sup class="my_markdown">n</sup>，是指数阶。因此穷举的办法是很糟的，那么能不能用动态规划呢？</p><p>下面分析矩阵连乘问题<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><ul><li>假设我们已经知道了在第k个位置加括号会得到最优解，那么原问题就变成了两个子问题：（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>），（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>），如图4-44所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/333.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-44　分解为两个子问题</b></center><p>原问题的最优解是否包含子问题的最优解呢？</p><ul><li>假设<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>的乘法次数是c，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）的乘法次数是a，（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的乘法次数是b，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数是d，那么c=a+b+d，无论两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的计算次序如何，都不影响它们结果矩阵，两个结果矩阵相乘的乘法次数d不变。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li></ul><p><strong>反证法：</strong> 如果a不是最优的，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）存在一个最优解a’，a’&lt;a，那么，a’+b+d&lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p><p>因此，矩阵连乘问题具有最优子结构性质。</p><p>（2）建立最优值递归式</p><ul><li>用<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优值，那么两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]。剩下的只需要考查（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数了。</li><li>设矩阵<strong>A</strong> <sub class="my_markdown">m</sub>的行数为p<sub class="my_markdown">m</sub>，列数为q<sub class="my_markdown">m</sub>，m=i，i+1, …，j，且矩阵是可乘的，即相邻矩阵前一个矩阵的列等于下一个矩阵的行（q<sub class="my_markdown">m</sub>= p<sub class="my_markdown">m</sub><sub>+1</sub>）。（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）的结果是一个p<sub class="my_markdown">i</sub>×q<sub class="my_markdown">k</sub>矩阵，（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果是一个p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>矩阵，q<sub class="my_markdown">k</sub>= p<sub class="my_markdown">k</sub><sub>+1</sub>，两个结果矩阵相乘的乘法次数是p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。如图4-45所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/334.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-45　结果矩阵乘法次数</b></center><ul><li>矩阵连乘最优值递归式：</li></ul><p>当i=j时，只有一个矩阵，<strong>m</strong>[i][j]=0；</p><p>当i&gt;j时，</p><p><img src="https://source.drie.cn/qxsf-images/335.gif" alt="code"><br>如果用一维数组p[]来记录矩阵的行和列，第i个矩阵的行数存储在数组的第i−1位置，列数存储在数组的第i位置，那么p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>对应的数组元素相乘为p[i−1]<em>p[k]</em> p[j]，原递归式变为：</p><p><img src="https://source.drie.cn/qxsf-images/336.gif" alt="code"><br>（3)自底向上计算并记录最优值</p><p>先求两个矩阵相乘的最优值，再求3个矩阵相乘的最优值，直到n个矩阵连乘的最优值。</p><p>（4）构造最优解</p><p>上面得到的最优值只是矩阵连乘的最小的乘法次数，并不知道加括号的次序，需要从记录表中还原加括号次序，构造出最优解，例如<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub>）。</p><p>这个问题是一个动态规划求矩阵连乘最小计算量的问题，将问题分为小规模的问题，自底向上，将规模放大，直到得到所求规模的问题的解。</p><h3 id="4-6-2-算法设计">4.6.2　算法设计</h3><p>采用自底向上的方法求最优值，对于每一个小规模的子问题都求最优值，并记录最优策略（加括号位置），具体算法设计如下。</p><p>（1）确定合适的数据结构</p><p>采用一维数组p[]来记录矩阵的行和列，第i个矩阵的行数存储在数组的第i−1位置，列数存储在数组的第i位置。二维数组<strong>m</strong>[][]来存放各个子问题的最优值，二维数组<strong>s</strong>[][]来存放各个子问题的最优决策(加括号的位置)。</p><p>（2）初始化</p><p>采用一维数组p[]来记录矩阵的行和列，<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，…，n。</p><p>（3）循环阶段</p><ul><li>按照递归关系式计算2个矩阵<strong>A</strong> <sub class="my_markdown">i</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>相乘时的最优值，j=i+1，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，…，n−1。</li><li>按照递归关系式计算3个矩阵相乘<strong>A</strong> <sub class="my_markdown">i</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>、<strong>A</strong> <sub class="my_markdown">i</sub><sub>+2</sub>相乘时的最优值，j=i+2，并将其存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，…，n−2。</li><li>以此类推，直到求出n个矩阵相乘的最优值<strong>m</strong>[1][n]。</li></ul><p>（4）构造最优解</p><p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解。<strong>s</strong>[1][n] 表示<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>最优解的加括号位置，即（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]</sub>）（<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]+1</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>），我们在递归构造两个子问题（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub>…<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]</sub>）、（<strong>A<sub class="my_markdown">s</sub></strong><sub>[1][n]+1</sub>…<strong>A</strong> <sub class="my_markdown">n</sub>）的最优解加括号位置，一直递归到子问题只包含一个矩阵为止。</p><h3 id="4-6-3-完美图解">4.6.3　完美图解</h3><p>现在我们假设有5个矩阵，如表4-1所示。</p><center class="my_markdown"><b class="my_markdown">表4-1　矩阵的规模</b></center><p>| 矩阵 | A<sub class="my_markdown">1</sub> | A<sub class="my_markdown">2</sub> | A<sub class="my_markdown">3</sub> | A<sub class="my_markdown">4</sub> | A<sub class="my_markdown">5</sub> |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 规模 | 3×5 | 5×10 | 10×8 | 8×2 | 2×4 |</p><p>（1）初始化</p><p>采用一维数组p[]记录矩阵的行和列，实际上只需要记录每个矩阵的行，再加上最后一个矩阵的列即可，如图4-46所示。<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，4，5。</p><p><img src="https://source.drie.cn/qxsf-images/337.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-46　记录行列的数组p[]</b></center><p>最优值数组<strong>m</strong>[i][i]=0，最优决策数组<strong>s</strong>[i][i]=0，其中i= 1，2，3，4，5。如图4-47所示。</p><p><img src="https://source.drie.cn/qxsf-images/338.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-47　**m**[][]和**s**[][]初始化</b></center><p>（2）计算两个矩阵相乘的最优值</p><p>规模r=2。根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p><ul><li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>：k=1，<strong>m</strong>[1][2]=min{ <strong>m</strong>[1][1]+ <strong>m</strong>[2][2]+p<sub>0</sub>p<sub class="my_markdown">1</sub>p<sub>2</sub>}=150；<strong>s</strong>[1][2]=1。</li><li><strong>A</strong><sub>2</sub>*<strong>A</strong><sub class="my_markdown">3</sub>：k=2，<strong>m</strong>[2][3]=min{ <strong>m</strong>[2][2]+ <strong>m</strong>[3][3]+p<sub class="my_markdown">1</sub>p<sub>2</sub>p<sub class="my_markdown">3</sub>}=400；<strong>s</strong>[2][3]=2。</li><li><strong>A</strong><sub class="my_markdown">3</sub>*<strong>A</strong><sub>4</sub>：k=3，<strong>m</strong>[3][4]=min{ <strong>m</strong>[3][3]+ <strong>m</strong>[4][4]+p<sub>2</sub>p<sub class="my_markdown">3</sub>p<sub>4</sub>}=160；<strong>s</strong>[3][4]=3。</li><li><strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：k=4，<strong>m</strong>[4][5]=min{ <strong>m</strong>[4][4]+ <strong>m</strong>[5][5]+p<sub class="my_markdown">3</sub>p<sub>4</sub>p<sub>5</sub>}=64； <strong>s</strong>[4][5]=4。</li></ul><p>计算完毕，如图4-48所示。</p><p><img src="https://source.drie.cn/qxsf-images/340.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-48　**m**[][]和**s**[][]计算过程</b></center><p>（3）计算3个矩阵相乘的最优值</p><p>规模r=3。根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p><ul><li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/341.gif" alt="code"><br><strong>s</strong>[1][3]=2。</p><ul><li><strong>A</strong><sub class="my_markdown">2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/342.gif" alt="code"><br><strong>s</strong>[2][4]=2。</p><ul><li><strong>A</strong><sub class="my_markdown">3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/343.gif" alt="code"><br><strong>s</strong>[3][5]=4。</p><p>计算完毕，如图4-49所示。</p><p><img src="https://source.drie.cn/qxsf-images/344.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-49　**m**[][]和**s**[][]计算过程</b></center><p>（4）计算4个矩阵相乘的最优值</p><p>规模r=4。根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/345.gif" alt="code"></p><ul><li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/346.gif" alt="code"><br><strong>s</strong>[1][4]=1。</p><ul><li><strong>A</strong><sub class="my_markdown">2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/347.gif" alt="code"><br><strong>s</strong>[2][5]=4。</p><p>计算完毕，如图4-50所示。</p><p><img src="https://source.drie.cn/qxsf-images/348.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-50　**m**[][]和**s**[][]计算过程</b></center><p>（5）计算5个矩阵相乘的最优值</p><p>规模r=5。根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/339.gif" alt="code"></p><ul><li><strong>A</strong><sub class="my_markdown">1</sub>*<strong>A</strong><sub>2</sub>*<strong>A</strong><sub>3</sub>*<strong>A</strong><sub>4</sub>*<strong>A</strong><sub>5</sub>：</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/349.gif" alt="code"><br><strong>s</strong>[1][5]=4。</p><p>计算完毕，如图4-51所示。</p><p><img src="https://source.drie.cn/qxsf-images/350.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-51**m**[][]和**s**[][]计算过程</b></center><p>（6）构造最优解</p><p>根据最优决策数组<strong>s</strong>[][]中的数据来构造最优解，即加括号的位置。</p><p>首先读取<strong>s</strong>[1][5]=4，表示在k=4的位置把矩阵分为两个子问题：（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）、<strong>A</strong><sub>5</sub>。</p><p>再看第一个子问题（<strong>A</strong><sub class="my_markdown">1</sub><strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>），读取<strong>s</strong>[1][4]=1，表示在k=1的位置把矩阵分为两个子问题：<strong>A</strong><sub class="my_markdown">1</sub>、（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）。</p><p>子问题<strong>A</strong><sub class="my_markdown">1</sub>不用再分解，输出；子问题（<strong>A</strong><sub>2</sub><strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>），读取<strong>s</strong>[2][4]=2，表示在k=2的位置把矩阵分为两个子问题：<strong>A</strong><sub>2</sub>、（<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）。</p><p>子问题<strong>A</strong><sub class="my_markdown">2</sub>不用再分解，输出；子问题(<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>)，读取<strong>s</strong>[3][4]=3，表示在k=3的位置把矩阵分为两个子问题：<strong>A</strong><sub>3</sub>、<strong>A</strong><sub>4</sub>。这两个子问题都不用再分解，输出。</p><p>子问题<strong>A</strong><sub class="my_markdown">5</sub>不用再分解，输出。</p><p>最优解构造过程如图4-52所示。</p><p><img src="https://source.drie.cn/qxsf-images/351.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-52　最优解构造过程</b></center><p>最优解为：（（<strong>A</strong><sub class="my_markdown">1</sub>（<strong>A</strong><sub>2</sub>（<strong>A</strong><sub>3</sub><strong>A</strong><sub>4</sub>）））<strong>A</strong><sub>5</sub>）。</p><p>最优值为：314。</p><h3 id="4-6-4-伪代码详解">4.6.4　伪代码详解</h3><p>按照算法思想和设计，以下程序将矩阵的行和列存储在一维数组p[]，<strong>m</strong>[][]数组用于存储分成的各个子问题的最优值，<strong>s</strong>[][]数组用于存储各个子问题的决策点，然后在一个for循环里，将问题分为规模为r的子问题，求每个规模子问题的最优解，那么得到的<strong>m</strong>[1][n]就是最小的计算量。</p><p>（1）矩阵连乘求解函数</p><p>首先将数组<strong>m</strong>[][]，<strong>s</strong>[][]初始化为0，然后自底向上处理不同规模的子问题，r为问题的规模，r= 2；r &lt;= n；r++，当r= 2时，表示矩阵连乘的规模为2，即两个矩阵连乘。求解两个矩阵连乘的最优值和最优策略，根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/339.gif" alt="code"><br>对每一个k值，求解<img class="my_markdown" src="https://source.drie.cn/qxsf-images/352.gif" style="width:332px;  height: 18px; "/>，找到最小值用<strong>m</strong>[i][j]记录，并用<strong>s</strong>[i][j]记录取得最小值的k值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">matrixchain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,r,k;</span><br><span class="line">     <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));   <span class="comment">// m[][]初始化所有元素为0，实际只需要对角线为0即可</span></span><br><span class="line">     <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));   <span class="comment">// s[][]初始化所有元素为0，实际只需要对角线为0即可</span></span><br><span class="line">     <span class="keyword">for</span>(r = <span class="number">2</span>; r &lt;= n; r++)  <span class="comment">//r为问题的规模，处理不同规模的子问题</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n-r+<span class="number">1</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j = i + r - <span class="number">1</span>;</span><br><span class="line">               m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];<span class="comment">//决策为k=i的乘法次数</span></span><br><span class="line">               s[i][j] = i;             <span class="comment">//子问题的最优策略是i;</span></span><br><span class="line">              <span class="keyword">for</span>(k = i+<span class="number">1</span> ; k &lt; j; k++) <span class="comment">//对从i+1到j的所有决策，求最优值</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                           m[i][j] = t;</span><br><span class="line">                           s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）最优解输出函数</p><p>根据存储表格<strong>s</strong>[][]中的数据来构造最优解，即加括号的位置。首先打印一个左括号，然后递归求解子问题print（i， <strong>s</strong>[i][j]），print（<strong>s</strong>[i][j]+1，j），再打印右括号，当i=j即只剩下一个矩阵时输出该矩阵即可。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( i == j )</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-5-实战演练">4.6.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> msize = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> p[msize];</span><br><span class="line"><span class="type">int</span> m[msize][msize],s[msize][msize];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">void</span> <span class="title function_">matrixchain</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j,r,k;</span><br><span class="line">     <span class="built_in">memset</span>(m,<span class="number">0</span>,<span class="keyword">sizeof</span>(m));</span><br><span class="line">     <span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="keyword">sizeof</span>(s));</span><br><span class="line">     <span class="keyword">for</span>(r = <span class="number">2</span>; r &lt;= n; r++)          <span class="comment">//不同规模的子问题</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n-r+<span class="number">1</span>; i++)</span><br><span class="line">          &#123;</span><br><span class="line">              j = i + r - <span class="number">1</span>;</span><br><span class="line">              m[i][j] = m[i+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[i] * p[j];  <span class="comment">//决策为k=i的乘法次数</span></span><br><span class="line">              s[i][j] = i;            <span class="comment">//子问题的最优策略是i;</span></span><br><span class="line">              <span class="keyword">for</span>(k = i+<span class="number">1</span>; k &lt; j; k++) <span class="comment">//对从i到j的所有决策，求最优值，记录最优策略</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i<span class="number">-1</span>] * p[k] * p[j];</span><br><span class="line">                    <span class="keyword">if</span>(t &lt; m[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                          m[i][j] = t;</span><br><span class="line">                          s[i][j] = k;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>( i == j )</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;A[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;]&quot;</span>;</span><br><span class="line">          <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;(&quot;</span>;</span><br><span class="line">     print(i,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span>,j);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入矩阵的个数 n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="type">int</span> i ,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个矩阵的行数和最后一个矩阵的列数：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n; i++ )</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">     matrixchain();</span><br><span class="line">     print(<span class="number">1</span>,n);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小计算量的值为：&quot;</span> &lt;&lt; m[<span class="number">1</span>][n] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入矩阵的个数 n：<span class="number">5</span></span><br><span class="line">请依次输入每个矩阵的行数和最后一个矩阵的列数：<span class="number">3</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">2</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">((A[<span class="number">1</span>](A[<span class="number">2</span>](A[<span class="number">3</span>]A[<span class="number">4</span>])))A[<span class="number">5</span>]) </span><br><span class="line">最小计算量的值为：<span class="number">314</span></span><br></pre></td></tr></table></figure><h3 id="4-6-6-算法解析及优化拓展">4.6.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以得出：语句 t= <strong>m</strong>[i][k] + <strong>m</strong>[k+1][j] +p[i−1]*p[k]*p[j]，它是算法的基本语句，在3层for循环中嵌套。最坏情况下，该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p><p>（2）空间复杂度：该程序的输入数据的数组为p[]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，因此空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h4 id="2．算法优化拓展-4">2．算法优化拓展</h4><p>想一想，还有什么办法对算法进行改进，或者有什么更好的算法实现？</p><h3 id="4-7-切呀切披萨——最优三角剖分">4.7　切呀切披萨——最优三角剖分</h3><p>有一块多边形的披萨饼，上面有很多蔬菜和肉片，我们希望沿着两个不相邻的顶点切成小三角形，并且尽可能少地切碎披萨上面的蔬菜和肉片。</p><p><img src="https://source.drie.cn/qxsf-images/353.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-53美味披萨</b></center><h3 id="4-7-1-问题分析">4.7.1　问题分析</h3><p>我们可以把披萨饼看作一个凸多边形，凸多边形是指多边形的任意两点的连线均落在多边形的内部或边界上。</p><p>（1）什么是凸多边形？</p><p>图4-54所示是一个凸多边形，图4-55所示不是凸多边形，因为v<sub class="my_markdown">1</sub>v<sub>3</sub>的连线落在了多边形的外部。</p><p><img src="https://source.drie.cn/qxsf-images/354.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-54　凸多边形</b></center><p><img src="https://source.drie.cn/qxsf-images/355.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-55　非凸多边形</b></center><p>凸多边形不相邻的两个顶点的连线称为凸多边形的弦。</p><p>（2）什么是凸多边形三角剖分？</p><p>凸多边形的三角剖分是指将一个凸多边形 <strong>分割成互不相交的三角形的弦的集合</strong> 。图4-56所示的一个三角剖分是{ v<sub class="my_markdown">0</sub>v<sub>4</sub>，v<sub>1</sub>v<sub>3</sub>，v<sub>1</sub>v<sub>4</sub>}，另一个三角剖分是{ v<sub class="my_markdown">0</sub>v<sub>2</sub>，v<sub class="my_markdown">0</sub>v<sub>3</sub>，v<sub class="my_markdown">0</sub>v<sub>4</sub>}，一个凸多边形的三角剖分有很多种。</p><p><img src="https://source.drie.cn/qxsf-images/356.jpg" alt="code"><br><img src="https://source.drie.cn/qxsf-images/357.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-56　凸多边形三角剖分</b></center><p>如果我们给定凸多边形及定义在边、弦上的权值，即任意两点之间定义一个数值作为权值。如图4-57所示。</p><p><img src="https://source.drie.cn/qxsf-images/358.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-57　带权值的凸多边形</b></center><p>三角形上权值之和是指三角形的3条边上权值之和：</p><p><img src="https://source.drie.cn/qxsf-images/359.gif" alt="code"><br>如图4-58所示，。</p><p><img src="https://source.drie.cn/qxsf-images/360.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/361.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-58　三角形权值之和</b></center><p>（3）什么是凸多边形最优三角剖分？</p><p>一个凸多边形的三角剖分有很多种，最优三角剖分就是划分的各三角形上权函数之和最小的三角剖分。</p><p>再回到切披萨的问题上来，我们可以把披萨看作一个凸多边形，任何两个顶点的连线对应的权值代表上面的蔬菜和肉片数，我们希望沿着两个不相邻的顶点切成小三角形，尽可能少地切碎披萨上面的蔬菜和肉片。那么，该问题可以归结为凸多边形的最优三角剖分问题。</p><p>假设把披萨看作一个凸多边形，标注各顶点为{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>}。那么怎么得到它的最优三角剖分呢？</p><p>首先分析该问题是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><ul><li>假设已经知道了在第k个顶点切开会得到最优解，那么原问题就变成了两个子问题和一个三角形，子问题分别是{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}和{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">n</sub>}，三角形为v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>，如图4-59所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/362.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-59　凸多边形三角剖分子问题</b></center><p>那么原问题的最优解是否包含子问题的最优解呢？</p><ul><li>假设{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>}三角剖分的权值之和是c，{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}三角剖分的权值之和是a，{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">n</sub>}三角剖分的权函数之和是b，三角形v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>的权值之和是w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>），那么c=a+b+ w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">n</sub>）。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li></ul><p><strong>反证法：</strong> 如果a不是最优的，{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">k</sub>}三角剖分一定存在一个最优解a’，a’&lt;a，那么a’+b+w（v<sub class="my_markdown">0</sub>v<sub class="my_markdown">k</sub>v<sub>n</sub>）&lt;c，所以c不是最优的，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p><p>因此，凸多边形的最优三角剖分问题具有最优子结构性质。</p><p>（2）建立最优值的递归式</p><ul><li>用<strong>m</strong>[i][j]表示凸多边形{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}三角剖分的最优值，那么两个子问题{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">k</sub>}、{v<sub class="my_markdown">k</sub>，v<sub class="my_markdown">k</sub><sub>+1</sub>，…，v<sub class="my_markdown">j</sub>}对应的最优值分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]，如图4-60所示，剩下的就是三角形v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>的权值之和是w(v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>)。</li></ul><p><img src="https://source.drie.cn/qxsf-images/363.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-60　凸多边形三角剖分最优值</b></center><p>当i=j时，{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}就变成了{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub> }，是一条线段，不能形成一个三角形剖分，我们可以将其看作退化的多边形，其权值设置为0。</p><ul><li>凸多边形三角剖分最优解递归式：</li></ul><p>当i=j时，只是一个线段，<strong>m</strong>[i][j]=0。</p><p>当i&gt;j时，，</p><p><img src="https://source.drie.cn/qxsf-images/364.gif" alt="code"><br>。</p><p><img src="https://source.drie.cn/qxsf-images/365.gif" alt="code"><br>（3)自底向上计算并记录最优值</p><p>先求只有3个顶点凸多边形三角剖分的最优值，再求4个顶点凸多边形三角剖分的最优值，直到n个顶点凸多边形三角剖分的最优值。</p><p>（4）构造最优解</p><p>上面得到的最优值只是凸多边形三角剖分的三角形权值之和最小值，并不知道是怎样剖分的。我们需要从记录表中还原剖分次序，找到最优剖分的弦，由这些弦构造出最优解。</p><p>如图4-61所示，如果v<sub class="my_markdown">k</sub> 能够得到凸多边形{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，…，v<sub class="my_markdown">j</sub>}的最优三角剖分，那么我们就找到两条弦v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown">k</sub>和v<sub class="my_markdown">k</sub>v<sub class="my_markdown">j</sub>，把这两条弦放在最优解集合里面，继续求解两个子问题最优三角剖分的弦。</p><p><img src="https://source.drie.cn/qxsf-images/366.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-61　凸多边形三角剖分构造最优解</b></center><p>凸多边形最优三角剖分的问题，首先判断该问题是否具有最优子结构性质，有了这个性质就可以使用动态规划，然后分析问题找最优解的递归式，根据递归式自底向上求解，最后根据最优决策表格，构造出最优解。</p><h3 id="4-7-2-算法设计">4.7.2　算法设计</h3><p>凸多边形最优三角剖分满足动态规划的最优子结构性质，可以从自底向上逐渐推出整体的最优。</p><p>（1）确定合适的数据结构</p><p>采用二维数组<strong>g</strong>[][]记录各个顶点之间的连接权值，二维数组<strong>m</strong>[][]存放各个子问题的最优值，二维数组<strong>s</strong>[][]存放各个子问题的最优决策。</p><p>（2）初始化</p><p>输入顶点数n，然后依次输入各个顶点之间的连接权值存储在二维数组<strong>g</strong>[][]中，令n=n−1（顶点标号从v<sub class="my_markdown">0</sub>开始），<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i= 1，2，3，…，n。</p><p>（3）循环阶段</p><ul><li>按照递归关系式计算3个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>}的最优三角剖分，j=i+1，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][ j]，i= 1，2，3，…，n−1。</li><li>按照递归关系式计算4个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>}的最优三角剖分，j=i+2，将最优值存入<strong>m</strong>[i][ j]，同时将最优策略记入<strong>s</strong>[i][ j]，i= 1，2，3，…，n−2。</li><li>以此类推，直到求出所有顶点 {v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>} 的最优三角剖分，并将最优值存入<strong>m</strong>[1][n]，将最优策略记入<strong>s</strong>[1][n]。</li></ul><p>（4）构造最优解</p><p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解，即输出凸多边形最优剖分的所有弦。<strong>s</strong>[1][n] 表示凸多边形{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub>} 的最优三角剖分位置，如图4-62所示。</p><ul><li>如果子问题1为空，即没有一个顶点，说明v<sub class="my_markdown">0</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>是一条边，不是弦，不需输出，否则，输出该弦v<sub class="my_markdown">0</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>。</li><li>如果子问题2为空，即没有一个顶点，说明v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub> v<sub class="my_markdown">n</sub>是一条边，不是弦，不需输出，否则，输出该弦v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub> v<sub class="my_markdown">n</sub>。</li><li>递归构造两个子问题{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>}和{v<sub class="my_markdown"><strong>s</strong></sub><sub>[1][n]</sub>，v<sub>1</sub>，…，v<sub class="my_markdown">n</sub> }，一直递归到子问题为空停止。</li></ul><p><img src="https://source.drie.cn/qxsf-images/367.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-62　凸多边形三角剖分构造最优解</b></center><h3 id="4-7-3-完美图解">4.7.3　完美图解</h3><p>以图4-63的凸多边形为例。</p><p><img src="https://source.drie.cn/qxsf-images/368.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-63　凸多边形</b></center><p>（1）初始化</p><p>顶点数n=6，令n=n−1=5（顶点标号从v<sub class="my_markdown">0</sub>开始），然后依次输入各个顶点之间的连接权值存储在邻接矩阵 <strong>g</strong> [i][j]中，其中i，j=0，1，2，3，4，5，如图4-64所示。<strong>m</strong>[i][i]=0，<strong>s</strong>[i][i]=0，其中i=1，2，3，4，5，如图4-65所示。</p><p><img src="https://source.drie.cn/qxsf-images/369.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-64　凸多边形邻接矩阵</b></center><p><img src="https://source.drie.cn/qxsf-images/370.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-65　最优值和最优策略</b></center><p>（2）计算3个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3，4。</p><p>根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/371.gif" alt="code"></p><ul><li>i=1，j=2：{v<sub class="my_markdown">0</sub>，v<sub class="my_markdown">1</sub>，v<sub class="my_markdown">2</sub>}</li><li>k=1：<strong>m</strong>[1][2]=min{<strong>m</strong>[1][1]+<strong>m</strong>[2][2]+w(v<sub class="my_markdown">0</sub>v<sub class="my_markdown">1</sub>v<sub class="my_markdown">2</sub>)}=8；<strong>s</strong>[1][2]=1。</li><li>i=2，j=3：{v<sub class="my_markdown">1</sub>，v<sub class="my_markdown">2</sub>，v<sub class="my_markdown">3</sub>}</li><li>k=2：<strong>m</strong>[2][3]=min{<strong>m</strong>[2][2]+<strong>m</strong>[3][3]+w (v<sub class="my_markdown">1</sub>v<sub class="my_markdown">2</sub>v<sub class="my_markdown">3</sub>)}=17；<strong>s</strong>[2][3]=2。</li><li>i=3，j=4：{v<sub class="my_markdown">2</sub>，v<sub class="my_markdown">3</sub>，v<sub>4</sub>}</li><li>k=3：<strong>m</strong>[3][4]=min{<strong>m</strong>[3][3]+<strong>m</strong>[4][4]+w (v<sub class="my_markdown">2</sub>v<sub class="my_markdown">3</sub>v<sub>4</sub>)}=35；<strong>s</strong>[3][4]=3。</li><li>i=4，j=5：{v<sub class="my_markdown">3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li><li>k=4：<strong>m</strong>[4][5]=min{<strong>m</strong>[4][4]+<strong>m</strong>[5][5]+w (v<sub class="my_markdown">3</sub>v<sub>4</sub>v<sub>5</sub>)}=20；<strong>s</strong>[4][5]=4。</li></ul><p>计算完毕，如图4-66所示。</p><p><img src="https://source.drie.cn/qxsf-images/372.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-66　最优值和最优策略</b></center><p>（3）计算4个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2，3。</p><p>根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/364.gif" alt="code"></p><ul><li>i=1，j=3：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/373.gif" alt="code"><br><strong>s</strong>[1][3]=2。</p><ul><li>i=2，j=4：{v<sub class="my_markdown">1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/374.gif" alt="code"><br><strong>s</strong>[2][4]=3。</p><ul><li>i=3，j=5：{v<sub class="my_markdown">2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/375.gif" alt="code"><br><strong>s</strong>[3][5]=3。</p><p>计算完毕，如图4-67所示：</p><p><img src="https://source.drie.cn/qxsf-images/376.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-67　最优值和最优策略</b></center><p>（4）计算5个顶点{v<sub class="my_markdown">i</sub><sub>-1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>，v<sub class="my_markdown">i</sub><sub>+3</sub>}的最优三角剖分，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1，2。</p><p>根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/364.gif" alt="code"></p><ul><li>i=1，j=4：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/377.gif" alt="code"><br><strong>s</strong>[1][4]=3。</p><ul><li>i=2，j=5：{v<sub class="my_markdown">1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/378.gif" alt="code"><br><strong>s</strong>[2][5]=3。</p><p>计算完毕，如图4-68所示。</p><p><img src="https://source.drie.cn/qxsf-images/379.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-68　最优值和最优策略</b></center><p>（5）计算6个顶点{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">i</sub><sub>+1</sub>，v<sub class="my_markdown">i</sub><sub>+2</sub>，v<sub class="my_markdown">i</sub><sub>+3</sub>，v<sub class="my_markdown">i</sub><sub>+4</sub>}的最优三角剖分，j=i+4，将最优值存入<strong>m</strong>[i][j]，同时将最优策略记入<strong>s</strong>[i][j]，i=1。</p><p>根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/371.gif" alt="code"></p><ul><li>i=1，j=5：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub>3</sub>，v<sub>4</sub>，v<sub>5</sub>}</li></ul><p>；</p><p><img src="https://source.drie.cn/qxsf-images/380.gif" alt="code"><br><strong>s</strong>[1][5]=3。</p><p>计算完毕，如图4-69所示。</p><p><img src="https://source.drie.cn/qxsf-images/381.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-69　最优值和最优策略</b></center><p>（6）构造最优解</p><p>根据最优决策信息数组<strong>s</strong>[][]递归构造最优解，即输出凸多边形最优剖分的所有弦。<strong>s</strong>[1][5] 表示凸多边形{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，…，v<sub>5</sub>} 的最优三角剖分位置，从图4-69最优决策数组可以看出，<strong>s</strong>[1][5]=3，如图4-70所示。</p><ul><li>因为v<sub class="my_markdown">0</sub>～v<sub class="my_markdown">3</sub>中有结点，所以子问题1不为空，输出该弦v<sub class="my_markdown">0</sub>v<sub class="my_markdown">3</sub>。</li><li>因为v<sub class="my_markdown">3</sub>～v<sub>5</sub>中有结点，所以子问题2不为空，输出该弦v<sub class="my_markdown">3</sub>v<sub>5</sub>。</li><li>递归构造子问题1：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub>，v<sub class="my_markdown">3</sub>}，读取<strong>s</strong>[1][3]=2，如图4-71所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/382.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-70　构造最优解过程（原问题）</b></center><p><img src="https://source.drie.cn/qxsf-images/383.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-71　构造最优解过程（子问题1）</b></center><p>因为v<sub class="my_markdown">0</sub>～v<sub>2</sub>中有结点，所以子问题1’不为空，输出该弦v<sub class="my_markdown">0</sub>v<sub>2</sub>。</p><p>递归构造子问题1’：{v<sub class="my_markdown">0</sub>，v<sub>1</sub>，v<sub>2</sub> }，读取s[1][2]=1，如图4-72所示。</p><p><img src="https://source.drie.cn/qxsf-images/384.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-72　构造最优解过程（子问题1'）</b></center><p>因为v<sub class="my_markdown">0</sub>～v<sub>1</sub>中没有结点，子问题1’''为空，v<sub class="my_markdown">0</sub>v<sub>1</sub>是一条边，不是弦，不输出。</p><p>因为v<sub class="my_markdown">1</sub>～v<sub>2</sub>中没有结点，子问题2’''为空，v<sub class="my_markdown">1</sub>v<sub>2</sub>是一条边，不是弦，不输出。</p><p>递归构造子问题2’：{ v<sub class="my_markdown">2</sub>，v<sub>3</sub> }。</p><p>因为v<sub class="my_markdown">2</sub>～v<sub>3</sub>中没有结点，子问题2’为空，v<sub class="my_markdown">2</sub>v<sub>3</sub>是一条边，不是弦，不输出。</p><ul><li>递归构造子问题2：{v<sub class="my_markdown">3</sub>，v<sub>4</sub>，v<sub>5</sub>}，读取<strong>s</strong>[4][5]=4，如图4-73所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/385.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-73　构造最优解过程（子问题2）</b></center><p>因为v<sub class="my_markdown">3</sub>～v<sub>4</sub>中没有结点，子问题1’'为空，v<sub class="my_markdown">3</sub>v<sub>4</sub>是一条边，不是弦，不输出。</p><p>因为v<sub class="my_markdown">4</sub>～v<sub>5</sub>中没有结点，子问题2’'为空，v<sub class="my_markdown">4</sub>v<sub>5</sub>是一条边，不是弦，不输出。</p><p>因此，该凸多边形三角剖分最优解为：v<sub class="my_markdown">0</sub>v<sub>3</sub>，v<sub>3</sub>v<sub>5</sub>，v<sub class="my_markdown">0</sub>v<sub>2</sub>。</p><h3 id="4-7-4-伪代码详解">4.7.4　伪代码详解</h3><p>（1）凸多边形三角剖分求解函数</p><p>首先将数组<strong>m</strong>[][]、<strong>s</strong>[][]初始化为0，然后自底向上处理不同规模的子问题，d为i到j的规模，d=2；d&lt;=n；d++，当d=2时，实际上是3个点，因为<strong>m</strong>[i][j]表示的是{v<sub class="my_markdown">i</sub><sub>−1</sub>，v<sub class="my_markdown">i</sub>，v<sub class="my_markdown">j</sub>}。求解3个顶点凸多边形三角剖分的最优值和最优策略，根据递归式：</p><p><img src="https://source.drie.cn/qxsf-images/371.gif" alt="code"><br>对每一个k值，求解<img class="my_markdown" src="https://source.drie.cn/qxsf-images/386.gif" style="width:275px;  height: 20px; "/>，找到最小值后用<strong>m</strong>[i][j]记录，并用<strong>s</strong>[i][j]记录取得最小值的k值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Convexpolygontriangulation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n ; i++) <span class="comment">// 初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">         m[i][i] = <span class="number">0</span> ;</span><br><span class="line">         s[i][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span> ;d &lt;= n ; d++)  <span class="comment">//d为i到j的规模，d=2时，实际上是三个点</span></span><br><span class="line">                                  <span class="comment">//因为我们的m[i][j]表示的是&#123;vi-1，vi，vj&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n - d + <span class="number">1</span> ; i++) <span class="comment">//控制i值</span></span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = i + d - <span class="number">1</span> ;             <span class="comment">// j值</span></span><br><span class="line">           m[i][j] = m[i+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][i] + g[i][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">           s[i][j] = i ;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span> ;k &lt; j ; k++) <span class="comment">// 枚举划分点</span></span><br><span class="line">           &#123;</span><br><span class="line">                <span class="type">double</span> temp = m[i][k] + m[k+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][k] + g[k][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                     m[i][j] = temp ;      <span class="comment">// 更新最优值</span></span><br><span class="line">                     s[i][j] = k ;         <span class="comment">// 记录划分点</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）最优解输出函数</p><p>我们首先从<strong>s</strong>[][]数组中读取<strong>s</strong>[i][j]，然后判断子问题1是否为空。若<strong>s</strong>[i][j]&gt;i，表示i到<strong>s</strong>[i][j]之间存在顶点，子问题1不为空，那么v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]</sub>是一条弦，输出{v<sub class="my_markdown">i</sub><sub>−1</sub>v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]</sub>}；判断子问题2是否为空，若j&gt;<strong>s</strong>[i][j]+1，表示<strong>s</strong>[i][j]+1到j之间存在顶点，子问题2不为空，那么v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]+1</sub> v<sub class="my_markdown">j</sub>是一条弦，输出{v<sub class="my_markdown"><strong>s</strong></sub><sub>[i][j]+1</sub>v<sub class="my_markdown">j</sub>}。递归求解子问题1和子问题2，直到i=j时停止。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> j)</span>                  <span class="comment">// 输出所有的弦</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i == j)  <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]&gt;i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">if</span>(j&gt;s[i][j]+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(i ,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span> ,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-5-实战演练">4.7.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M= <span class="number">1000</span> + <span class="number">5</span> ;</span><br><span class="line"><span class="type">int</span> n ;</span><br><span class="line"><span class="type">int</span> s[M][M] ;</span><br><span class="line"><span class="type">double</span> m[M][M],g[M][M];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Convexpolygontriangulation</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n ; i++)           <span class="comment">// 初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">         m[i][i] = <span class="number">0</span> ;</span><br><span class="line">         s[i][i] = <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">2</span> ;d &lt;= n ; d++)        <span class="comment">//d为问题规模，d=2时，实际上是三个点</span></span><br><span class="line">                                        <span class="comment">//因为我们的m[i][j]表示的是&#123;vi-1，vi，vj&#125;</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span> ;i &lt;= n - d + <span class="number">1</span> ; i++)  <span class="comment">// 控制i值</span></span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> j = i + d - <span class="number">1</span> ;          <span class="comment">// j值</span></span><br><span class="line">           m[i][j] = m[i+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][i] + g[i][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">           s[i][j] = i ;</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k = i + <span class="number">1</span> ;k &lt; j ; k++)     <span class="comment">// 枚举划分点</span></span><br><span class="line">           &#123;</span><br><span class="line">                <span class="type">double</span> temp = m[i][k] + m[k+<span class="number">1</span>][j] + g[i<span class="number">-1</span>][k] + g[k][j] + g[i<span class="number">-1</span>][j] ;</span><br><span class="line">                <span class="keyword">if</span>(m[i][j] &gt; temp)</span><br><span class="line">                &#123;</span><br><span class="line">                     m[i][j] = temp ;   <span class="comment">// 更新最优值</span></span><br><span class="line">                     s[i][j] = k ;      <span class="comment">// 记录划分点</span></span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> i , <span class="type">int</span> j)</span>               <span class="comment">// 输出所有的弦</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i == j)  <span class="keyword">return</span> ;</span><br><span class="line">     <span class="keyword">if</span>(s[i][j]&gt;i)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;i<span class="number">-1</span>&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">if</span>(j&gt;s[i][j]+<span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;&#123;v&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot;v&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot;&#125;&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(i ,s[i][j]);</span><br><span class="line">     print(s[i][j]+<span class="number">1</span> ,j);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,j;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入顶点的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     n-- ;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各顶点的连接权值:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span> ;i &lt;= n ; ++i)           <span class="comment">// 输入各个顶点之间的连接权值</span></span><br><span class="line">          <span class="keyword">for</span>( j = <span class="number">0</span> ;j &lt;= n ; ++j)</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;g[i][j] ;</span><br><span class="line">     Convexpolygontriangulation ();</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;m[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     print(<span class="number">1</span> ,n);                       <span class="comment">// 打印路径</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">0</span>  <span class="number">2</span>  <span class="number">3</span>   <span class="number">1</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line"><span class="number">2</span>  <span class="number">0</span>  <span class="number">3</span>   <span class="number">4</span>   <span class="number">8</span>   <span class="number">6</span></span><br><span class="line"><span class="number">3</span>  <span class="number">3</span>  <span class="number">0</span>   <span class="number">10</span>  <span class="number">13</span>  <span class="number">7</span></span><br><span class="line"><span class="number">1</span>  <span class="number">4</span>  <span class="number">10</span>  <span class="number">0</span>   <span class="number">12</span>  <span class="number">5</span></span><br><span class="line"><span class="number">5</span>  <span class="number">8</span>  <span class="number">13</span>  <span class="number">12</span>  <span class="number">0</span>   <span class="number">3</span></span><br><span class="line"><span class="number">6</span>  <span class="number">6</span>  <span class="number">7</span>   <span class="number">5</span>   <span class="number">3</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">54</span></span><br><span class="line">&#123; v0 v3 &#125;</span><br><span class="line">&#123; v3 v5 &#125;</span><br><span class="line">&#123; v0 v2 &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-7-6-算法解析及优化拓展">4.7.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-5">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以得出语句 t= <strong>m</strong>[i][k] + <strong>m</strong>[k+1][j] + <strong>g</strong>[i−1][i] + <strong>g</strong>[i][j] + <strong>g</strong>[i−1] [j]，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，print()函数算法的时间主要取决于递归，最坏情况下时间复杂度为O(n)。故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p><p>（2）空间复杂度：该程序的输入数据的数组为<strong>g</strong>[][]，辅助变量为i、j、r、t、k、<strong>m</strong>[][]、<strong>s</strong>[][]，空间复杂度取决于辅助空间，因此空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h4 id="2．算法优化拓展-5">2．算法优化拓展</h4><p>这个问题尽管和矩阵连乘问题表达的含义不同，但递归式是完全相同的，那么程序代码就可以参考矩阵连乘的代码了。</p><p>想一想，还有什么办法对算法进行改进，或者有什么更好的算法实现？</p><h3 id="4-8-小石子游戏——石子合并">4.8　小石子游戏——石子合并</h3><p>一群小孩子在玩小石子游戏，游戏有两种玩法。</p><p>（1）路边玩法</p><p>有n堆石子堆放在路边，现要将石子有序地合并成一堆，规定每次只能移动相邻的两堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费（最小或最大）。</p><p>（2）操场玩法</p><p>一个圆形操场周围摆放着n堆石子，现要将石子有序地合并成一堆，规定每次只能移动相邻的两堆石子合并，合并花费为新合成的一堆石子的数量。求将这N堆石子合并成一堆的总花费（最小或最大）。</p><p><img src="https://source.drie.cn/qxsf-images/387.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-74　小石子游戏</b></center><h3 id="4-8-1-问题分析">4.8.1　问题分析</h3><p>本题初看可以使用贪心法来解决，但是因为有必须相邻两堆才能合并这个条件在，用贪心法就无法保证每次都能取到所有堆中石子数最少（最多）的两堆。</p><p>下面以操场玩法为例：假设有n=6堆石子，每堆的石子个数分别为3、4、6、5、4、2。</p><p>如果使用贪心法求最小花费，应该是如下的合并步骤：</p><p>第1次合并 3 4 6 5 4 2　　 　2，3合并花费是5</p><p>第2次合并 5 4 6 5 4　　　　5，4合并花费是9</p><p>第3次合并 9 6 5 4　 　 　 　5，4合并花费是9</p><p>第4次合并 9 6 9 　　 　　　 9，6合并花费是15</p><p>第5次合并 15 9　 　　 　 　15，9合并花费是24</p><p>总得分＝5＋9＋9＋15＋24＝62</p><p>但是如果采用如下合并方法，却可以得到比上面花费更少的方法：</p><p>第1次合并 3 4 6 5 4 2　　　 3，4合并花费是7</p><p>第2次合并 7 6 5 4 2　　　 　7，6合并花费是13</p><p>第3次合并 13 5 4 2　　　　 4，2合并花费是6</p><p>第4次合并 13 5 6　　　　 　5，6合并花费是11</p><p>第5次合并 13 11　　　　　 13，11合并花费是24</p><p>总花费＝7＋13＋6＋11＋24＝61</p><p>显然利用贪心法来求解错误的，贪心算法在子过程中得出的解只是局部最优，而不能保证全局的值最优，因此本题不可以使用贪心法求解。</p><p>如果使用暴力穷举的办法，会有大量的子问题重复，这种做法是不可取的，那么是否可以使用动态规划呢？我们要分析该问题是否具有最优子结构性质，它是使用动态规划的必要条件。</p><h4 id="1．路边玩法">1．路边玩法</h4><p>如果n−1次合并的全局最优解包含了每一次合并的子问题的最优解，那么经这样的n−1次合并后的花费总和必然是最优的，因此我们就可以通过动态规划算法来求出最优解。</p><p>首先分析该问题是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><ul><li>假设已经知道了在第k堆石子分开可以得到最优解，那么原问题就变成了两个子问题，子问题分别是{a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub>}和{ a<sub class="my_markdown">k</sub><sub>+1</sub>，…，a<sub class="my_markdown">j</sub>}，如图4-75所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/388.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-75　原问题分解为子问题</b></center><p>那么原问题的最优解是否包含子问题的最优解呢？</p><ul><li>假设已经知道了n堆石子合并起来的花费是c，子问题1{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub> }石子合并起来的花费是a，子问题2{ a<sub class="my_markdown">k</sub><sub>+1</sub>，…，a<sub class="my_markdown">j</sub>}石子合并起来的花费是b，{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">j</sub> }石子数量之和是w（i，j），那么c=a+b+ w（i，j）。因此我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</li></ul><p><strong>反证法：</strong> 如果a不是最优的，子问题1{ a<sub class="my_markdown">i</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">k</sub> }一定存在一个最优解a’，a’&lt;a，那么a’+b+ w（i，j）&lt;c，这与我们的假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。</p><p>因此，路边玩法小石子合并游戏问题具有最优子结构性质。</p><p>（2）建立最优值递归式</p><p>设<strong>Min</strong>[i][j]代表从第i堆石子到第j堆石子合并的最小花费，<strong>Min</strong>[i][k]代表从第i堆石子到第k堆石子合并的最小花费，<strong>Min</strong>[k+1][j]代表从第k+1堆石子到第j堆石子合并的最小花费，w（i，j）代表从i堆到j堆的石子数量之和。列出递归式：</p><p><img src="https://source.drie.cn/qxsf-images/389.gif" alt="code"><br><strong>Max</strong>[i][j] 代表从第 i 堆石子到第 j 堆石子合并的最大花费，<strong>Max</strong>[i][k] 代表从第 i 堆石子到第 k堆石子合并的最大花费，<strong>Max</strong>[k+1][j] 代表从第 k+1堆石子到第 j 堆石子合并的最大花费，w（i，j)代表从i堆到j堆的石子数量之和。列出递归式：</p><p><img src="https://source.drie.cn/qxsf-images/390.gif" alt="code"></p><h4 id="2．操场玩法">2．操场玩法</h4><p>如果把路边玩法看作直线型石子合并问题，那么操场玩法就属于圆型石子合并问题。圆型石子合并经常转化为直线型来求。也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，如图4-76所示。然后就可以用线性的石子合并问题的方法求解，求最大值的方法和求最小值的方法是一样的。最后，从 <strong>规模是</strong> n <strong>的最优值</strong> 找出 <strong>最小值或最大值</strong> 即可。</p><p><img src="https://source.drie.cn/qxsf-images/391.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-76　转化为规模为2n−1的直线型</b></center><h3 id="4-8-2-算法设计">4.8.2　算法设计</h3><h4 id="1．路边玩法-2">1．路边玩法</h4><p>假设有n堆石子，一字排开，合并相邻两堆的石子，每合并两堆石子有一个花费，最终合并后的最小花费和最大花费。</p><p>（1）确定合适的数据结构</p><p>采用一维数组a[i]来记录第i堆石子（a<sub class="my_markdown">i</sub>）的数量；sum[i]来记录前i堆（a<sub>1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">i</sub>）石子的总数量；二维数组<strong>Min</strong>[i][j]、<strong>Max</strong>[i][j]来记录第i堆到第j堆a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，…，a<sub class="my_markdown">i</sub>堆石子合并的最小花费和最大花费。</p><p>（2）初始化</p><p>输入石子的堆数n，然后依次输入各堆石子的数量存储在a[i]中，令<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n。</p><p>（3）循环阶段</p><ul><li>按照递归式计算2堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，…，n−1。</li><li>按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，…，n−2。</li><li>以此类推，直到求出所有堆{a<sub class="my_markdown">1</sub>，…，a<sub class="my_markdown">n</sub>}的最小花费和最大花费。</li></ul><p>（4）构造最优解</p><p><strong>Min</strong>[1][n]和<strong>Max</strong>[1][n]是n堆石子合并的最小花费和最大花费。如果还想知道具体的合并顺序，需要在求解的过程中记录最优决策，然后逆向构造最优解，可以使用类似矩阵连乘的构造方法，用括号来表达合并的先后顺序。</p><h4 id="2．操场玩法-2">2．操场玩法</h4><p>圆型石子合并经常转化为直线型来求，也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，然后就可以用线性的石子合并问题的方法求解，求最小花费和最大花费的方法是一样的。最后，从规模是n的最优值找出最小值即可。即要从规模为n的最优值<strong>Min</strong>[1][n]，<strong>Min</strong>[2][n+1]，<strong>Min</strong>[3][n+2]，…，<strong>Min</strong>[n][2n−1]中找最小值作为圆型石子合并的最小花费。</p><p>从 <strong>规模是</strong> n <strong>的最优值</strong> <strong>Max</strong>[1][n]，<strong>Max</strong>[2][n+1]，<strong>Max</strong>[3][n+2]，…，<strong>Max</strong>[n][2n−1] 中找 <strong>最大值</strong> 作为圆型石子合并的最大花费。</p><h3 id="4-8-3-完美图解">4.8.3　完美图解</h3><p>如图4-77所示，以6堆石子的路边玩法为例。</p><p><img src="https://source.drie.cn/qxsf-images/392.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-77　6堆石子</b></center><p>（1）初始化</p><p>输入石子的堆数n，然后依次输入各堆石子的数量存储在a[i]中，如图4-78所示。</p><p><img src="https://source.drie.cn/qxsf-images/393.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-78　石子数量</b></center><p><strong>Min</strong>[i][j]和<strong>Max</strong>[i][j]来记录第i堆到第j堆a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，…，a<sub class="my_markdown">i</sub>堆石子合并的最小花费和最大花费。令<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，如图4-79所示。</p><p><img src="https://source.drie.cn/qxsf-images/394.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-79　最小花费和最大花费</b></center><p>sum[i]为前i堆石子数量总和，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n，如图4-80所示。</p><p><img src="https://source.drie.cn/qxsf-images/395.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-80　前i堆石子数量总和</b></center><p>原递归公式中的w（i，j）代表从i堆到j堆的石子数量之和，可以用直接查表法sum[j] −sum[i−1]求解，如图4-81所示。这样就不用每次遇到w（i，j）都计算一遍了，这也是动态规划思想的显现！</p><p><img src="https://source.drie.cn/qxsf-images/396.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-81　sum[j]−sum[i−1]即为w（i，j）</b></center><p>（2）按照递归式计算两堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，4，5。如图4-82所示。</p><p><img src="https://source.drie.cn/qxsf-images/397.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-82　最小花费和最大花费</b></center><ul><li>i=1，j=2：{a<sub class="my_markdown">1</sub>，a<sub>2</sub>}</li></ul><p>k=1：<strong>Min</strong>[1][2]=<strong>Min</strong>[1][1]+<strong>Min</strong>[2][2]+sum[2] −sum[0]=13；</p><p>**　 　 Max**[1][2]=<strong>Max</strong>[1][1]+<strong>Max</strong>[2][2]+sum[2] −sum[0]=13。</p><ul><li>i=2，j=3：{a<sub class="my_markdown">2</sub>，a<sub>3</sub>}</li></ul><p>k=2：<strong>Min</strong>[2][3]=<strong>Min</strong>[2][2]+<strong>Min</strong>[3][3]+sum[3] −sum[1]=14；</p><p>**　 　 Max**[2][3]=<strong>Max</strong>[2][2]+<strong>Max</strong>[3][3]+sum[3] −sum[1]=14。</p><ul><li>i=3，j=4：{a<sub class="my_markdown">3</sub>，a<sub>4</sub>}</li></ul><p>k=3：<strong>Min</strong>[3][4]=<strong>Min</strong>[3][3]+<strong>Min</strong>[4][4]+sum[4] −sum[2]=15；</p><p>**　 　 Max**[3][4]=<strong>Max</strong>[3][3]+<strong>Max</strong>[4][4]+sum[4] −sum[2]=15。</p><ul><li>i=4，j=5：{a<sub class="my_markdown">4</sub>，a<sub>5</sub>}</li></ul><p>k=4：<strong>Min</strong>[4][5]=<strong>Min</strong>[4][4]+<strong>Min</strong>[5][5]+sum[5] −sum[3]=11；</p><p>**　 　 Max**[4][5]=<strong>Max</strong>[4][4]+<strong>Max</strong>[5][5]+sum[5] −sum[3]=11。</p><ul><li>i=5，j=6：{a<sub class="my_markdown">5</sub>，a<sub>6</sub>}</li></ul><p>k=5：<strong>Min</strong>[5][6]=<strong>Min</strong>[5][5]+<strong>Min</strong>[6][6]+sum[6] −sum[4]=5；</p><p>**　 　 Max**[5][6]=<strong>Max</strong>[5][5]+<strong>Max</strong>[6][6]+sum[6] −sum[4]=5。</p><p>（3）按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，4，如图4-83所示。</p><p><img src="https://source.drie.cn/qxsf-images/398.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-83　最小花费和最大花费</b></center><ul><li>i=1，j=3：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>}</li></ul><p><img src="https://source.drie.cn/qxsf-images/399.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/400.gif" alt="code"><br><strong>Min</strong>[1][3]= 32；<strong>Max</strong>[1][3]=33。</p><ul><li>i=2，j=4：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>}</li></ul><p><img src="https://source.drie.cn/qxsf-images/401.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/402.gif" alt="code"><br><strong>Min</strong>[2][4]= 37；<strong>Max</strong>[2][4]=38。</p><ul><li>i=3，j=5：{ a<sub class="my_markdown">3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li></ul><p><img src="https://source.drie.cn/qxsf-images/403.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/404.gif" alt="code"><br><strong>Min</strong>[3][5]= 28；<strong>Max</strong>[3][5]=32。</p><ul><li>i=4，j=6：{ a<sub class="my_markdown">4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li></ul><p><img src="https://source.drie.cn/qxsf-images/405.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/406.gif" alt="code"><br><strong>Min</strong>[4][6]= 19；<strong>Max</strong>[4][6]=25。</p><p>（4）按照递归式计算4堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>，a<sub class="my_markdown">i</sub><sub>+3</sub>}的最小花费和最大花费，i=1，2，3，如图4-84所示。</p><p><img src="https://source.drie.cn/qxsf-images/407.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-84　最小花费和最大花费</b></center><ul><li>i=1，j=4：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>}</li></ul><p><strong>Min</strong>[1][4]= 56；<strong>Max</strong>[1][4]=66。</p><ul><li>i=2，j=5：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li></ul><p><strong>Min</strong>[2][5]=50；<strong>Max</strong>[2][5]=63。</p><ul><li>i=3，j=6：{ a<sub class="my_markdown">3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li></ul><p><strong>Min</strong>[3][6]=39；<strong>Max</strong>[3][6]=52。</p><p>（5）按照递归式计算5堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>，a<sub class="my_markdown">i</sub><sub>+3</sub>，a<sub class="my_markdown">i</sub><sub>+4</sub>}的最小花费和最大花费，i=1，2，如图4-85所示。</p><p><img src="https://source.drie.cn/qxsf-images/414.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-85　最小花费和最大花费</b></center><ul><li>i=1，j=5：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>}</li></ul><p><strong>Min</strong>[1][5]=71；<strong>Max</strong>[1][5]=96。</p><ul><li>i=2，j=6：{ a<sub class="my_markdown">2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li></ul><p><strong>Min</strong>[2][6]=61；<strong>Max</strong>[3][6]=9。</p><p>（6）按照递归式计算6堆石子合并{a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}的最小花费和最大花费，如图4-86所示。</p><p><img src="https://source.drie.cn/qxsf-images/419.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-86　最小花费和最大花费</b></center><ul><li>i=1，j=6：{ a<sub class="my_markdown">1</sub>，a<sub>2</sub>，a<sub>3</sub>，a<sub>4</sub>，a<sub>5</sub>，a<sub>6</sub>}</li></ul><p><strong>Min</strong>[1][6]=84；<strong>Max</strong>[1][6]=129。</p><h3 id="4-8-4-伪代码详解">4.8.4　伪代码详解</h3><p>（1）路边玩法</p><p>首先初始化<strong>Min</strong>[i][i]=0，<strong>Max</strong>[i][i]=0，sum[0]=0，计算sum[i]，其中i= 1，2，3，…，n。</p><p>循环阶段：</p><p>按照递归式计算2堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>}的最小花费和最大花费，i=1，2，3，…，n−1。</p><p>按照递归式计算3堆石子合并{a<sub class="my_markdown">i</sub>，a<sub class="my_markdown">i</sub><sub>+1</sub>，a<sub class="my_markdown">i</sub><sub>+2</sub>}的最小花费和最大花费，i=1，2，3，…，n−2。</p><p>以此类推，直到求出所有堆{a<sub class="my_markdown">1</sub>，…，a<sub class="my_markdown">n</sub>}的最小花费和最大花费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)               <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Min[i][j] = INF;          <span class="comment">//初始化为最大值</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;j; k++) &#123;  <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">                    Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）操场玩法</p><p>圆型石子合并经常转化为直线型来求，也就是说，把圆形结构看成是长度为原规模两倍的直线结构来处理。如果操场玩法原问题规模为n，所以相当于有一排石子a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>，a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub><sub>−1</sub>，该问题规模为2n−1，然后就可以用线性的石子合并问题的方法求解，求最小花费和最大花费的方法是一样的。最后，从最优解中找出规模是n的最优解即可。</p><p>即要从规模为n的最优解<strong>Min</strong>[1][n]，<strong>Min</strong>[2][n+1]，<strong>Min</strong>[3][n+2]，…，<strong>Min</strong>[n][2n−1]中找最小值作为圆型石子合并的最小花费。</p><p>从<strong>Max</strong>[1][n]，<strong>Max</strong>[2][n+1]，<strong>Max</strong>[3][n+2]，…，<strong>Max</strong>[n][2n−1] 中找出最大值作为圆型石子合并的最大花费。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">              min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">              max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-8-5-实战演练">4.8.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> Min[N][N], Max[N][N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> min_Circular,max_Circular;</span><br><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)  <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Min[i][j] = INF;          <span class="comment">//初始化为最大值</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;j; k++) &#123;  <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    Min[i][j] = min(Min[i][j], Min[i][k] + Min[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">                    Max[i][j] = max(Max[i][j], Max[i][k] + Max[k+<span class="number">1</span>][j] + tmp);</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">              min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">              max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入石子的堆数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各堆的石子数:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">     straight(a, n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法（直线型）最小花费为：&quot;</span>&lt;&lt;Min[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法（直线型）最大花费为：&quot;</span>&lt;&lt;Max[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     Circular(a,n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法（圆型）最小花费为：&quot;</span>&lt;&lt;min_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法（圆型）最大花费为：&quot;</span>&lt;&lt;max_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现和测试</p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入石子的堆数 n：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">请依次输入各堆的石子数：</span><br><span class="line"><span class="number">5</span> <span class="number">8</span> <span class="number">6</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">路边玩法（直线型）最小花费为：<span class="number">84</span></span><br><span class="line">路边玩法（直线型）最大花费为：<span class="number">129</span></span><br><span class="line">操场玩法（圆型）最小花费为：<span class="number">81</span></span><br><span class="line">操场玩法（圆型）最大花费为：<span class="number">130</span></span><br></pre></td></tr></table></figure><h3 id="4-8-6-算法解析及优化拓展">4.8.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-6">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以得出语句<strong>Min</strong>[i][j] = min(<strong>Min</strong>[i][j], <strong>Min</strong>[i][k] + <strong>Min</strong>[k+1][j] + tmp)，它是算法的基本语句，在3层for循环中嵌套，最坏情况下该语句的执行次数为O(n<sup class="my_markdown">3</sup>)，故该程序的时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p><p>（2）空间复杂度：该程序的辅助变量为<strong>Min</strong>[][]、<strong>Max</strong>[][]，空间复杂度取决于辅助空间，故空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h4 id="2．算法优化拓展-6">2．算法优化拓展</h4><p>对于石子合并问题，如果按照普通的区间动态规划进行求解，时间复杂度是O(n<sup class="my_markdown">3</sup>)，但最小值可以用四边形不等式（见附录F）优化。</p><p><img src="https://source.drie.cn/qxsf-images/422.gif" alt="code"><br><strong>s</strong>[i][j]表示取得最优解<strong>Min</strong>[i][j]的最优策略位置。</p><p>k的取值范围缩小了很多，原来是区间[i，j)，现在变为区间[<strong>s</strong>[i][j−1]，<strong>s</strong>[i+1][j])。如图4-87所示。</p><p><img src="https://source.drie.cn/qxsf-images/423.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-87　k的取值范围缩小</b></center><p>经过优化，算法时间复杂度可以减少至O(n<sup class="my_markdown">2</sup>)。</p><p>注意：最大值有一个性质，即总是在两个端点的最大者中取到。</p><p>即<strong>Max</strong>[i][j] = max(<strong>Max</strong>[i][j−1], <strong>Max</strong>[i+1][j]) + <strong>sum</strong>[i][j]</p><p>经过优化，算法时间复杂度也可以减少至O(n<sup class="my_markdown">2</sup>)。</p><p>优化后算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-6-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">205</span>;</span><br><span class="line"><span class="type">int</span> Min[N][N], Max[N][N],s[N][N];</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> min_Circular,max_Circular;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Min</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)               <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)      <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;            <span class="comment">//枚举终点j</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];  <span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="type">int</span> i1=s[i][j<span class="number">-1</span>]&gt;i?s[i][j<span class="number">-1</span>]:i;</span><br><span class="line">               <span class="type">int</span> j1=s[i+<span class="number">1</span>][j]&lt;j?s[i+<span class="number">1</span>][j]:j;</span><br><span class="line">               Min[i][j]=Min[i][i1]+Min[i1+<span class="number">1</span>][j];</span><br><span class="line">               s[i][j]=i1;</span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> k=i1+<span class="number">1</span>; k&lt;=j1; k++) <span class="comment">//枚举中间分隔点</span></span><br><span class="line">                    <span class="keyword">if</span>(Min[i][k]+ Min[k+<span class="number">1</span>][j]&lt;Min[i][j])</span><br><span class="line">                    &#123;</span><br><span class="line">                         Min[i][j]=Min[i][k]+Min[k+<span class="number">1</span>][j];</span><br><span class="line">                         s[i][j]=k;</span><br><span class="line">                    &#125;</span><br><span class="line">               Min[i][j]+=tmp;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get_Max</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> v=<span class="number">2</span>; v&lt;=n; v++)             <span class="comment">// 枚举合并的堆数规模</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n-v+<span class="number">1</span>; i++)    <span class="comment">//枚举起始点i</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="type">int</span> j = i + v<span class="number">-1</span>;          <span class="comment">//枚举终点j</span></span><br><span class="line">               Max[i][j] = <span class="number">-1</span>;           <span class="comment">//初始化为-1</span></span><br><span class="line">               <span class="type">int</span> tmp = sum[j]-sum[i<span class="number">-1</span>];<span class="comment">//记录i...j之间的石子数之和</span></span><br><span class="line">               <span class="keyword">if</span>(Max[i+<span class="number">1</span>][j]&gt;Max[i][j<span class="number">-1</span>])</span><br><span class="line">                   Max[i][j]=Max[i+<span class="number">1</span>][j]+tmp;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   Max[i][j]=Max[i][j<span class="number">-1</span>]+tmp;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">straight</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)               <span class="comment">// 初始化</span></span><br><span class="line">          Min[i][i]=<span class="number">0</span>, Max[i][i]=<span class="number">0</span>, s[i][i]=<span class="number">0</span>;</span><br><span class="line">     sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">     get_Min(n);</span><br><span class="line">     get_Max(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Circular</span><span class="params">(<span class="type">int</span> a[],<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)</span><br><span class="line">          a[n+i]=a[i];</span><br><span class="line">     n=<span class="number">2</span>*n<span class="number">-1</span>;</span><br><span class="line">     straight(a, n);</span><br><span class="line">     n=(n+<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">     min_Circular=Min[<span class="number">1</span>][n];</span><br><span class="line">     max_Circular=Max[<span class="number">1</span>][n];</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(Min[i][n+i<span class="number">-1</span>]&lt;min_Circular)</span><br><span class="line">             min_Circular=Min[i][n+i<span class="number">-1</span>];</span><br><span class="line">          <span class="keyword">if</span>(Max[i][n+i<span class="number">-1</span>]&gt;max_Circular)</span><br><span class="line">             max_Circular=Max[i][n+i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入石子的堆数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入各堆的石子数:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;a[i];</span><br><span class="line">     straight(a, n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法(直线型)最小花费为：&quot;</span>&lt;&lt;Min[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;路边玩法(直线型)最大花费为：&quot;</span>&lt;&lt;Max[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     Circular(a,n);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法(圆型)最小花费为：&quot;</span>&lt;&lt;min_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;操场玩法(圆型)最大花费为：&quot;</span>&lt;&lt;max_Circular&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（1）时间复杂度：在get_Min()函数中，虽然有3层for循环语句，但并不是有3层for语句的执行次数就是O(n<sup class="my_markdown">3</sup>)，我们分析其执行次数为：</p><p><img src="https://source.drie.cn/qxsf-images/424.gif" alt="code"><br>因为公式中的j=i+v−1，所以：</p><p><img src="https://source.drie.cn/qxsf-images/425.gif" alt="code"><br>故get_Min()的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>在get_Max()函数中，有两层for循环语句嵌套，时间复杂度也是O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：空间复杂度取决于辅助空间，空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h3 id="4-9-大卖场购物车1——0-1背包问题">4.9　大卖场购物车1——0-1背包问题</h3><p>央视有一个大型娱乐节目——购物街，舞台上模拟超市大卖场，有很多货物，每个嘉宾分配一个购物车，可以尽情地装满购物车，购物车中装的货物价值最高者取胜。假设有n个物品和1个购物车，每个物品i对应价值为v<sub class="my_markdown">i</sub>，重量w<sub class="my_markdown">i</sub>，购物车的容量为W（你也可以将重量设定为体积）。每个物品只有1件，要么装入，要么不装入，不可拆分。在购物车不超重的情况下，如何选取物品装入购物车，使所装入的物品的总价值最大？最大价值是多少？装入了哪些物品？</p><p><img src="https://source.drie.cn/qxsf-images/426.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-88　大卖场购物车1</b></center><h3 id="4-9-1-问题分析">4.9.1　问题分析</h3><p>有n个物品和购物车的容量，每个物品的重量为w[i]，价值为v[i]，购物车的容量为W。选若干个物品放入购物车，使价值最大，可表示如下。</p><p>约束条件：</p><p><img src="https://source.drie.cn/qxsf-images/427.gif" alt="code"><br>目标函数：</p><p><img src="https://source.drie.cn/qxsf-images/428.gif" alt="code"><br>问题归结为求解满足约束条件，使目标函数达到最大值的解向量X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，…，x<sub class="my_markdown">n</sub>}。</p><p>该问题就是经典的0-1背包问题，我们在第2章贪心算法中已经知道背包问题（可切割）可以用贪心算法求解，而0-1背包问题使用贪心算法有可能得不到最优解（参看2.4.6节）。因为物品的不可切割性，无法保证能够装满背包，所以采用每次装价值/重量比最高的贪心策略是不可行的。</p><p>那么是否能够使用动态规划呢？</p><p>首先分析该问题是否具有最优子结构性质。</p><p>（1）分析最优解的结构特征</p><ul><li>假设已经知道了X={x<sub class="my_markdown">1</sub>，x<sub>2</sub>，…，x<sub class="my_markdown">n</sub>}是原问题{a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，那么原问题去掉第一个物品就变成了子问题{a<sub>2</sub>，a<sub>3</sub>，…，a<sub class="my_markdown">n</sub>}，如图4-89所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/429.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-89　原问题和子问题</b></center><p>子问题的约束条件和目标函数如下。</p><p>约束条件：</p><p><img src="https://source.drie.cn/qxsf-images/430.gif" alt="code"><br>目标函数：</p><p><img src="https://source.drie.cn/qxsf-images/431.gif" alt="code"></p><ul><li>我们只需要证明：X’={x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}是子问题{a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，即证明了最优子结构性质。</li></ul><p><strong>反证法：</strong> 假设X’={ x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}不是子问题{ a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，{ y<sub class="my_markdown">2</sub>，…，y<sub class="my_markdown">n</sub>}是子问题的最优解，<img class="my_markdown" src="https://source.drie.cn/qxsf-images/432.gif" style="width:137px;  height: 50px; "/>，且满足约束条件<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/433.gif" style="width:163px;  height: 50px; "/>，我们将约束条件两边同时加上<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/434.gif" style="width:36px;  height: 12px; "/>，则变为<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/435.gif" style="width:164px;  height: 50px; "/>，目标函数两边同时加上<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/436.gif" style="width:32px;  height: 12px; "/>，则变为<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/437.gif" style="width:194px;  height: 51px; "/>，说明{x<sub>1</sub>，y<sub class="my_markdown">2</sub>，…，y<sub class="my_markdown">n</sub>}比{ x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}更优，{ x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}不是原问题{a<sub>1</sub>，a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解，与假设X={x<sub>1</sub>，x<sub class="my_markdown">2</sub>，…，x<sub class="my_markdown">n</sub>}是原问题{a<sub>1</sub>，a<sub class="my_markdown">2</sub>，…，a<sub class="my_markdown">n</sub>}的最优解矛盾。问题得证。</p><p>该问题是否具有最优子结构性质。</p><p>（2）建立最优值的递归式</p><p>可以对每个物品依次检查是否放入或者不放入，对于第i个物品的处理状态：</p><p>用<strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。</p><ul><li>不放入第i件物品，x<sub class="my_markdown">i</sub>=0，装入购物车的价值不增加。那么问题就转化为“前i−1件物品放入容量为j的背包中”，最大价值为<strong>c</strong>[i−1][j]。</li><li>放入第i件物品，x<sub class="my_markdown">i</sub>=1，装入购物车的价值增加v<sub class="my_markdown">i</sub>。</li></ul><p>那么问题就转化为“前i−1件物品放入容量为j−w[i]的购物车中”，此时能获得的最大价值就是<strong>c</strong>[i−1][j−w[i]]，再加上放入第i件物品获得的价值v[i]。即<strong>c</strong>[i−1][j−w[i]]+ v[i]。</p><p>购物车容量不足，肯定不能放入；购物车容量足，我们要看放入、不放入哪种情况获得的价值更大。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif/" alt="code"></p><h3 id="4-9-2-算法设计">4.9.2　算法设计</h3><p>有n个物品，每个物品的重量为w[i]，价值为v[i]，购物车的容量为W。选若干个物品放入购物车，在不超过容量的前提下使获得的价值最大。</p><p>（1）确定合适的数据结构</p><p>采用一维数组w[i]、v[i]来记录第i个物品的重量和价值；二维数组用<strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。</p><p>（2）初始化</p><p>初始化<strong>c</strong>[][]数组0行0列为0：<strong>c</strong>[0][j]=0，<strong>c</strong>[i][0] =0，其中i=0，1，2，…，n，j=0，1，2，…，W。</p><p>（3）循环阶段</p><ul><li>按照递归式计算第1个物品的处理情况，得到<strong>c</strong>[1][j]，j=1，2，…，W。</li><li>按照递归式计算第2个物品的处理情况，得到<strong>c</strong>[2][j]，j=1，2，…，W。</li><li>以此类推，按照递归式计算第n个物品的处理情况，得到<strong>c</strong>[n][j]，j=1，2，…，W。</li></ul><p>（4）构造最优解</p><p><strong>c</strong>[n][W]就是不超过购物车容量能放入物品的最大价值。如果还想知道具体放入了哪些物品，就需要根据<strong>c</strong>[][]数组逆向构造最优解。我们可以用一维数组x[i]来存储解向量。</p><ul><li>首先i=n，j=W，如果<strong>c</strong>[i][j]&gt;<strong>c</strong>[i−1][j]，则说明第n个物品放入了购物车，令x[n]=1，j−=w[n]；如果<strong>c</strong>[i][j]≤<strong>c</strong>[i−1][j]，则说明第n个物品没有放入购物车，令x[n]=0。</li><li>i−−，继续查找答案。</li><li>直到i=1处理完毕。</li></ul><p>这时已经得到了解向量（x[1]，x[2]，…，x[n]），可以直接输出该解向量，也可以仅把x[i]=1的货物序号i输出。</p><h3 id="4-9-3-完美图解">4.9.3　完美图解</h3><p>假设现在有5个物品，每个物品的重量为（2，5，4，2，3），价值为（6，3，5，4，6），如图4-90所示。购物车的容量为10，求在不超过购物车容量的前提下，把哪些物品放入购物车，才能获得最大价值。</p><p><img src="https://source.drie.cn/qxsf-images/439.jpg" alt="code"><br><img src="https://source.drie.cn/qxsf-images/440.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-90　物品的重量和价值</b></center><p>（1）初始化</p><p><strong>c</strong>[i][j]表示前i件物品放入一个容量为j的购物车可以获得的最大价值。初始化<strong>c</strong>[][]数组0行0列为0：<strong>c</strong>[0][j]=0，<strong>c</strong>[i][0] =0，其中i=0，1，2，…，n，j=0，1，2，…，W。如图4-91所示。</p><p><img src="https://source.drie.cn/qxsf-images/441.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-91　最大价值数组</b></center><p>按照递归式计算第1个物品（i=1）的处理情况，得到<strong>c</strong>[1][j]，j=1，2，…，W。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>w[1]=2，v[1]=6，如图4-92所示。</p><p><img src="https://source.drie.cn/qxsf-images/442.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-92　最大价值数组</b></center><ul><li>j=1时，<strong>c</strong>[1][1]=<strong>c</strong>[0][1]=0；</li><li>j=2时，<strong>c</strong>[1][2]=max{<strong>c</strong>[0][2]，<strong>c</strong>[0][0]+6}=6；</li><li>j=3时，<strong>c</strong>[1][3]=max{<strong>c</strong>[0][3]，<strong>c</strong>[0][1]+6}=6；</li><li>j=4时，<strong>c</strong>[1][4]=max{<strong>c</strong>[0][4]，<strong>c</strong>[0][2]+6}=6；</li><li>j=5时，<strong>c</strong>[1][5]=max{<strong>c</strong>[0][5]，<strong>c</strong>[0][3]+6}=6；</li><li>j=6时，<strong>c</strong>[1][6]=max{<strong>c</strong>[0][6]，<strong>c</strong>[0][4]+6}=6；</li><li>j=7时，<strong>c</strong>[1][7]=max{<strong>c</strong>[0][7]，<strong>c</strong>[0][5]+6}=6；</li><li>j=8时，<strong>c</strong>[1][8]=max{<strong>c</strong>[0][8]，<strong>c</strong>[0][6]+6}=6；</li><li>j=9时，<strong>c</strong>[1][9]=max{<strong>c</strong>[0][9]，<strong>c</strong>[0][7]+6}=6；</li><li>j=10时，<strong>c</strong>[1][10]=max{<strong>c</strong>[0][10]，<strong>c</strong>[0][8]+6}=6。</li></ul><p>（2）按照递归式计算第1个物品（i=2）的处理情况，得到<strong>c</strong>[2][j]，j=1，2，…，W。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>w[2]=5，v[2]=3，如图4-93所示。</p><p><img src="https://source.drie.cn/qxsf-images/443.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-93　最大价值数组</b></center><ul><li>j=1时，<strong>c</strong>[2][1]=<strong>c</strong>[1][1]=0；</li><li>j=2时，<strong>c</strong>[2][2]=<strong>c</strong>[1][2]=6；</li><li>j=3时，<strong>c</strong>[2][3]=<strong>c</strong>[1][3]=6；</li><li>j=4时，<strong>c</strong>[2][4]=<strong>c</strong>[1][4]=6；</li><li>j=5时，<strong>c</strong>[2][5]=max{<strong>c</strong>[1][5]，<strong>c</strong>[1][0]+3}=6；</li><li>j=6时，<strong>c</strong>[2][6]=max{<strong>c</strong>[1][6]，<strong>c</strong>[1][1]+3}=6；</li><li>j=7时，<strong>c</strong>[2][7]=max{<strong>c</strong>[1][7]，<strong>c</strong>[1][2]+3}=9；</li><li>j=8时，<strong>c</strong>[2][8]=max{<strong>c</strong>[1][8]，<strong>c</strong>[1][3]+3}=9；</li><li>j=9时，<strong>c</strong>[2][9]=max{<strong>c</strong>[1][9]，<strong>c</strong>[1][4]+3}=9；</li><li>j=10时，<strong>c</strong>[1][10]=max{<strong>c</strong>[1][10]，<strong>c</strong>[1][5]+3}=9。</li></ul><p>（3）按照递归式计算第1个物品（i=3）的处理情况，得到<strong>c</strong>[3][j]，j=1，2，…，W。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>w[3]=4，v[3]=5，如图4-94所示。</p><p><img src="https://source.drie.cn/qxsf-images/444.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-94　最大价值数组</b></center><ul><li>j=1时，<strong>c</strong>[3][1]=<strong>c</strong>[2][1]=0；</li><li>j=2时，<strong>c</strong>[3][2]=<strong>c</strong>[2][2]=6；</li><li>j=3时，<strong>c</strong>[3][3]=<strong>c</strong>[2][3]=6；</li><li>j=4时，<strong>c</strong>[3][4]=max{<strong>c</strong>[2][4]，<strong>c</strong>[2][0]+5}=6；</li><li>j=5时，<strong>c</strong>[3][5]=max{<strong>c</strong>[2][5]，<strong>c</strong>[2][1]+5}=6；</li><li>j=6时，<strong>c</strong>[3][6]=max{<strong>c</strong>[2][6]，<strong>c</strong>[2][2]+5}=11；</li><li>j=7时，<strong>c</strong>[3][7]=max{<strong>c</strong>[2][7]，<strong>c</strong>[2][3]+5}=11；</li><li>j=8时，<strong>c</strong>[3][8]=max{<strong>c</strong>[2][8]，<strong>c</strong>[2][4]+5}=11；</li><li>j=9时，<strong>c</strong>[3][9]=max{<strong>c</strong>[2][9]，<strong>c</strong>[2][5]+5}=11；</li><li>j=10时，<strong>c</strong>[3][10]=max{<strong>c</strong>[2][10]，<strong>c</strong>[2][6]+5}=11。</li></ul><p>（4）按照递归式计算第1个物品（i=4）的处理情况，得到<strong>c</strong>[4][j]，j=1，2，…，W。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>w[4]=2，v[4]=4，如图4-95所示。</p><p><img src="https://source.drie.cn/qxsf-images/445.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-95　最大价值数组</b></center><ul><li>j=1时，<strong>c</strong>[4][1]=c[3][1]=0；</li><li>j=2时，<strong>c</strong>[4][2]=max{<strong>c</strong>[3][2]，<strong>c</strong>[3][0]+4}=6；</li><li>j=3时，<strong>c</strong>[4][3]=max{<strong>c</strong>[3][3]，<strong>c</strong>[3][1]+4}=6；</li><li>j=4时，<strong>c</strong>[4][4]=max{<strong>c</strong>[3][4]，<strong>c</strong>[3][2]+4}=10；</li><li>j=5时，<strong>c</strong>[4][5]=max{<strong>c</strong>[3][5]，<strong>c</strong>[3][3]+4}=10；</li><li>j=6时，<strong>c</strong>[4][6]=max{<strong>c</strong>[3][6]，<strong>c</strong>[3][4]+4}=11；</li><li>j=7时，<strong>c</strong>[4][7]=max{<strong>c</strong>[3][7]，<strong>c</strong>[3][5]+4}=11；</li><li>j=8时，<strong>c</strong>[4][8]=max{<strong>c</strong>[3][8]，<strong>c</strong>[3][6]+4}=15；</li><li>j=9时，<strong>c</strong>[4][9]=max{<strong>c</strong>[3][9]，<strong>c</strong>[3][7]+4}=15；</li><li>j=10时，<strong>c</strong>[4][10]=max{<strong>c</strong>[3][10]，<strong>c</strong>[3][8]+4}=15。</li></ul><p>（5）按照递归式计算第1个物品（i=5）的处理情况，得到<strong>c</strong>[5][j]，j=1，2，…，W。</p><p><img src="https://source.drie.cn/qxsf-images/438.gif" alt="code"><br>w[5]=3，v[5]=6，如图4-96所示。</p><p><img src="https://source.drie.cn/qxsf-images/446.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-96　最大价值数组</b></center><ul><li>j=1时，<strong>c</strong>[5][1]=<strong>c</strong>[4][1]=0；</li><li>j=2时，<strong>c</strong>[5][2]=<strong>c</strong>[4][2]=6；</li><li>j=3时，<strong>c</strong>[5][3]=max{<strong>c</strong>[4][3]，<strong>c</strong>[4][0]+6}=6；</li><li>j=4时，<strong>c</strong>[5][4]=max{<strong>c</strong>[4][4]，<strong>c</strong>[4][1]+6}=10；</li><li>j=5时，<strong>c</strong>[5][5]=max{<strong>c</strong>[4][5]，<strong>c</strong>[4][2]+6}=12；</li><li>j=6时，<strong>c</strong>[5][6]=max{<strong>c</strong>[4][6]，<strong>c</strong>[4][3]+6}=12；</li><li>j=7时，<strong>c</strong>[5][7]=max{<strong>c</strong>[4][7]，<strong>c</strong>[4][4]+6}=16；</li><li>j=8时，<strong>c</strong>[5][8]=max{<strong>c</strong>[4][8]，<strong>c</strong>[4][5]+6}=16；</li><li>j=9时，<strong>c</strong>[5][9]=max{<strong>c</strong>[4][9]，<strong>c</strong>[4][6]+6}=17；</li><li>j=10时，<strong>c</strong>[5][10]=max{<strong>c</strong>[4][10]，<strong>c</strong>[4][7]+6}=17。</li></ul><p>（6）构造最优解</p><p>首先读取<strong>c</strong>[5][10]&gt;<strong>c</strong>[4][10]，说明第5个物品装入了购物车，即x[5]=1，j=10−w[5]=7；</p><p>去找<strong>c</strong>[4][7]=<strong>c</strong>[3][7]，说明第4个物品没装入购物车，即x[4]=0；</p><p>去找<strong>c</strong>[3][7]&gt;<strong>c</strong>[2][7]，说明第3个物品装入了购物车，即x[3]=1，j= j−w[3]=3；</p><p>去找<strong>c</strong>[2][3]=<strong>c</strong>[1][3]，说明第2个物品没装入购物车，即x[2]=0；</p><p>去找<strong>c</strong>[1][3]&gt;<strong>c</strong>[0][3]，说明第1个物品装入了购物车，即x[1]=1，j= j−w[1]=1。</p><p>如图4-97所示。</p><p><img src="https://source.drie.cn/qxsf-images/447.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-97　最大价值数组</b></center><h3 id="4-9-5-实战演练">4.9.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 105</span></span><br><span class="line"><span class="type">int</span> c[M][maxn];         <span class="comment">//c[i][j] 表示前i个物品放入容量为j购物车获得的最大价值</span></span><br><span class="line"><span class="type">int</span> w[M],v[M];          <span class="comment">//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值</span></span><br><span class="line"><span class="type">int</span> x[M];               <span class="comment">//x[i]表示第i个物品是否放入购物车</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">     <span class="type">int</span> i,j,n,W;       <span class="comment">//n表示n个物品，W表示购物车的容量</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入物品的个数n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入购物车的容量W：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个物品的重量w和价值v，用空格分开：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=n;i++)  <span class="comment">//初始化第0列为0</span></span><br><span class="line">          c[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;=W;j++)  <span class="comment">//初始化第0行为0</span></span><br><span class="line">          c[<span class="number">0</span>][j]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;= n;i++) <span class="comment">//计算c[i][j]</span></span><br><span class="line">          <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">               <span class="keyword">if</span>(j&lt;w[i])  <span class="comment">//当物品的重量大于购物车的容量，则不放此物品</span></span><br><span class="line">                    c[i][j] = c[i<span class="number">-1</span>][j];</span><br><span class="line">               <span class="keyword">else</span>    <span class="comment">//否则比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">                    c[i][j] = max(c[i<span class="number">-1</span>][j],c[i<span class="number">-1</span>][j-w[i]] + v[i]);</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的最大价值为：&quot;</span>&lt;&lt;c[n][W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//逆向构造最优解</span></span><br><span class="line">     j=W;</span><br><span class="line">     <span class="keyword">for</span>(i=n;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">          <span class="keyword">if</span>(c[i][j]&gt;c[i<span class="number">-1</span>][j])</span><br><span class="line">          &#123;</span><br><span class="line">               x[i]=<span class="number">1</span>;</span><br><span class="line">               j-=w[i];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               x[i]=<span class="number">0</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的物品为：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">if</span>(x[i]==<span class="number">1</span>)</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现和测试</p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入物品的个数n：<span class="number">5</span></span><br><span class="line">请输入购物车的容量W：<span class="number">10</span></span><br><span class="line">请依次输入每个物品的重量w和价值v，用空格分开：</span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">装入购物车的最大价值为：<span class="number">17</span></span><br><span class="line">装入购物车的物品为：<span class="number">1</span>  <span class="number">3</span>  <span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="4-9-6-算法解析及优化拓展">4.9.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-7">1．算法复杂度分析</h4><p>（1）时间复杂度：算法中有主要的是两层嵌套的for循环，其时间复杂度为O(n*W)。</p><p>（2）空间复杂度：由于二维数组<strong>c</strong>[n][W]，所以空间复杂度为O(n*W)。</p><h4 id="2．算法优化拓展-7">2．算法优化拓展</h4><p>如何实现优化改进呢？首先有一个主循环i=1，2，…，N，每次算出来二维数组<strong>c</strong>[i][0～W]的所有值。那么，如果只用一个数组dp[0～W]，能不能保证第i次循环结束后dp[j]中表示的就是我们定义的状态<strong>c</strong>[i][j]呢？<strong>c</strong>[i][j]由<strong>c</strong>[i−1][j]和<strong>c</strong>[i−1] [j−w[i]]两个子问题递推而来，能否保证在递推<strong>c</strong>[i][j]时（也即在第i次主循环中递推dp[j]时）能够得到<strong>c</strong>[i−1][j]和<strong>c</strong>[i−1][j−w[i]]的值呢？事实上，这要求在每次主循环中以j=W，W−1，…，1，0的顺序倒推dp[j]，这样才能保证递推dp[j]时dp[j−<strong>c</strong>[i]]保存的是状态<strong>c</strong>[i −1][j−w[i]]的值。</p><p>伪代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i=<span class="number">1.</span>.n </span><br><span class="line"><span class="keyword">for</span> j=W.<span class="number">.0</span> </span><br><span class="line">       dp[j]=max&#123;dp[j],dp[j-w[i]]+v[i]&#125;;</span><br></pre></td></tr></table></figure><p>其中，dp[j]=max{dp[j]，dp[j−w[i]]}就相当于转移方程<strong>c</strong>[i][j]=max{<strong>c</strong>[i−1][j]，<strong>c</strong>[i−1][j− w[i]]}，因为这里的dp[j−w[i]]就相当于原来的<strong>c</strong>[i−1][j−w[i]]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-7-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 10005</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 105</span></span><br><span class="line"><span class="type">int</span> dp[maxn];    <span class="comment">//dp[j] 表示当前已放入容量为j的购物车获得的最大价值</span></span><br><span class="line"><span class="type">int</span> w[M],v[M];   <span class="comment">//w[i] 表示第i个物品的重量，v[i] 表示第i个物品的价值</span></span><br><span class="line"><span class="type">int</span> x[M];        <span class="comment">//x[i]表示第i个物品是否放入购物车</span></span><br><span class="line"><span class="type">int</span> i,j,n,W;     <span class="comment">//n表示n个物品，W表示购物车的容量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">opt1</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=W;j&gt;<span class="number">0</span>;j--)</span><br><span class="line">               <span class="keyword">if</span>(j&gt;=w[i])  <span class="comment">//当购物车的容量大于等于物品的重量，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">                  dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入物品的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入购物车的容量W:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; W;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个物品的重量w和价值v,用空格分开:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;w[i]&gt;&gt;v[i];</span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)<span class="comment">//初始化第0行为0</span></span><br><span class="line">          dp[j]=<span class="number">0</span>;</span><br><span class="line">     opt1(n,W);</span><br><span class="line">     <span class="comment">//opt2(n,W);</span></span><br><span class="line">     <span class="comment">//opt3(n,W);</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入购物车的最大价值为:&quot;</span>&lt;&lt;dp[W]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">//测试dp[]数组结果</span></span><br><span class="line">     <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=W;j++)</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;dp[j]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实我们可以缩小范围，因为只有当购物车的容量大于等于物品的重量时才要更新（dp[j] = max（dp[j],dp[j−w[i]]+v[i]）），如果当购物车的容量小于物品的重量时，则保持原来的值（相当于原来的<strong>c</strong>[i−1][j]）即可。因此第2个for语句可以是for(j=W；j&gt;=w[i]；j−−)，而不必搜索到j=0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">opt2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;= n;i++)</span><br><span class="line">          <span class="keyword">for</span>(j=W;j&gt;=w[i];j--)</span><br><span class="line">               <span class="comment">//当购物车的容量大于等于物品的重量，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">               dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以再缩小范围，确定搜索的下界bound，搜索下界取w[i]与剩余容量的最大值，sum[n] −sum[i−1]表示i～n的物品重量之和。W−（sum[n] −sum[i−1]）表示剩余容量。</p><p>因为只有购物车容量超过下界时才要更新（dp[j] = max（dp[j]，dp[j−w[i]]+v[i]）），如果购物车容量小于下界，则保持原来的值（相当于原来的<strong>c</strong>[i−1][j]）即可。因此第2个for语句可以是for(j=W；j&gt;=bound；j−−)，而不必搜索到j=0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">opt3</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> W)</span></span><br><span class="line">&#123;</span><br><span class="line">      <span class="type">int</span> sum[n];<span class="comment">//sum[i]表示从1~i的物品重量之和</span></span><br><span class="line">      sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">           sum[i]=sum[i<span class="number">-1</span>]+w[i];</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      &#123;</span><br><span class="line">           <span class="type">int</span> bound=max(w[i],W-(sum[n]-sum[i<span class="number">-1</span>]));<span class="comment">//搜索下界，w[i]与剩余容量取最大值,sum[n]-sum[i-1]表示从i...n的物品重量之和</span></span><br><span class="line">           <span class="keyword">for</span>(j=W;j&gt;=bound;j--)</span><br><span class="line">               <span class="comment">//购物车容量大于等于下界，比较此物品放与不放是否能使得购物车内的价值最大</span></span><br><span class="line">               dp[j] = max(dp[j],dp[j-w[i]]+v[i]);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-快速定位——最优二叉搜索树">4.10　快速定位——最优二叉搜索树</h3><p>给定n个关键字组成的有序序列S={s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">n</sub>}，关键字结点称为实结点。对每个关键字查找的概率是p<sub class="my_markdown">i</sub>，查找不成功的结点称为虚结点，对应{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">n</sub>}，每个虚结点的查找概率为q<sub class="my_markdown">i</sub>。e<sub>0</sub>表示小于s<sub class="my_markdown">1</sub>的值，e<sub class="my_markdown">n</sub>大于s<sub class="my_markdown">n</sub>的值。所有结点查找概率之和为1。求最小平均比较次数的二叉搜索树（最优二叉搜索树）。</p><p>举例说明：给定一个有序序列S={5，9，12，15，20，24}，这些数的查找概率分别是p<sub class="my_markdown">1</sub>、p<sub>2</sub>、p<sub>3</sub>、p<sub>4</sub>、p<sub>5</sub>、p<sub>6</sub>。在实际中，有可能有查找不成功的情况，例如要在序列中查找x=2，那么我们就会定位在5的前面，查找不成功，相当于落在了虚结点e<sub>0</sub>的位置。要在序列中查找x=18，那么就会定位在15～20，查找不成功，相当于落在了虚结点e<sub>4</sub>的位置。</p><p><img src="https://source.drie.cn/qxsf-images/448.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-98　查找关键字</b></center><p><img src="https://source.drie.cn/qxsf-images/449.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-99　快速定位</b></center><h3 id="4-10-1-问题分析">4.10.1　问题分析</h3><p>无论是查找成功还是查找不成功，都需要若干次比较才能判断出结果，那么如何查找才能使平均比较次数最小呢？</p><ul><li>如果使用顺序查找，能不能使平均查找次数最小呢？</li><li>因为序列是有序的，顺序查找有点笨，折半查找怎样呢？</li><li>折半查找是在查找概率相等的情况下折半的，查找概率不等的情况又如何呢？</li><li>在有序、查找概率不同的情况下，采用二叉搜索树能否使平均比较次数最小呢？</li><li>如何构建最优二叉搜索树？</li></ul><p>首先我们要了解二叉搜索树。</p><p>二叉搜索树（Binary Search Tree，BST），又称为二叉查找树，它是一棵二叉树（每个结点最多有两个孩子），而且左子树结点&lt;根结点，右子树结点&gt;根结点。</p><p>最优二叉搜索树（Optimal Binary Search Tree，OBST）是搜索成本最低的二叉搜索树，即平均比较次数最少。</p><p>例如，关键字{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub>6</sub>}的搜索概率是{p<sub class="my_markdown">1</sub>，p<sub>2</sub>，…，p<sub>6</sub>}，查找不成功的结点{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub>6</sub>}的搜索概率为{q<sub>0</sub>，q<sub class="my_markdown">1</sub>，…，q<sub>6</sub>}，其对应的数值如表4-2所示。</p><center class="my_markdown"><b class="my_markdown">表4-2　查找概率</b></center><p><img src="https://source.drie.cn/qxsf-images/450.jpg" alt="code"><br>接下来，我们通过构建不同的二叉搜索树来分别看其搜索成本（平均比较次数)。</p><p>第1种二叉搜索树如图4-100所示。</p><p><img src="https://source.drie.cn/qxsf-images/451.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-100　二叉搜索数树1</b></center><p>首先分析关键字结点的搜索成本，搜索每一个关键字需要 <strong>比较的次数是其所在的深度+1</strong> 。例如关键字5，需要比较1次（深度为0），查找成功；关键字12，需要首先和树根5比较，比5大，找其右子树，和右子树的根9比较，比9大，找其右子树，和右子树的根12比较，相等，查找成功，比较了3次（结点12的深度为2）。因此每个关键字结点的搜索成本=（结点的深度+1）*搜索概率=(depth(s<sub class="my_markdown">i</sub>)+1)*p<sub class="my_markdown">i</sub>。</p><p>我们再看虚结点，即查找不成功的情况的搜索成本，每一个虚结点需要 <strong>比较的次数是其所在的深度</strong> 。虚结点e<sub class="my_markdown">0</sub>需要比较1次（深度为1），即和数据5比较，如果小于5，则落入虚结点e<sub class="my_markdown">0</sub>位置，查找失败。虚结点e<sub>1</sub>需要比较2次（深度为2），需要首先和树根5比较，比5大，找其右子树，和右子树的根9比较，比9小，找其左子树，则落入虚结点e<sub>1</sub>位置，查找失败，比较了2次（虚结点e<sub>1</sub>的深度为2）。因此每个虚结点的搜索成本=结点的深度*搜索概率=(depth(e<sub class="my_markdown">i</sub>))*q<sub class="my_markdown">i</sub>。</p><p>二叉搜索树1的搜索成本为：</p><p><img src="https://source.drie.cn/qxsf-images/452.gif" alt="code"><br>图4-100的搜索成本为：</p><p><img src="https://source.drie.cn/qxsf-images/453.gif" alt="code"><br>接下来看第2个二叉搜索树，如图4-101所示。</p><p><img src="https://source.drie.cn/qxsf-images/454.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-101　二叉搜索数树2</b></center><p>图4-101的搜索成本为：</p><p><img src="https://source.drie.cn/qxsf-images/455.gif" alt="code"><br>第1个二叉搜索树相当于顺序查找（高度最大），第2个二叉搜索树相当于折半查找（平衡树)，我们再看第3个二叉搜索树，如图4-102所示。</p><p><img src="https://source.drie.cn/qxsf-images/456.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-102　二叉搜索数树3</b></center><p>图4-102的搜索成本为：</p><p><img src="https://source.drie.cn/qxsf-images/457.gif" alt="code"><br>第3个图搜索成本又降到了2.52，有没有可能继续降低呢？</p><p>可能很多人会想到，搜索概率大的离根越近，那么总的成本就会更低，这其实就是哈夫曼思想。但是因为二叉搜索树需要满足（左子树&lt;根，右子树&gt;根）的性质，那么每次选取时就不能保证一定搜索概率大的结点。所以哈夫曼思想无法构建最优二叉搜索树。那么怎么找到最优解呢？我们很难确定目前得到的就是最优解，如果采用暴力穷举所有的情况，一共有O(4<sup class="my_markdown">n</sup>/n<sup>3/2</sup>)棵不同的二叉搜索树，这可是指数级的数量！显然是不可取的。</p><p>那么如何才能构建一棵最优二叉搜索树呢？</p><p>我们来分析该问题是否具有最优子结构性质：</p><p>（1）分析最优解的结构特征</p><ul><li>原问题为有序序列{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">n</sub>}，对应虚结点是{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">n</sub>}。假设我们已经知道了s<sub class="my_markdown">k</sub>是二叉搜索树T(1，n)的根，那么原问题就变成了两个子问题：{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">k</sub><sub>-1</sub>}和{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">k</sub><sub>−1</sub>}构成的左子树T(1，k−1)，{s<sub class="my_markdown">k</sub><sub>+1</sub>，s<sub class="my_markdown">k</sub><sub>+2</sub>，…，s<sub class="my_markdown">n</sub>}和{e<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub><sub>+1</sub>，…，e<sub class="my_markdown">n</sub>}构成的右子树T(k+1，n)。如图4-103所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/458.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-103　原问题分解为子问题</b></center><ul><li>我们只需要证明：如果T(1，n)是最优二叉搜索树，那么它的左子树T(1，k−1)和右子树T(k+1，n)也是最优二叉搜索树。即证明了最优子结构性质。</li></ul><p><strong>反证法：</strong> 假设T’ (1，k−1)是比T(1，k−1)更优的二叉搜索树，则T’(1，k−1)的搜索成本比T(1，k−1)的搜索成本小，因此由T’ (1，k−1)、s<sub class="my_markdown">k</sub>、T(k+1，n) 组成的二叉搜索树T’ (1，n)的搜索成本比T(1，n)的搜索成本小。T’ (1，n)是最优二叉搜索树，与假设T(1，n)是最优二叉搜索树矛盾。问题得证。</p><p>（2）建立最优值的递归式</p><p>先看看原问题最优解和子问题最优解的关系：用<strong>c</strong>[i][j]表示{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，…，s<sub class="my_markdown">j</sub>}和{e<sub class="my_markdown">i</sub><sub>−1</sub>，e<sub class="my_markdown">i</sub>，…，e<sub class="my_markdown">j</sub>}构成的最优二叉搜索树的搜索成本。</p><ul><li>两个子问题（如图4-104所示）的搜索成本分别是<strong>c</strong>[i][k−1]和<strong>c</strong>[k+1][j]。</li></ul><p><img src="https://source.drie.cn/qxsf-images/459.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-104　两个子问题</b></center><p>子问题1包含的结点：{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，…，s<sub class="my_markdown">k</sub><sub>−1</sub>}和{e <sub class="my_markdown">i</sub><sub>−1</sub>，e<sub class="my_markdown">i</sub>，…，e<sub class="my_markdown">k</sub><sub>−1</sub>}。</p><p>子问题2包含的结点：{s<sub class="my_markdown">k</sub><sub>+1</sub>，s<sub class="my_markdown">k</sub><sub>+2</sub>，…，s<sub class="my_markdown">j</sub>}和{e<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub><sub>+1</sub>，…，e<sub class="my_markdown">j</sub>}。</p><ul><li>把两个子问题和s<sub class="my_markdown">k</sub>一起构建成一棵二叉搜索树，如图4-105所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/460.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-105　原问题和子问题</b></center><p>在构建的新树中，左子树和右子树中所有的结点深度增加了1，因为实结点搜索成本=（深度+1）<em>搜索概率p，虚结点搜索成本=深度</em>搜索概率q。</p><p>左子树和右子树中所有的结点深度增加了1，相当于搜索成本 <strong>增加了</strong> 这些结点的搜索概率之和， <strong>加上</strong> s<sub class="my_markdown">k</sub>结点的搜索成本p<sub class="my_markdown">k</sub>，总的增加成本用<strong>w</strong>[i][j]表示。</p><p><img src="https://source.drie.cn/qxsf-images/461.jpg" alt="code"><br>所有结点顺序排列一起：{e<sub class="my_markdown">i</sub><sub>−1</sub>，s<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>，…，s<sub class="my_markdown">k</sub>，e<sub class="my_markdown">k</sub>，…，s<sub class="my_markdown">j</sub>，e<sub class="my_markdown">j</sub>}，它们的概率之和为：</p><p><strong>w</strong>[i][j]=q<sub class="my_markdown">i</sub><sub>−1</sub>+p<sub class="my_markdown">i</sub>+q<sub class="my_markdown">i</sub>+…+ p<sub class="my_markdown">k</sub>+q<sub class="my_markdown">k</sub>+…+p<sub class="my_markdown">j</sub>+q<sub class="my_markdown">j</sub></p><p>最优二叉搜索树的搜索成本为：</p><p><strong>c</strong>[i][j]= <strong>c</strong>[i][k−1]+<strong>c</strong>[k+1][j]+ <strong>w</strong>[i][j]</p><p>因为我们并不确定k的值到底是多少，因此在<img class="my_markdown" src="https://source.drie.cn/qxsf-images/462.gif" style="width:73px;  height: 17px; "/>的范围内找最小值即可。</p><p>（3）因此最优二叉搜索树的最优值递归式：</p><p><img src="https://source.drie.cn/qxsf-images/463.gif" alt="code"><br><strong>w</strong>[i][j]也可以使用递推的形式，而没有必要每次都从q<sub class="my_markdown">i</sub><sub>-1</sub>加到q<sub class="my_markdown">j</sub>。</p><p><img src="https://source.drie.cn/qxsf-images/464.gif" alt="code"><br>这同样也是动态规划的查表法。</p><h3 id="4-10-2-算法设计">4.10.2　算法设计</h3><p>采用自底向上的方法求最优解，分为不同规模的子问题，对于每一个小的决策都求最优</p><p>（1）确定合适的数据结构</p><p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T(i，j)的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T(i，j)中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T(i，j)的根节点序号。</p><p>（2）初始化</p><p>输入实结点的个数n，然后依次输入实结点的搜索概率存储在p[i]中，依次输入虚结点的搜索概率存储在q[i]中。令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i= 1，2，3，…，n+1。</p><p>（3）循环阶段</p><ul><li>按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n。</li><li>按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n−1。</li><li>以此类推，直到求出所有元素{s<sub class="my_markdown">1</sub>，…，s<sub class="my_markdown">n</sub>} 的最优二叉搜索树搜索成本<strong>c</strong>[1][n]和最优策略<strong>s</strong>[1][n]。</li></ul><p>（4）构造最优解</p><ul><li>首先读取<strong>s</strong>[1][n]，令k=<strong>s</strong>[1][n]，输出s<sub class="my_markdown">k</sub>为最优二叉搜索树的根。</li><li>判断如果k−1&lt;1，表示虚结点e<sub class="my_markdown">k</sub><sub>−1</sub>是s<sub class="my_markdown">k</sub>的左子树；否则，递归求解左子树Construct_ Optimal_BST(1,k−1,1)。</li><li>判断如果k<strong>≥</strong>n，输出虚结点e<sub class="my_markdown">k</sub>是s<sub class="my_markdown">k</sub>的右孩子；否则，输出<strong>s</strong>[k+1][n]是s<sub class="my_markdown">k</sub>的右孩子，递归求解右子树Construct_Optimal_BST(k+1，n，1)。</li></ul><h3 id="4-10-3-完美图解">4.10.3　完美图解</h3><p>假设我们现在有6个关键字{s<sub class="my_markdown">1</sub>，s<sub>2</sub>，…，s<sub class="my_markdown">6</sub>}的搜索概率是{p<sub class="my_markdown">1</sub>，p<sub>2</sub>，…，p<sub class="my_markdown">6</sub>}，查找不成功的结点{e<sub>0</sub>，e<sub class="my_markdown">1</sub>，…，e<sub class="my_markdown">6</sub>}的搜索概率为{q<sub>0</sub>，q<sub class="my_markdown">1</sub>，…，q<sub class="my_markdown">6</sub>}，其对应的数值如图4-106和图4-107所示。</p><p><img src="https://source.drie.cn/qxsf-images/465.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-106　实结点的搜索概率</b></center><p><img src="https://source.drie.cn/qxsf-images/466.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-107　虚结点的搜索概率</b></center><p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T(i，j)的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T(i，j)中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T(i，j)的根节点序号，即取得最小值时的k值。</p><p>（1）初始化</p><p>n=6，令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i=1，2，3，…，n+1，如图4-108所示。</p><p><img src="https://source.drie.cn/qxsf-images/467.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-108　概率之和以及最优二叉树搜索成本</b></center><p>（2）按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=1：k=1。</li></ul><p>为了形象表达，我们把虚结点和实结点的搜索概率按顺序放在一起，用圆圈和阴影部分表示<strong>w</strong>[][]，如图4-109所示。</p><p><img src="https://source.drie.cn/qxsf-images/470.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-109　概率之和**w**[1][1]</b></center><p><strong>w</strong>[1][1]= <strong>w</strong>[1][0]+p<sub class="my_markdown">1</sub>+q<sub class="my_markdown">1</sub>=0.06+0.04+0.08=0.18；</p><p><strong>c</strong>[1][1]= min{<strong>c</strong>[1][0]，<strong>c</strong>[2][1] }+ <strong>w</strong>[1][1] =0.18；</p><p><strong>s</strong>[1][1]=1。</p><ul><li>i=2，j=2：k=2。如图4-110所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/471.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-110　概率之和**w**[2][2]</b></center><p><strong>w</strong>[2][2]= <strong>w</strong>[2][1]+p<sub class="my_markdown">2</sub>+q<sub class="my_markdown">2</sub>=0.08+0.09+0.10=0.27；</p><p><strong>c</strong>[2][2]= min{<strong>c</strong>[2][1]，<strong>c</strong>[3][2] }+ <strong>w</strong>[2][2] =0.27；</p><p><strong>s</strong>[2][2]=2。</p><ul><li>i=3，j=3：k=3。如图4-111所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/472.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-111　概率之和**w**[3][3]</b></center><p><strong>w</strong>[3][3]= <strong>w</strong>[3][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.10+0.08+0.07=0.25；</p><p><strong>c</strong>[3][3]= min{<strong>c</strong>[3][2]，<strong>c</strong>[4][3] }+ <strong>w</strong>[3][3] =0.25；</p><p><strong>s</strong>[3][3]=3。</p><ul><li>i=4，j=4：k=4。如图4-112所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/473.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-112　概率之和**w**[4][4]</b></center><p><strong>w</strong>[4][4]= <strong>w</strong>[4][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.07+0.02+0.05=0.14；</p><p><strong>c</strong>[1][1]= min{<strong>c</strong>[1][0]，<strong>c</strong>[2][1] }+ <strong>w</strong>[1][1] =0.14；</p><p><strong>s</strong>[4][4]=4。</p><ul><li>i=5，j=5：k=5。如图4-113所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/474.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-113　概率之和**w**[5][5]</b></center><p><strong>w</strong>[5][5]= <strong>w</strong>[5][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.05+0.12+0.05=0.22；</p><p><strong>c</strong>[5][5]= min{<strong>c</strong>[5][4]，<strong>c</strong>[6][5] }+ <strong>w</strong>[5][5] =0.22；</p><p><strong>s</strong>[5][5]=5。</p><ul><li>i=6，j=6：k=6。如图4-114所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/475.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-114　概率之和**w**[6][6]</b></center><p><strong>w</strong>[6][6]= <strong>w</strong>[6][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.05+0.14+0.10=0.29；</p><p><strong>c</strong>[6][6]= min{<strong>c</strong>[6][5]，<strong>c</strong>[7][6] }+ <strong>w</strong>[6][6] =0.29；</p><p><strong>s</strong>[6][6]=6。</p><p>计算完毕，概率之和以及最优二叉树搜索成本如图4-115所示。最优策略如图4-116所示。</p><p><img src="https://source.drie.cn/qxsf-images/476.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-115　概率之和以及最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/477.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-116　最优二叉树的最优策略</b></center><p>（3）按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i= 1，2，3，…，n−1。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=2。如图4-117所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/478.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-117　概率之和**w**[1][2]</b></center><p><strong>w</strong>[1][2]= <strong>w</strong>[1][1]+p<sub class="my_markdown">2</sub>+q<sub class="my_markdown">2</sub>=0.18+0.09+0.10=0.37；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/479.gif" alt="code"><br><strong>s</strong>[1][2]=2。</p><ul><li>i=2，j=3。如图4-118所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/480.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-118　概率之和**w**[2][3]</b></center><p><strong>w</strong>[2][3]= <strong>w</strong>[2][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.27+0.08+0.07=0.42；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/481.gif" alt="code"><br><strong>s</strong>[2][3]=2。</p><ul><li>i=3，j=4。如图4-119所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/482.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-119　概率之和**w**[3][4]</b></center><p><strong>w</strong>[3][4]= <strong>w</strong>[3][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.25+0.02+0.05=0.32；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/483.gif" alt="code"><br><strong>s</strong>[3][4]=3。</p><ul><li>i=4，j=5。如图4-120所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/484.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-120　概率之和**w**[4][5]</b></center><p><strong>w</strong>[4][5]= <strong>w</strong>[4][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.14+0.12+0.05=0.31；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/485.gif" alt="code"><br><strong>s</strong>[4][5]=5。</p><ul><li>i=5，j=6。如图4-121所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/486.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-121　概率之和**w**[5][6]</b></center><p><strong>w</strong>[5][6]= <strong>w</strong>[5][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.22+0.14+0.10=0.46；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/487.gif" alt="code"><br><strong>s</strong>[5][6]=6。</p><p>计算完毕。概率之和以及最优二叉树搜索成本如图4-122所示，最优策略如图4-123所示。</p><p><img src="https://source.drie.cn/qxsf-images/488.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-122　概率之和以及最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/489.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-123　最优策略</b></center><p>（4）按照递归式计算元素规模是3的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>}（j=i+2）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，4。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=3。如图4-124所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/490.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-124　概率之和**w**[1][3]</b></center><p><strong>w</strong>[1][3]= <strong>w</strong>[1][2]+p<sub class="my_markdown">3</sub>+q<sub class="my_markdown">3</sub>=0.37+0.08+0.07=0.52；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/491.gif" alt="code"><br><strong>s</strong>[1][3]=2。</p><ul><li>i=2，j=4。如图4-125所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/492.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-125　概率之和**w**[2][4]</b></center><p><strong>w</strong>[2][4]= <strong>w</strong>[2][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.42+0.02+0.05=0.49；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/493.gif" alt="code"><br><strong>s</strong>[2][4]=3。</p><ul><li>i=3，j=5。如图4-126所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/494.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-126　概率之和**w**[3][5]</b></center><p><strong>w</strong>[3][5]= <strong>w</strong>[3][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.32+0.12+0.05=0.49；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/495.gif" alt="code"><br><strong>s</strong>[3][5]=3。</p><ul><li>i=4，j=6。如图4-127所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/496.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-127　概率之和**w**[4][6]</b></center><p><strong>w</strong>[4][6]= <strong>w</strong>[4][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.31+0.14+0.10=0.55；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/497.gif" alt="code"><br><strong>s</strong>[4][6]=5。</p><p>计算完毕。概率之和以及最优二叉树搜索成本如图4-128所示，最优策略如图4-129所示。</p><p><img src="https://source.drie.cn/qxsf-images/498.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-128　概率之和以及最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/499.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-129　最优策略</b></center><p>（5）按照递归式计算元素规模是4的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>}（j=i+3）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=4。如图4-130所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/500.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-130　概率之和**w**[1][4]</b></center><p><strong>w</strong>[1][4]= <strong>w</strong>[1][3]+p<sub class="my_markdown">4</sub>+q<sub class="my_markdown">4</sub>=0.52+0.02+0.05=0.59；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/501.gif" alt="code"><br><strong>s</strong>[1][4]=2。</p><ul><li>i=2，j=5。如图4-131所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/502.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-131　概率之和**w**[2][5]</b></center><p><strong>w</strong>[2][5]= <strong>w</strong>[2][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.49+0.12+0.05=0.66；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/503.gif" alt="code"><br><strong>s</strong>[2][5]=3。</p><ul><li>i=3，j=6。如图4-132所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/504.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-132　概率之和**w**[3][6]</b></center><p><strong>w</strong>[3][6]= <strong>w</strong>[3][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.49+0.14+0.10=0.73；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/505.gif" alt="code"><br><strong>s</strong>[3][6]=5。</p><p>计算完毕。概率之和以及最优二叉树搜索成本如图4-133所示，最优策略如图4-134所示。</p><p><img src="https://source.drie.cn/qxsf-images/506.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-133　概率之和以及最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/507.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-134　最优策略</b></center><p>（6）按照递归式计算元素规模是5的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>，s<sub class="my_markdown">i</sub><sub>+4</sub>}（j=i+4）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=5。如图4-135所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/508.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-135　概率之和**w**[1][5]</b></center><p><strong>w</strong>[1][5]= <strong>w</strong>[1][4]+p<sub class="my_markdown">5</sub>+q<sub class="my_markdown">5</sub>=0.59+0.12+0.05=0.76；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/509.gif" alt="code"><br><strong>s</strong>[1][5]=3。</p><ul><li>i=2，j=6。如图4-136所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/510.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-136　概率之和**w**[2][6]</b></center><p><strong>w</strong>[2][6]= <strong>w</strong>[2][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.66+0.14+0.10=0.90；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/511.gif" alt="code"><br><strong>s</strong>[2][6]=5。</p><p>计算完毕。概率之和以及最优二叉树搜索成本如图4-137所示，最优策略如图4-138所示。</p><p><img src="https://source.drie.cn/qxsf-images/512.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-137　概率之和以及最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/513.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-138　最优策略</b></center><p>（7）按照递归式计算元素规模是6的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>，s<sub class="my_markdown">i</sub><sub>+2</sub>，s<sub class="my_markdown">i</sub><sub>+3</sub>，s<sub class="my_markdown">i</sub><sub>+4</sub>，s<sub class="my_markdown">i</sub><sub>+5</sub>}（j=i+5）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1。</p><p><img src="https://source.drie.cn/qxsf-images/468.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/469.gif" alt="code"></p><ul><li>i=1，j=6。如图4-139所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/514.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-139　概率之和**w**[1][6]</b></center><p><strong>w</strong>[1][6]= <strong>w</strong>[1][5]+p<sub class="my_markdown">6</sub>+q<sub class="my_markdown">6</sub>=0.76+0.14+0.10=1.00；</p><p>；</p><p><img src="https://source.drie.cn/qxsf-images/515.gif" alt="code"><br><strong>s</strong>[1][6]=5。</p><p>计算完毕。概率之和以及最优二叉树搜索成本如图4-140所示，最优策略如图4-141所示。</p><p><img src="https://source.drie.cn/qxsf-images/516.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-140　概率之和和最优二叉树搜索成本</b></center><p><img src="https://source.drie.cn/qxsf-images/517.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-141　最优决策</b></center><p>（8）构造最优解</p><ul><li>首先读取<strong>s</strong>[1][6]=5，k=5，输出s<sub class="my_markdown">5</sub>为最优二叉搜索树的根。</li></ul><p>判断如果k−1<strong>≥</strong>1，读取<strong>s</strong>[1][4]=2，输出s<sub class="my_markdown">2</sub>为s<sub>5</sub>的左孩子；递归求解左子树T（1，4）；判断如果k&lt;6，读取<strong>s</strong>[6][6]=6，输出s<sub>6</sub>为s<sub>5</sub>的右孩子；递归求解右子树T（6，6），如图4-142所示。</p><p><img src="https://source.drie.cn/qxsf-images/518.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-142　最优解构造过程</b></center><ul><li>递归求解左子树T（1，4）。</li></ul><p>首先读取<strong>s</strong>[1][4]=2，k=2。</p><p>判断如果k−1<strong>≥</strong>1，读取<strong>s</strong>[1][1]=1，输出s<sub class="my_markdown">1</sub>为s<sub>2</sub>的左孩子；判断如果k&lt;4，读取<strong>s</strong>[3][4]=3，输出s<sub>3</sub>为s<sub>2</sub>的右孩子；递归求解右子树T（3，4），如图4-143所示。</p><p><img src="https://source.drie.cn/qxsf-images/519.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-143　最优解构造过程</b></center><ul><li>递归求解左子树T（1，1）。</li></ul><p>首先读取<strong>s</strong>[1][1]=1，k=1。</p><p>判断如果k−1&lt;1，输出e<sub class="my_markdown">0</sub>为s<sub>1</sub>的左孩子；判断如果k<strong>≥</strong>1，输出e<sub>1</sub>为s<sub>1</sub>的右孩子，如图4-144所示。</p><p><img src="https://source.drie.cn/qxsf-images/520.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-144　最优解构造过程</b></center><ul><li>递归求解右子树T（3，4）。</li></ul><p>首先读取<strong>s</strong>[3][4]=3，k=3。</p><p>判断如果k−1&lt;3，输出e<sub class="my_markdown">2</sub>为s<sub>3</sub>的左孩子；判断如果k&lt;4，读取<strong>s</strong>[4][4]=4，输出s<sub>4</sub>为s<sub>3</sub>的右孩子；递归求解右子树T（4，4），如图4-145所示。</p><p><img src="https://source.drie.cn/qxsf-images/521.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-145　最优解构造过程</b></center><ul><li>递归求解右子树T（4，4）。</li></ul><p>首先读取<strong>s</strong>[4][4]=4，k=4。</p><p>判断如果k−1&lt;4，输出e<sub class="my_markdown">3</sub>为s<sub>4</sub>的左孩子；判断如果k<strong>≥</strong>4，输出e<sub>4</sub>为s<sub>4</sub>的右孩子，如图4-146所示。</p><p><img src="https://source.drie.cn/qxsf-images/522.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-146　最优解构造过程</b></center><ul><li>递归求解右子树T（6，6）。</li></ul><p>首先读取<strong>s</strong>[6][6]=6，k=6。</p><p>判断如果k−1&lt;6，输出e<sub class="my_markdown">5</sub>为s<sub>6</sub>的左孩子；判断如果k<strong>≥</strong>6，输出e<sub>6</sub>为s<sub>6</sub>的右孩子，如图4-147所示。</p><p><img src="https://source.drie.cn/qxsf-images/523.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图4-147　最优解构造过程</b></center><h3 id="4-10-4-伪代码详解">4.10.4　伪代码详解</h3><p>（1）构建最优二叉搜索树</p><p>采用一维数组p[]、q[]分别记录实结点和虚结点的搜索概率，<strong>c</strong>[i][j]表示最优二叉搜索树T（i，j）的搜索成本，<strong>w</strong>[i][j]表示最优二叉搜索树T（i，j）中的所有实结点和虚结点的搜索概率之和，<strong>s</strong>[i][j]表示最优二叉搜索树T（i，j）的根节点序号。首先初始化，令<strong>c</strong>[i][i−1]=0.0，<strong>w</strong>[i][i−1]=q[i−1]，其中i= 1，2，3，…，n+1。按照递归式计算元素规模是1的{s<sub class="my_markdown">i</sub>}（j=i）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，…，n。按照递归式计算元素规模是2的{s<sub class="my_markdown">i</sub>，s<sub class="my_markdown">i</sub><sub>+1</sub>}（j=i+1）的最优二叉搜索树搜索成本<strong>c</strong>[i][j]，并记录最优策略，即树根<strong>s</strong>[i][j]，i=1，2，3，…，n−1。以此类推，直到求出所有元素{s<sub>1</sub>，…，s<sub class="my_markdown">n</sub>} 的最优二叉搜索树搜索成本<strong>c</strong>[1][n]和最优策略<strong>s</strong>[1][n]。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)                 <span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               c[i][j]=c[i][i<span class="number">-1</span>]+c[i+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i;                  <span class="comment">//初始化</span></span><br><span class="line">               <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=j;k++) <span class="comment">//选取i+1到i之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较，fabs(temp-c[i][j])&gt;1E-6表示两者不相等</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;        <span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）构造最优解</p><p>Construct_Optimal_BST(int i,int j,bool flag)表示构建从结点i到结点j的最优二叉搜索树。首次调用时，flag=0、i=1、j=n，表示首次构建，读取的第一个数值<strong>s</strong>[1][n]为树根，其他递归调用flag=1。</p><p>Construct_Optimal_BST(int i,int j,bool flag)：首先读取<strong>s</strong>[i][j]，令k=<strong>s</strong>[i][j]，判断如果k−1&lt;i，表示虚结点e<sub class="my_markdown">k</sub><sub>−1</sub>是s<sub class="my_markdown">k</sub>的左子树；否则，递归求解左子树Construct_Optimal_BST(i，k−1，1)。判断如果k<strong>≥</strong>j，输出虚结点e<sub class="my_markdown">k</sub>是s<sub class="my_markdown">k</sub>的右孩子；否则，输出<strong>s</strong>[k+1][j]是s<sub class="my_markdown">k</sub>的右孩子，递归求解右子树Construct_Optimal_BST(k +1，j，1)。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">           flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-10-5-实战演练">4.10.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>                            <span class="comment">//求绝对值函数需要引入该头文件</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> c[M][M],w[M][M],p[M],q[M];</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line"><span class="type">int</span> n,i,j,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)                 <span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               c[i][j]=c[i][i<span class="number">-1</span>]+c[i+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i;                  <span class="comment">//初始化</span></span><br><span class="line">               <span class="comment">//选取i+1到j之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               <span class="keyword">for</span>(k=i+<span class="number">1</span>;k&lt;=j;k++)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较，fabs(temp-c[i][j])&gt;1E-6表示两者不相等</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;<span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入关键字的个数n：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入每个关键字的搜索概率：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个虚结点的搜索概率：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">      Optimal_BST();</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最小的搜索成本为：&quot;</span>&lt;&lt;c[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最优二叉搜索树为：&quot;</span>;</span><br><span class="line">      Construct_Optimal_BST(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法实现和测试</p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入关键字的个数n：<span class="number">6</span></span><br><span class="line">请依次输入每个关键字的搜索概率：</span><br><span class="line"><span class="number">0.04</span> <span class="number">0.09</span> <span class="number">0.08</span> <span class="number">0.02</span> <span class="number">0.12</span> <span class="number">0.14</span></span><br><span class="line">请依次输入每个虚结点的搜索概率：</span><br><span class="line"><span class="number">0.06</span> <span class="number">0.08</span> <span class="number">0.10</span> <span class="number">0.07</span> <span class="number">0.05</span> <span class="number">0.05</span> <span class="number">0.10</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">最小的搜索成本为：<span class="number">2.52</span></span><br><span class="line">最优二叉搜索树为：</span><br><span class="line">S5 是根</span><br><span class="line">S2 is the left child of S5</span><br><span class="line">S1 is the left child of S2</span><br><span class="line">e0 is the left child of S1</span><br><span class="line">e1 is the right child of S1</span><br><span class="line">S3 is the right child of S2</span><br><span class="line">e2 is the left child of S3</span><br><span class="line">S4 is the right child of S3</span><br><span class="line">e3 is the left child of S4</span><br><span class="line">e4 is the right child of S4</span><br><span class="line">S6 is the right child of S5</span><br><span class="line">e5 is the left child of S6</span><br><span class="line">e6 is the right child of S6</span><br></pre></td></tr></table></figure><h3 id="4-10-6-算法解析及优化拓展">4.10.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-8">1．算法复杂度分析</h4><p>（1）时间复杂度：算法中有3层嵌套的for循环，其时间复杂度为O(n<sup class="my_markdown">3</sup>)。</p><p>（2）空间复杂度：使用了3个二维数组求解<strong>c</strong>[i][j]、<strong>w</strong>[i][j]、<strong>s</strong>[i][j]，所以空间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><h4 id="2．算法优化拓展-8">2．算法优化拓展</h4><p>如果按照普通的区间动态规划进行求解，时间复杂度是O(n<sup class="my_markdown">3</sup>)，但可以用四边形不等式优化。</p><p>!/524.gif)<br><strong>s</strong>[i][j]表示取得最优解<strong>c</strong>[i][j]的最优策略位置。</p><p>k的取值范围缩小了很多，原来是区间[i，j]，现在变为区间[<strong>s</strong>[i][j−1]，<strong>s</strong>[i+1][j]]。经过优化，算法时间复杂度可以减少至O(n<sup class="my_markdown">2</sup>)，时间复杂度的计算可参看4.8.6节。</p><p>优化后算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 4-8-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span>           <span class="comment">//求绝对值函数需要引入该头文件</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000</span>+<span class="number">5</span>;</span><br><span class="line"><span class="type">double</span> c[M][M],w[M][M],p[M],q[M];</span><br><span class="line"><span class="type">int</span> s[M][M];</span><br><span class="line"><span class="type">int</span> n,i,j,k;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Optimal_BST</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">          c[i][i<span class="number">-1</span>]=<span class="number">0.0</span>;</span><br><span class="line">          w[i][i<span class="number">-1</span>]=q[i<span class="number">-1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> t=<span class="number">1</span>;t&lt;=n;t++)<span class="comment">//t为关键字的规模</span></span><br><span class="line">          <span class="comment">//从下标为i开始的关键字到下标为j的关键字</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n-t+<span class="number">1</span>;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               j=i+t<span class="number">-1</span>;</span><br><span class="line">               w[i][j]=w[i][j<span class="number">-1</span>]+p[j]+q[j];</span><br><span class="line">               <span class="type">int</span> i1=s[i][j<span class="number">-1</span>]&gt;i?s[i][j<span class="number">-1</span>]:i;</span><br><span class="line">               <span class="type">int</span> j1=s[i+<span class="number">1</span>][j]&lt;j?s[i+<span class="number">1</span>][j]:j;</span><br><span class="line">               c[i][j]=c[i][i1<span class="number">-1</span>]+c[i1+<span class="number">1</span>][j];<span class="comment">//初始化</span></span><br><span class="line">               s[i][j]=i1;<span class="comment">//初始化</span></span><br><span class="line">               <span class="comment">//选取i1+1到j1之间的某个下标的关键字作为从i到j的根，如果组成的树的期望值当前最小，则k为从i到j的根节点</span></span><br><span class="line">               <span class="keyword">for</span>(k=i1+<span class="number">1</span>;k&lt;=j1;k++)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="type">double</span> temp=c[i][k<span class="number">-1</span>]+c[k+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(temp&lt;c[i][j]&amp;&amp;<span class="built_in">fabs</span>(temp-c[i][j])&gt;<span class="number">1E-6</span>)<span class="comment">//C++中浮点数因为精度问题不可以直接比较</span></span><br><span class="line">                    &#123;</span><br><span class="line">                         c[i][j]=temp;</span><br><span class="line">                         s[i][j]=k;<span class="comment">//k即为从下标i到j的根节点</span></span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               c[i][j]+=w[i][j];</span><br><span class="line">          &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Construct_Optimal_BST</span><span class="params">(<span class="type">int</span> i,<span class="type">int</span> j,<span class="type">bool</span> flag)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(flag==<span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][j]&lt;&lt;<span class="string">&quot; 是根&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          flag=<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> k=s[i][j];</span><br><span class="line">     <span class="comment">//如果左子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k<span class="number">-1</span>&lt;i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;k<span class="number">-1</span>&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果左子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[i][k<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; is the left child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(i,k<span class="number">-1</span>,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树是叶子</span></span><br><span class="line">     <span class="keyword">if</span>(k&gt;=j)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;e&quot;</span>&lt;&lt;j&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//如果右子树不是叶子</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;s[k+<span class="number">1</span>][j]&lt;&lt;<span class="string">&quot; is the right child of &quot;</span>&lt;&lt;<span class="string">&quot;S&quot;</span>&lt;&lt;k&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          Construct_Optimal_BST(k+<span class="number">1</span>,j,<span class="number">1</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入关键字的个数 n:&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入每个关键字的搜索概率:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=n; i++ )</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;p[i];</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请依次输入每个虚结点的搜索概率:&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;=n; i++)</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;q[i];</span><br><span class="line">     Optimal_BST();</span><br><span class="line">     <span class="comment">// /*用于测试</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; w[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n+<span class="number">1</span>;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; c[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">            <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;i;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-1</span>; j&lt;=n;j++)</span><br><span class="line">              <span class="built_in">cout</span> &lt;&lt; s[i][j]&lt;&lt;<span class="string">&quot;\t&quot;</span> ;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="comment">// */用于测试</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最小的搜索成本为：&quot;</span>&lt;&lt;c[<span class="number">1</span>][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;最优二叉搜索树为：&quot;</span>;</span><br><span class="line">     Construct_Optimal_BST(<span class="number">1</span>,n,<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-11-动态规划算法秘籍">4.11　动态规划算法秘籍</h3><p>本章通过8个实例讲解了动态规划的解题过程。动态规划求解最优化问题时需要考虑两个性质：最优子结构和子问题重叠。只要满足最优子结构性质就可以使用动态规划，如果还具有子问题重叠，则更能彰显动态规划的优势。判断可以使用动态规划后，就可以分析其最优子结构特征，找到原问题和子问题的关系，从而得到最优解递归式。然后按照最优解递归式自底向上求解，采用备忘机制（查表法）有效解决子问题重叠，重复的子问题不需要重复求解，只需查表即可。</p><p>动态规划的关键总结如下。</p><p>（1）最优子结构判定</p><ul><li>作出一个选择。</li><li>假定已经知道了哪种选择是最优的。</li></ul><p>例如矩阵连乘问题，我们假设已经知道在第k个矩阵加括号是最优的，即(<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>)(<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>)。</p><ul><li>最优选择后会产生哪些子问题。</li></ul><p>例如矩阵连乘问题，我们作出最优选择后产生两个子问题：(<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>)，(<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>)。</p><ul><li>证明原问题的最优解包含其子问题的最优解。</li></ul><p>通常使用“剪切—粘贴”反证法。证明如果原问题的解是最优解，那么子问题的解也是最优解。反证：假定子问题的解不是最优解，那么就可以将它“剪切”掉，把最优解“粘贴”进去，从而得到一个比原问题最优解更优的解，这与前提原问题的解是最优解矛盾。得证。</p><p>例如：矩阵连乘问题，c=a+b+d，我们只需要证明如果c是最优的，则a和b一定是最优的（即原问题的最优解包含子问题的最优解）。</p><p><strong>反证法：</strong> 如果a不是最优的，（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）存在一个最优解a’，a’&lt;a，那么，a’+b+d&lt;c，这与假设c是最优的矛盾，因此如果c是最优的，则a一定是最优的。同理可证b也是最优的。因此如果c是最优的，则a和b一定是最优的。因此，矩阵连乘问题具有最优子结构性质。</p><p>（2）如何得到最优解递归式</p><ul><li>分析原问题最优解和子问题最优解的关系。</li></ul><p>例如矩阵连乘问题，我们假设已经知道在第k个矩阵加括号是最优的，即（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>） （<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）。作出最优选择后产生两个子问题：（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>），（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）。如果我们用<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优解，那么两个子问题（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）、（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）对应的最优解分别是<strong>m</strong>[i][k]、<strong>m</strong>[k+1][j]。剩下的只需要考查（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）和（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>）的结果矩阵相乘的乘法次数了，两个结果矩阵相乘的乘法次数是p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。</p><p>因此，原问题最优解和子问题最优解的关系为<strong>m</strong>[i][j]=<strong>m</strong>[i][k]+<strong>m</strong>[k+1][j]+ p<sub class="my_markdown">i</sub>*p<sub class="my_markdown">k</sub><sub>+1</sub>*q<sub class="my_markdown">j</sub>。</p><ul><li>考查有多少种选择。</li></ul><p>实质上，我们并不知道哪种选择是最优的，因此就需要考查有多少种选择，然后从这些选择中找到最优解。</p><p>例如矩阵连乘问题，加括号的位置k（<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">k</sub>）（<strong>A</strong> <sub class="my_markdown">k</sub><sub>+1</sub><strong>A</strong> <sub class="my_markdown">k</sub><sub>+2</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>），k的取值范围是{i，i+1，…，j−1}，即i≤k&lt;j，那么我们考查每一种选择，找到最优值。</p><ul><li>得到最优解递归式。</li></ul><p>例如矩阵连乘问题，<strong>m</strong>[i][j]表示<strong>A</strong> <sub class="my_markdown">i</sub> <strong>A</strong> <sub class="my_markdown">i</sub><sub>+1</sub>…<strong>A</strong> <sub class="my_markdown">j</sub>矩阵连乘的最优解，根据最优解和子问题最优解的关系，并考查所有的选择，找到最小值即为最优解。</p><p><img src="https://source.drie.cn/qxsf-images/525.gif" alt="code"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第四章-动态规划&quot;&gt;第四章  动态规划&lt;/h3&gt;
&lt;p&gt;前面讲的分治法是将原问题分解为若干个规模较小、形式相同的子问题，然后求解这些子问题，合并子问题的解得到原问题的解。在分治法中，各个子问题是互不相交的，即相互独立。如果各个子问题有重叠，不是相互独立的，那么用分</summary>
      
    
    
    
    <category term="算法" scheme="https://drie.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>《趣学算法》—第三章（分治法）</title>
    <link href="https://drie.cn/posts/8f61c33e.html"/>
    <id>https://drie.cn/posts/8f61c33e.html</id>
    <published>2024-07-03T01:00:00.000Z</published>
    <updated>2024-07-03T00:59:18.709Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第三章-分治法">第三章　分治法</h3><p>分而治之是一种很古老但很实用的策略，或者说战略，本意是将一个较大的力量打碎分成小的力量，这样每个小的力量都不足以对抗大的力量。在现实应用中，分而治之往往是将大片区域分成小块区域治理。战国时期，秦国破坏合纵连横即是一种分而治之的手段。</p><h3 id="3-1-山高皇帝远">3.1　山高皇帝远</h3><p>我们经常听到一句话：“山高皇帝远”，意思是山高路远，皇帝管不了。实际上无论山多高，皇帝有多远，都在朝庭的统治之下。皇帝一个人当然不可能管那么多的事情，那么怎么统治天下呢？分而治之。我们现在的制度也采用了分而治之的办法，国家分省、市、县、镇、村，层层管理，无论哪个偏远角落，都不是无组织的。</p><h3 id="3-1-1-治众如治寡——分而治之">3.1.1　治众如治寡——分而治之</h3><p>“凡治众如治寡，分数是也。”</p><p>——《孙子兵法》</p><p>“分数”的“分”是指分各层次的部分，“数”是每部分的人数编制，意为通过把部队分为各级组织，将帅就只需通过管理少数几个人来实现管理全军众多组织。这样，管理和指挥人数众多的大军，也如同管理和指挥人数少的部队一样容易。</p><p>在我们生活当中也有很多这样的例子，例如电视节目歌唱比赛，如果全国各地的歌手都来报名参赛，那估计要累坏评委了，而且一个一个比赛需要很长的时间，怎么办呢？全国分赛区海选，每个赛区的前几名再参加二次海选，最后选择比较优秀的选手参加电视节目比赛。这样既可以把最优秀的歌手呈现给观众，又节省了很多时间，因为全国各地分赛区的海选比赛是同步进行的，有点“并行”的意思。</p><p>在算法设计中，我们也引入分而治之的策略，称为分治算法，其本质就是将一个大规模的问题分解为若干个规模较小的相同子问题，分而治之。</p><h3 id="3-1-2-天时地利人和——分治算法要素">3.1.2　天时地利人和——分治算法要素</h3><p>“农夫朴力而寡能，则上不失天时，下不失地利，中得人和而百事不废。”</p><p>——《荀子•王霸篇》</p><p>也就是说，做成一件事，需要天时地利人和。那么在现实生活中，什么样的问题才能使用分治法解决呢？简单来说，需要满足以下3个条件。</p><p>（1）原问题可分解为若干个规模较小的相同子问题。</p><p>（2）子问题相互独立。</p><p>（3）子问题的解可以合并为原问题的解。</p><h3 id="3-1-3-分治算法秘籍">3.1.3　分治算法秘籍</h3><p>分治法解题的一般步骤如下。</p><p>（1）分解：将要解决的问题分解为若干个规模较小、相互独立、与原问题形式相同的子问题。</p><p>（2）治理：求解各个子问题。由于各个子问题与原问题形式相同，只是规模较小而已，而当子问题划分得足够小时，就可以用较简单的方法解决。</p><p>（3）合并：按原问题的要求，将子问题的解逐层合并构成原问题的解。</p><p>一言以蔽之，分治法就是将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>在分治算法中，各个子问题形式相同，解决的方法也一样，因此我们可以使用递归算法快速解决，递归是彰显分治法优势的利器。</p><h3 id="3-2-猜数游戏——二分搜索技术">3.2　猜数游戏——二分搜索技术</h3><p>一天晚上，我们在家里看电视，某大型娱乐节目在玩猜数游戏。主持人在女嘉宾的手心上写一个10以内的整数，让女嘉宾的老公猜是多少，而女嘉宾只能提示大了，还是小了，并且只有3次机会。</p><p>主持人悄悄地在美女手心写了一个8。</p><p>老公：“2。”</p><p>老婆：“小了。”</p><p>老公：“3。”</p><p>老婆：“小了。”</p><p>老公：“10。”</p><p>老婆：“晕了!”</p><p>孩子说：“天啊，怎么还有这么笨的人。”那么，聪明的孩子，现在随机写1～n范围内的整数，你有没有办法以最快的速度猜出来呢？</p><p><img src="https://source.drie.cn/qxsf-images/146.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-1　猜数游戏</b></center><h3 id="3-2-1-问题分析">3.2.1　问题分析</h3><p>从问题描述来看，如果是n个数，那么最坏的情况要猜n次才能成功，其实我们没有必要一个一个地猜，因为这些数是有序的，它是一个二分搜索问题。我们可以使用折半查找的策略，每次和中间的元素比较，如果比中间元素小，则在前半部分查找（假定为升序），如果比中间元素大，则去后半部分查找。</p><h3 id="3-2-2-算法设计">3.2.2　算法设计</h3><p>问题描述：给定n个元素，这些元素是有序的（假定为升序），从中查找特定元素x。</p><p>算法思想：将有序序列分成规模大致相等的两部分，然后取中间元素与特定查找元素x进行比较，如果x等于中间元素，则查找成功，算法终止；如果x小于中间元素，则在序列的前半部分继续查找，即在序列的前半部分重复分解和治理操作；否则，在序列的后半部分继续查找，即在序列的后半部分重复分解和治理操作。</p><p>算法设计：用一维数组S[]存储该有序序列，设变量low和high表示查找范围的下界和上界，middle表示查找范围的中间位置，x为特定的查找元素。</p><p>（1）初始化。令low=0，即指向有序数组S[]的第一个元素；high=n−1，即指向有序数组S[]的最后一个元素。</p><p>（2）middle=（low+high）/2，即指示查找范围的中间元素。</p><p>（3）判定low≤high是否成立，如果成立，转第4步，否则，算法结束。</p><p>（4）判断x与S[middle]的关系。如果x=S[middle]，则搜索成功，算法结束；如果x&gt;S[middle]，则令low=middle+1；否则令high=middle−1，转为第2步。</p><h3 id="3-2-3-完美图解">3.2.3　完美图解</h3><p>用分治法在有序序列（5，8，15，17，25，30，34，39，45，52，60）中查找元素17。</p><p>（1）数据结构。用一维数组S[]存储该有序序列，x=17，如图3-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/147.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-2　S[]数组</b></center><p>（2）初始化。low=0，high=10，计算middle=（low+high）/2=5，如图3-3所示。</p><p><img src="https://source.drie.cn/qxsf-images/148.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-3　搜索初始化</b></center><p>（3）将x与S[middle]比较。x=17&lt;S[middle]=30，我们在序列的前半部分查找，搜索的范围缩小到子问题S[0…middle−1]，令high=middle−1，如图3-4所示。</p><p><img src="https://source.drie.cn/qxsf-images/149.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-4　搜索过程</b></center><p>（4）计算middle=（low+high）/2=2，如图3-5所示。</p><p><img src="https://source.drie.cn/qxsf-images/150.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-5　搜索过程</b></center><p>（5）将x与S[middle]比较。x=17&gt;S[middle]=15，我们在序列的后半部分查找，搜索的范围缩小到子问题S[middle+1…low]，令low=middle+1，如图3-6所示。</p><p><img src="https://source.drie.cn/qxsf-images/151.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-6　搜索过程</b></center><p>（6）计算middle=（low+high）/2=3，如图3-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/152.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-7　搜索过程</b></center><p>（7）将x与S[middle]比较。x=17=S[middle]=17，查找成功，算法结束。</p><h3 id="3-2-4-伪代码详解">3.2.4　伪代码详解</h3><p>我们用BinarySearch（int n，int s[]，int x）函数实现二分搜索技术，其中n为元素个数，s[]为有序数组，x为特定查找元素。low指向数组的第一个元素，high指向数组的最后一个元素。如果low≤high，middle=（low+high）/2，即指向查找范围的中间元素。如果x=S[middle]，搜索成功，算法结束；如果x&gt;S[middle]，则令low=middle+1，去后半部分搜索；否则令high=middle−1，去前半部分搜索。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s[],<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=n<span class="number">-1</span>;          <span class="comment">//low指向数组的第一个元素，high指向数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)             <span class="comment">//设置判定条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> middle=(low+high)/<span class="number">2</span>; <span class="comment">//计算middle值(查找范围的中间值) </span></span><br><span class="line">        <span class="keyword">if</span>(x==s[middle])         <span class="comment">//x等于s[middle]，查找成功，算法结束</span></span><br><span class="line">            <span class="keyword">return</span> middle; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;s[middle])     <span class="comment">//x小于s[middle]，则从前半部分查找</span></span><br><span class="line">                high=middle<span class="number">-1</span>; </span><br><span class="line">            <span class="keyword">else</span>                 <span class="comment">//x大于s[middle]，则从后半部分查找</span></span><br><span class="line">                low=middle+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-5-实战演练">3.2.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 3-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">10000</span>; </span><br><span class="line"><span class="type">int</span> x,n,i; </span><br><span class="line"><span class="type">int</span> s[M]; </span><br><span class="line"><span class="type">int</span> <span class="title function_">BinarySearch</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> s[],<span class="type">int</span> x)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low=<span class="number">0</span>,high=n<span class="number">-1</span>;         <span class="comment">//low指向数组的第一个元素，high指向数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high) </span><br><span class="line">    &#123;</span><br><span class="line">         <span class="type">int</span> middle=(low+high)/<span class="number">2</span>; <span class="comment">//middle为查找范围的中间值</span></span><br><span class="line">         <span class="keyword">if</span>(x==s[middle])      <span class="comment">//x等于查找范围的中间值，算法结束</span></span><br><span class="line">             <span class="keyword">return</span> middle; </span><br><span class="line">         <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;s[middle])  <span class="comment">//x小于查找范围的中间元素，则从前半部分查找</span></span><br><span class="line">                  high=middle<span class="number">-1</span>; </span><br><span class="line">                  <span class="keyword">else</span>         <span class="comment">//x大于查找范围的中间元素，则从后半部分查找</span></span><br><span class="line">                  low=middle+<span class="number">1</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入数列中的元素个数n为：&quot;</span>;</span><br><span class="line">     <span class="keyword">while</span>(<span class="built_in">cin</span>&gt;&gt;n) </span><br><span class="line">     &#123;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入数列中的元素：&quot;</span>;</span><br><span class="line">           <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">               <span class="built_in">cin</span>&gt;&gt;s[i]; </span><br><span class="line">           sort(s,s+n); </span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;排序后的数组为：&quot;</span>;</span><br><span class="line">           <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="built_in">cout</span>&lt;&lt;s[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">           <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入要查找的元素：&quot;</span>;</span><br><span class="line">           <span class="built_in">cin</span>&gt;&gt;x; </span><br><span class="line">           i=BinarySearch(n,s,x); </span><br><span class="line">           <span class="keyword">if</span>(i==<span class="number">-1</span>) </span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;该数列中没有要查找的元素&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">              <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;要查找的元素在第&quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;位&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入数列中的元素个数n：<span class="number">11</span></span><br><span class="line">请依次输入数列中的元素：<span class="number">60</span> <span class="number">1739</span> <span class="number">15</span> <span class="number">8</span> <span class="number">34</span> <span class="number">30</span> <span class="number">45</span> <span class="number">5</span> <span class="number">52</span> <span class="number">25</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">排序后的数组为：<span class="number">5</span> <span class="number">8</span> <span class="number">15</span> <span class="number">17</span> <span class="number">25</span> <span class="number">30</span> <span class="number">34</span> <span class="number">39</span> <span class="number">45</span> <span class="number">52</span> <span class="number">60</span></span><br><span class="line">请输入要查找的元素：<span class="number">17</span></span><br><span class="line">要查找的元素在第<span class="number">4</span>位</span><br></pre></td></tr></table></figure><h3 id="3-2-6-算法解析与拓展">3.2.6　算法解析与拓展</h3><h4 id="1．算法复杂度分析">1．算法复杂度分析</h4><p>（1）时间复杂度：首先需要进行排序，调用sort函数，进行排序复杂度为O(nlogn)，如果数列本身有序，那么这部分不用考虑。</p><p>然后是二分查找算法，时间复杂度怎么计算呢？如果我们用T(n)来表示n个有序元素的二分查找算法时间复杂度，那么：</p><ul><li>当n=1时，需要一次比较，T(n)=O(1)。</li><li>当n&gt;1时，特定元素和中间位置元素比较，需要O(1)时间，如果比较不成功，那么需要在前半部分或后半部分搜索，问题的规模缩小了一半，时间复杂度变为T(n/2)。</li></ul><p><img src="https://source.drie.cn/qxsf-images/153.gif" alt="code"></p><ul><li>当n&gt;1时，可以递推求解如下。</li></ul><p><img src="https://source.drie.cn/qxsf-images/154.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/156.gif" style="width:72px;  height: 16px; "/>。</p><p><img src="https://source.drie.cn/qxsf-images/157.gif" alt="code"><br>二分查找算法的时间复杂度为O(logn)。</p><p>（2）空间复杂度：程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为O(1)。</p><h4 id="2．优化拓展">2．优化拓展</h4><p>在上面程序中，我们采用BinarySearch（int n，int s[]，int x）函数来实现二分搜索，那么能不能用递归来实现呢？因为递归有自调用问题，那么就需要增加两个参数 low 和 high来标记搜索范围的开始和结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">recursionBS</span> <span class="params">(<span class="type">int</span> s[],<span class="type">int</span> x,<span class="type">int</span> low,<span class="type">int</span> high)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//low指向数组的第一个元素，high指向数组的最后一个元素</span></span><br><span class="line">    <span class="keyword">if</span>(low&gt;high)              <span class="comment">//递归结束条件</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">    <span class="type">int</span> middle=(low+high)/<span class="number">2</span>;  <span class="comment">//计算middle值(查找范围的中间值) </span></span><br><span class="line">    <span class="keyword">if</span>(x==s[middle])          <span class="comment">//x等于s[middle]，查找成功，算法结束</span></span><br><span class="line">        <span class="keyword">return</span> middle; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x&lt;s[middle])      <span class="comment">//x小于s[middle]，则从前半部分查找</span></span><br><span class="line">             returnrecursionBS (s[],x, low, high<span class="number">-1</span>) </span><br><span class="line">           <span class="keyword">else</span>               <span class="comment">//x大于s[middle]，则从后半部分查找</span></span><br><span class="line">             returnrecursionBS (s[],x, middle+<span class="number">1</span>, high) </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在主函数main()的调用中，只需要把BinarySearch（n，s，x）换为recursionBS（s[]，x，0，n−1）即可完成二分查找，递归算法的时间复杂度未变，因为递归调用需要使用栈来实现，空间复杂度怎么计算呢？</p><p>在递归算法中，每一次递归调用都需要一个栈空间存储，那么我们只需要看看有多少次调用。假设原问题的规模为n，那么第一次递归就分为两个规模为n/2的子问题，这两个子问题并不是每个都执行，只会执行其中之一。因为我们和中间值比较后，要么去前半部分查找，要么去后半部分查找；然后再把规模为n/2的子问题继续划分为两个规模为n/4的子问题，选择其一；继续分治下去，最坏的情况会分治到只剩下一个数值，那么我们执行的节点数就是从树根到叶子所经过的节点，每一层执行一个，直到最后一层，如图3-8所示。</p><p><img src="https://source.drie.cn/qxsf-images/158.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-8　递归求解树</b></center><p>递归调用最终的规模为1，即n/2<sup class="my_markdown">x</sup>=1，则x=logn。假设阴影部分是搜索经过的路径，一共经过了logn个节点，也就是说递归调用了logn次。</p><p>因此，二分搜索递归算法的空间复杂度为O(logn)。</p><p>那么，还有没有更好的算法来解决这个问题呢？</p><h3 id="3-3-合久必分，分久必合——合并排序">3.3　合久必分，分久必合——合并排序</h3><p>在数列排序中，如果只有一个数，那么它本身就是有序的；如果只有两个数，那么一次比较就可以完成排序。也就是说，数越少，排序越容易。那么，如果有一个由大量数据组成的数列，我们很难快速地完成排序，该怎么办呢？可以考虑将其分解为很小的数列，直到只剩一个数时，本身已有序，再把这些有序的数列合并在一起，执行一个和分解相反的过程，从而完成整个数列的排序。</p><p><img src="https://source.drie.cn/qxsf-images/159.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-9　合并排序</b></center><h3 id="3-3-1-问题分析">3.3.1　问题分析</h3><p>合并排序就是采用分治的策略，将一个大的问题分成很多个小问题，先解决小问题，再通过小问题解决大问题。由于排序问题给定的是一个无序的序列，可以把待排序元素分解成两个规模大致相等的子序列。如果不易解决，再将得到的子序列继续分解，直到子序列中包含的元素个数为1。因为单个元素的序列本身是有序的，此时便可以进行合并，从而得到一个完整的有序序列。</p><h3 id="3-3-2-算法设计">3.3.2　算法设计</h3><p>合并排序是采用分治策略实现对n个元素进行排序的算法，是分治法的一个典型应用和完美体现。它是一种平衡、简单的二分分治策略，过程大致分为：</p><p>（1）分解——将待排序元素分成大小大致相同的两个子序列。</p><p>（2）治理——对两个子序列进行合并排序。</p><p>（3）合并——将排好序的有序子序列进行合并，得到最终的有序序列。</p><h3 id="3-3-3-完美图解">3.3.3　完美图解</h3><p>给定一个列数（42，15，20，6，8，38，50，12），我们执行合并排序的过程，如图3-10所示。</p><p><img src="https://source.drie.cn/qxsf-images/160.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-10　合并排序过程</b></center><p>从上图可以看出，首先将待排序元素分成大小大致相同的两个子序列，然后再把子序列分成大小大致相同的两个子序列，如此下去，直到分解成一个元素停止，这时含有一个元素的子序列都是有序的。然后执行合并操作，将两个有序的子序列合并为一个有序序列，如此下去，直到所有的元素都合并为一个有序序列。</p><p>合久必分，分久必合！合并排序就是这个策略。</p><h3 id="3-3-4-伪代码详解">3.3.4　伪代码详解</h3><p>（1）合并操作</p><p>为了进行合并，引入一个辅助合并函数Merge（A，low，mid，high），该函数将排好序的两个子序列A[low:mid]和A[mid+1:high]进行合并。其中，low和high代表待合并的两个子序列在数组中的下界和上界，mid代表下界和上界的中间位置，如图3-11所示。</p><p><img src="https://source.drie.cn/qxsf-images/161.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-11　合并操作原始数组</b></center><p>合并方法：设置3个工作指针i、j、k（整型数）和一个辅助数组B[]。其中，i和j分别指向两个待排序子序列中当前待比较的元素，k指向辅助数组B[]中待放置元素的位置。比较A[i]和A[j]，将较小的赋值给B[k]，同时相应指针向后移动。如此反复，直到所有元素处理完毕。最后把辅助数组B中排好序的元素复制到A数组中，如图3-12所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *B = new <span class="type">int</span>[high-low+<span class="number">1</span>];<span class="comment">//申请一个辅助数组B[]  </span></span><br><span class="line"><span class="type">int</span> i = low, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/162.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-12　合并操作初始化</b></center><p>现在，我们比较A[i]和A[j]，将较小的元素放入B数组中，相应的指针向后移动，直到i&gt;mid或者j&gt;high时结束。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high)<span class="comment">//按从小到大顺序存放到辅助数组B[]中</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(A[i] &lt;= A[j]) </span><br><span class="line">          B[k++] = A[i++];  </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">          B[k++] = A[j++];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第1次比较A[i]=4和A[j]=2，将较小元素2放入B数组中，j++，k++，如图3-13所示。</p><p><img src="https://source.drie.cn/qxsf-images/163.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-13　合并过程</b></center><p>第2次比较A[i]=4和A[j]=6，将较小元素4放入B数组中，i++，k++，如图3-14所示。</p><p><img src="https://source.drie.cn/qxsf-images/164.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-14　合并过程</b></center><p>第3次比较A[i]=9和A[j]=6，将较小元素6放入B数组中，j++，k++，如图3-15所示。</p><p><img src="https://source.drie.cn/qxsf-images/165.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-15　合并过程</b></center><p>第4次比较A[i]=9和A[j]=18，将较小元素9放入B数组中，i++，k++，如图3-16所示。</p><p><img src="https://source.drie.cn/qxsf-images/166.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-16　合并过程</b></center><p>第5次比较A[i]=15和A[j]=18，将较小元素15放入B数组中，i++，k++，如图3-17所示。</p><p><img src="https://source.drie.cn/qxsf-images/167.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-17　合并过程</b></center><p>第6次比较A[i]=24和A[j]=18，将较小元素18放入B数组中，j++，k++，如图3-18所示。</p><p><img src="https://source.drie.cn/qxsf-images/168.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-18　合并过程</b></center><p>第7次比较A[i]=24和A[j]=20，将较小元素20放入B数组中，j++，k++，如图3-19所示。</p><p><img src="https://source.drie.cn/qxsf-images/169.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-19　合并过程</b></center><p>此时，j&gt;high了，while循环结束，但A数组还剩有元素（i≤mid）怎么办呢？直接放置到B数组就可以了，如图3-20所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(i &lt;= mid) B[k++] = A[i++];<span class="comment">//对子序列A[low:middle]剩余的依次处理</span></span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/170.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-20　合并过程</b></center><p>现在已经完成了合并排序的过程，还需要把辅助数组B中的元素复制到原来的A数组中，如图3-21所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = low, k = <span class="number">0</span>; i &lt;= high; i ++)<span class="comment">//将合并后的有序序列复制到原来的A[]序列</span></span><br><span class="line">   A[i] = B[k++];</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/171.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-21　合并结果复制到A[]</b></center><p>完整的合并程序如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="type">int</span> *B = new <span class="type">int</span>[high-low+<span class="number">1</span>];<span class="comment">//申请一个辅助数组  </span></span><br><span class="line">  <span class="type">int</span> i = low, j = mid+<span class="number">1</span>, k = <span class="number">0</span>;   </span><br><span class="line">  <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high) </span><br><span class="line">  &#123;<span class="comment">//按从小到大存放到辅助数组B[]中  </span></span><br><span class="line">    <span class="keyword">if</span>(A[i] &lt;= A[j]) </span><br><span class="line">         B[k++] = A[i++];  </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">         B[k++] = A[j++];  </span><br><span class="line">  &#125;  </span><br><span class="line"><span class="keyword">while</span>(i &lt;= mid) B[k++] = A[i++];       <span class="comment">//对子序列A[low:middle]剩余的依次处理</span></span><br><span class="line"><span class="keyword">while</span>(j &lt;= high) B[k++] = A[j++];      <span class="comment">//对子序列A[middle+1:high]剩余的依次处理</span></span><br><span class="line"><span class="keyword">for</span>(i = low, k = <span class="number">0</span>; i &lt;= high; i ++)   <span class="comment">//将合并后的序列复制到原来的A[]序列</span></span><br><span class="line">   A[i] = B[k++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）递归形式的合并排序算法</p><p>将序列分为两个子序列，然后对子序列进行递归排序，再把两个已排好序的子序列合并成一个有序的序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(low &lt; high) </span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="type">int</span> mid = (low+high)/<span class="number">2</span>; </span><br><span class="line">     MergeSort(A, low, mid);           <span class="comment">//对A[low:mid]中的元素合并排序  </span></span><br><span class="line">     MergeSort(A, mid+<span class="number">1</span>, high);        <span class="comment">//对A[mid+1:high]中的元素合并排序  </span></span><br><span class="line">     Merge(A, low, mid, high);         <span class="comment">//合并操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-5-实战演练">3.3.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 3-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> mid, <span class="type">int</span> high)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> *B = new <span class="type">int</span>[high-low+<span class="number">1</span>];     <span class="comment">//申请一个辅助数组</span></span><br><span class="line">     <span class="type">int</span> i = low, j = mid+<span class="number">1</span>, k = <span class="number">0</span>; </span><br><span class="line">     <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= high) </span><br><span class="line">&#123;<span class="comment">//按从小到大存放到辅助数组B[]中</span></span><br><span class="line">         <span class="keyword">if</span>(A[i] &lt;= A[j]) </span><br><span class="line">               B[k++] = A[i++];</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">               B[k++] = A[j++];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">while</span>(i &lt;= mid) B[k++] = A[i++];  <span class="comment">//将数组中剩下的元素复制到数组B中</span></span><br><span class="line">     <span class="keyword">while</span>(j &lt;= high) B[k++] = A[j++];</span><br><span class="line">     <span class="keyword">for</span>(i = low, k = <span class="number">0</span>; i &lt;= high; i ++)</span><br><span class="line">           A[i] = B[k++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">MergeSort</span><span class="params">(<span class="type">int</span> A[], <span class="type">int</span> low, <span class="type">int</span> high)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(low &lt; high) </span><br><span class="line">&#123;</span><br><span class="line">           <span class="type">int</span> mid = (low+high) /<span class="number">2</span>;   <span class="comment">//取中点</span></span><br><span class="line">           MergeSort(A, low, mid);    <span class="comment">//对A[low:mid]中的元素合并排序</span></span><br><span class="line">           MergeSort(A, mid+<span class="number">1</span>, high); <span class="comment">//对A[mid+1:high]中的元素合并排序</span></span><br><span class="line">           Merge(A, low, mid, high);  <span class="comment">//合并</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n, A[<span class="number">100</span>]; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入数列中的元素个数n为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;n; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请依次输入数列中的元素：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;A[i]; </span><br><span class="line">     MergeSort(A,<span class="number">0</span>,n<span class="number">-1</span>); </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;合并排序结果：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;A[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入数列中的元素个数n为：</span><br><span class="line"><span class="number">8</span></span><br><span class="line">请依次输入数列中的元素：</span><br><span class="line"><span class="number">42</span> <span class="number">15</span> <span class="number">20</span> <span class="number">6</span> <span class="number">8</span> <span class="number">38</span> <span class="number">50</span> <span class="number">12</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">合并排序结果：</span><br><span class="line"><span class="number">6</span> <span class="number">8</span> <span class="number">12</span> <span class="number">15</span> <span class="number">20</span> <span class="number">38</span> <span class="number">42</span> <span class="number">50</span></span><br></pre></td></tr></table></figure><h3 id="3-3-6-算法解析与拓展">3.3.6　算法解析与拓展</h3><h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4><p>（1）时间复杂度</p><ul><li>分解：这一步仅仅是计算出子序列的中间位置，需要常数时间O(1)。</li><li>解决子问题：递归求解两个规模为n/2的子问题，所需时间为2T(n/2)。</li><li>合并：Merge算法可以在O(n)的时间内完成。</li></ul><p>所以总运行时间为：</p><p><img src="https://source.drie.cn/qxsf-images/172.gif" alt="code"><br>当n&gt;1时，可以递推求解：</p><p><img src="https://source.drie.cn/qxsf-images/173.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么</p><p><img src="https://source.drie.cn/qxsf-images/175.gif" alt="code"><br>合并排序算法的时间复杂度为O(nlogn)。</p><p>（2）空间复杂度：程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，每调用一个Merge()，会分配一个适当大小的缓冲区，且退出时释放。最多分配大小为n，所以空间复杂度为O(n)。递归调用所使用的栈空间是O(logn)，想一想为什么？</p><p>合并排序递归树如图3-22所示。</p><p><img src="https://source.drie.cn/qxsf-images/176.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-22　合并排序递归树</b></center><p>递归调用时占用的栈空间是递归树的深度，<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，递归树的深度为logn。</p><h4 id="2．优化拓展-2">2．优化拓展</h4><p>上面算法我们使用递归来实现，当然也可以使用非递归的方法，大家可以动手试试。</p><p>那么，还有没有更好的算法来解决这个问题呢？</p><h3 id="3-4-兵贵神速——快速排序">3.4　兵贵神速——快速排序</h3><p>未来的战争是科技的战争。假如A国受到B国的导弹威胁，那么A国就要启用导弹防御系统，根据卫星、雷达信息快速计算出敌方弹道导弹发射点和落点的信息，将导弹的跟踪和评估数据转告地基雷达，发射拦截导弹摧毁敌方导弹或使导弹失去攻击能力。如果A国的导弹防御系统处理速度缓慢，等算出结果时，导弹已经落地了，还谈何拦截？</p><p>现代科技的发展，速度至关重要。</p><p>我们以最基本的排序为例，生活中到处都用到排序，例如各种比赛、奖学金评选、推荐系统等，排序算法有很多种，能不能找到更快速高效的排序算法呢？</p><p><img src="https://source.drie.cn/qxsf-images/177.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-23　某国导弹防御系统示意图</b></center><h3 id="3-4-1-问题分析">3.4.1　问题分析</h3><p>曾经有人做过实验，对各种排序算法效率做了对比（单位：毫秒），如表3-1所示。</p><center class="my_markdown"><b class="my_markdown">表3-1　排序算法效率</b></center><p><img src="https://source.drie.cn/qxsf-images/178.jpg" alt="code"><br>从上面的表中我们可以看出，如果对10<sup class="my_markdown">5</sup>个数据进行排序，冒泡排序需要8 174毫秒，而快速排序只需要3.634毫秒！</p><p>快速排序（Quicksort）是比较快速的排序方法。快速排序由C. A. R. Hoare在1962年提出。它的基本思想是通过一组排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此使所有数据变成有序序列。</p><p>我们前面刚讲过合并排序（又叫归并排序），它每次从中间位置把问题一分为二，一直划分到不能再分时，执行合并操作。合并排序的划分很简单，但合并操作就复杂了，需要额外的辅助空间（辅助数组），在辅助数组中完成合并排序后复制到原来的位置，它是一种异地排序的方法。合并排序分解容易，合并难，属于“先易后难”。而快速排序是原地排序，不需要辅助数组，但分解困难，合并容易，是“先苦后甜”型。</p><h3 id="3-4-2-算法设计">3.4.2　算法设计</h3><p>快速排序的基本思想是基于分治策略的，其算法思想如下。</p><p>（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。</p><p>（2）治理：对两个子序列进行快速排序。</p><p>（3）合并：将排好序的两个子序列合并在一起，得到原问题的解。</p><p>设当前待排序的序列为R[low:high]，其中low≤high，如果序列的规模足够小，则直接进行排序，否则分3步处理。</p><p>（1）分解：在R[low: high]中选定一个元素R[pivot]，以此为标准将要排序的序列划分为两个序列R[low:pivot−1]和R[pivot+1:high]，并使用序列R[low:pivot−1]中所有元素的值小于等于R[pivot]，序列R[pivot+1:high]中所有元素均大于R[pivot]，此时基准元素已经位于正确的位置，它无需参加后面的排序，如图3-24所示。</p><p><img src="https://source.drie.cn/qxsf-images/179.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-24　快速排序分解</b></center><p>（2）治理：对于两个子序列R[low:pivot−1]和R[pivot+1:high]，分别通过递归调用快速排序算法来进行排序。</p><p>（3）合并：由于对R[low:pivot−1]和R[pivot+1:high]的排序是原地进行的，所以在R[low:pivot−1]和R[pivot+1:high]都已经排好序后，合并步骤无需做什么，序列R[low:high]就已经排好序了。</p><p>如何分解是一个难题，因为如果基准元素选取不当，有可能分解成规模为0和n−1的两个子序列，这样快速排序就退化为冒泡排序了。</p><p>例如序列（30，24，5，58，18，36，12，42，39），第一次选取5做基准元素，分解后，如图3-25所示。</p><p><img src="https://source.drie.cn/qxsf-images/180.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-25　选5做基准元素排序结果</b></center><p>第二次选取12做基准元素，分解后如图3-26所示。</p><p><img src="https://source.drie.cn/qxsf-images/181.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-26　继续选12做基准元素排序结果</b></center><p>是不是有点像冒泡了？这样做的效率是最差的，最理想的状态是把序列分解为两个规模相当的子序列，那么怎么选择基准元素呢？一般来说，基准元素选取有以下几种方法：</p><ul><li>取第一个元素。</li><li>取最后一个元素。</li><li>取中间位置元素。</li><li>取第一个、最后一个、中间位置元素三者之中位数。</li><li>取第一个和最后一个之间位置的随机数k（low≤k≤high），选R[k]做基准元素。</li></ul><h3 id="3-4-3-完美图解">3.4.3　完美图解</h3><p>并没有明确的方法说哪一种基准元素选取方案最好，在此以选取第一个元素做基准为例，说明快速排序的执行过程。</p><p>假设当前待排序的序列为R[low:high]，其中low≤high。</p><p>步骤1：首先取数组的第一个元素作为基准元素pivot=R[low]。i=low，j=high。</p><p>步骤2：从右向左扫描，找小于等于pivot的数，如果找到，R[i]和R[j]交换，i++。</p><p>步骤3：从左向右扫描，找大于pivot的数，如果找到，R[i]和R[j]交换，j−−。</p><p>步骤4：重复步骤2～步骤3，直到i和j指针重合，返回该位置mid=i，该位置的数正好是pivot元素。</p><p>至此完成一趟排序。此时以mid为界，将原数据分为两个子序列，左侧子序列元素都比pivot小，右侧子序列元素都比pivot大，然后再分别对这两个子序列进行快速排序。</p><p>以序列（30，24，5，58，18，36，12，42，39）为例，演示排序过程。</p><p>（1）初始化。i=low，j=high，pivot=R[low]=30，如图3-27所示。</p><p><img src="https://source.drie.cn/qxsf-images/182.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-27　快速排序初始化</b></center><p>（2）向左走。从数组的右边位置向左找，一直找小于等于pivot的数，找到R[j]=12，如图3-28所示。</p><p><img src="https://source.drie.cn/qxsf-images/183.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-28　快速排序过程（交换元素）</b></center><p>R[i]和R[j]交换，i++，如图3-29所示。</p><p><img src="https://source.drie.cn/qxsf-images/184.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-29　快速排序过程（交换元素后）</b></center><p>（3）向右走。从数组的左边位置向右找，一直找比pivot大的数，找到R[i]=58，如图3-30所示。</p><p><img src="https://source.drie.cn/qxsf-images/185.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-30　快速排序过程（交换元素）</b></center><p>R[i]和R[j]交换，j−−，如图3-31所示。</p><p><img src="https://source.drie.cn/qxsf-images/186.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-31　快速排序过程（交换元素后）</b></center><p>（4）向左走。从数组的右边位置向左找，一直找小于等于pivot的数，找到R[j]=18，如图3-32所示。</p><p><img src="https://source.drie.cn/qxsf-images/187.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-32　快速排序过程（交换元素）</b></center><p>R[i]和R[j]交换，i++，如图3-33所示。</p><p><img src="https://source.drie.cn/qxsf-images/188.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-33　快速排序过程（交换元素后）</b></center><p>（5）向右走。从数组的左边位置向右找，一直找比pivot大的数，这时i=j，第一轮排序结束，返回i的位置，mid=i，如图3-34所示。</p><p><img src="https://source.drie.cn/qxsf-images/189.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-34　第一趟快速排序（划分）结果</b></center><p>至此完成一轮排序。此时以mid为界，将原数据分为两个子序列，左侧子序列都比pivot小，右侧子序列都比pivot大。</p><p>然后再分别对这两个子序列（12，24，5，18）和（36，58，42，39）进行快速排序。</p><p>大家可以动手写一写哦！</p><h3 id="3-4-4-伪代码详解">3.4.4　伪代码详解</h3><p>（1）划分函数</p><p>我们编写划分函数对原序列进行分解，分解为两个子序列，以基准元素pivot为界，左侧子序列都比pivot小，右侧子序列都比pivot大。先从右向左扫描，找小于等于pivot的数，找到后两者交换（r[i]和r[j]交换后i++）；再从左向右扫描，找比基准元素大的数，找到后两者交换（r[i]和r[j]交换后j−−）。扫描交替进行，直到i=j停止，返回划分的中间位置i。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high)</span>   <span class="comment">//划分函数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i=low,j=high,pivot=r[low];       <span class="comment">//基准元素</span></span><br><span class="line">     <span class="keyword">while</span>(i&lt;j) </span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;j&amp;&amp;r[j]&gt;pivot) </span><br><span class="line">             j--;                         <span class="comment">//向左扫描</span></span><br><span class="line">         <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">         &#123;</span><br><span class="line">             swap(r[i++],r[j]);           <span class="comment">//r[i]和r[j]交换后i右移一位</span></span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">while</span>(i&lt;j&amp;&amp;r[i]&lt;=pivot) </span><br><span class="line">             i++;                         <span class="comment">//向右扫描</span></span><br><span class="line">         <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">         &#123;</span><br><span class="line">              swap(r[i],r[j--]);          <span class="comment">//r[i]和r[j]交换后j左移一位</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i;                            <span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）快速排序递归算法</p><p>首先对原序列执行划分，得到划分的中间位置mid，然后以中间位置为界，分别对左半部分（low，mid−1）执行快速排序，右半部分（mid+1，high）执行快速排序。递归结束的条件是low≥high。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> R[],<span class="type">int</span> low,<span class="type">int</span> high)</span>&#123; </span><br><span class="line">     <span class="type">int</span> mid; </span><br><span class="line">     <span class="keyword">if</span>(low&lt;high) </span><br><span class="line">     &#123;</span><br><span class="line">          mid=Partition(R,low,high);      <span class="comment">//返回基准元素位置</span></span><br><span class="line">          QuickSort(R,low,mid<span class="number">-1</span>);         <span class="comment">//左区间递归快速排序</span></span><br><span class="line">          QuickSort(R,mid+<span class="number">1</span>,high);        <span class="comment">//右区间递归快速排序</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-5-实战演练">3.4.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 3-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>; </span><br><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high)</span> <span class="comment">//划分函数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i=low,j=high,pivot=r[low];     <span class="comment">//基准元素</span></span><br><span class="line">     <span class="keyword">while</span>(i&lt;j) </span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;r[j]&gt;pivot) j--;   <span class="comment">//向左扫描</span></span><br><span class="line">          <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">          &#123;</span><br><span class="line">               swap(r[i++],r[j]);       <span class="comment">//r[i]和r[j]交换后i右移一位</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">while</span>(i&lt;j&amp;&amp;r[i]&lt;=pivot) i++;  <span class="comment">//向右扫描</span></span><br><span class="line">          <span class="keyword">if</span>(i&lt;j) </span><br><span class="line">          &#123;</span><br><span class="line">               swap(r[i],r[j--]);       <span class="comment">//r[i]和r[j]交换后j左移一位</span></span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> i;                          <span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">QuickSort</span><span class="params">(<span class="type">int</span> R[],<span class="type">int</span> low,<span class="type">int</span> high)</span><span class="comment">//快速排序递归算法</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> mid; </span><br><span class="line">     <span class="keyword">if</span>(low&lt;high) </span><br><span class="line">     &#123;</span><br><span class="line">          mid=Partition(R,low,high);    <span class="comment">//基准位置</span></span><br><span class="line">          QuickSort(R,low,mid<span class="number">-1</span>);       <span class="comment">//左区间递归快速排序</span></span><br><span class="line">          QuickSort(R,mid+<span class="number">1</span>,high);      <span class="comment">//右区间递归快速排序</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> a[<span class="number">1000</span>]; </span><br><span class="line">     <span class="type">int</span> i,N; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请先输入要排序的数据的个数：&quot;</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;N; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入要排序的数据：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;a[i]; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     QuickSort(a,<span class="number">0</span>,N<span class="number">-1</span>); </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;排序后的序列为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;N;i++)</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;a[i]&lt;&lt;<span class="string">&quot; &quot;</span> ; </span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请先输入要排序的数据的个数：<span class="number">9</span></span><br><span class="line">请输入要排序的数据：<span class="number">30</span> <span class="number">24</span> <span class="number">5</span> <span class="number">58</span> <span class="number">18</span> <span class="number">36</span> <span class="number">12</span> <span class="number">42</span> <span class="number">39</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">排序后的序列为：</span><br><span class="line"><span class="number">5</span> <span class="number">12</span> <span class="number">18</span> <span class="number">24</span> <span class="number">30</span> <span class="number">36</span> <span class="number">39</span> <span class="number">42</span> <span class="number">58</span></span><br></pre></td></tr></table></figure><h3 id="3-4-6-算法解析与拓展">3.4.6　算法解析与拓展</h3><h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4><p>（1）最好时间复杂度</p><ul><li>分解：划分函数Partition需要扫描每个元素，每次扫描的元素个数不超过n，因此时间复杂度为O(n)。</li><li>解决子问题：在最理想的情况下，每次划分将问题分解为两个规模为n/2的子问题，递归求解两个规模为n/2的子问题，所需时间为2T(n/2)，如图3-35所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/190.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-35　快速排序最好的划分</b></center><ul><li>合并：因为是原地排序，合并操作不需要时间复杂度，如图3-36所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/191.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-36　快速排序最好情况递归树</b></center><p>所以总运行时间为：</p><p><img src="https://source.drie.cn/qxsf-images/172.gif" alt="code"><br>当n&gt;1时，可以递推求解：</p><p><img src="https://source.drie.cn/qxsf-images/173.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么</p><p><img src="https://source.drie.cn/qxsf-images/175.gif" alt="code"><br>快速排序算法最好的时间复杂度为O(nlogn)。</p><ul><li>空间复杂度：程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，递归调用所使用的栈空间是O(logn)，想一想为什么？</li></ul><p>（2）最坏时间复杂度</p><ul><li>分解：划分函数Partition需要扫描每个元素，每次扫描的元素个数不超过n，因此时间复杂度为O(n)。</li><li>解决子问题：在最坏的情况下，每次划分将问题分解后，基准元素的左侧（或者右侧）没有元素，基准元素的另一侧为1个规模为n−1的子问题，递归求解这个规模为n−1的子问题，所需时间为T(n−1)。如图3-37所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/192.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-37　快速排序最坏的划分</b></center><ul><li>合并：因为是原地排序，合并操作不需要时间复杂度。如图3-38所示。</li></ul><p><img src="https://source.drie.cn/qxsf-images/193.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-38　快速排序最坏情况递归树</b></center><p>所以总运行时间为：</p><p><img src="https://source.drie.cn/qxsf-images/194.gif" alt="code"><br>当n&gt;1时，可以递推求解如下：</p><p><img src="https://source.drie.cn/qxsf-images/195.gif" alt="code"><br>快速排序算法最坏的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><ul><li>空间复杂度：程序中变量占用了一些辅助空间，这些辅助空间都是常数阶的，递归调用所使用的栈空间是O(n)，想一想为什么？</li></ul><p>（3）平均时间复杂度</p><p>假设我们划分后基准元素的位置在第 k（k=1，2，…，n）个，如图3-39所示。</p><p><img src="https://source.drie.cn/qxsf-images/196.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-39　快速排序平均情况的划分</b></center><p>则：</p><p><img src="https://source.drie.cn/qxsf-images/197.gif" alt="code"><br>由归纳法可以得出，T(n)的数量级也为O(nlogn)。快速排序算法平均情况下，时间复杂度为O(nlogn)，递归调用所使用的栈空间也是O(logn)。</p><h4 id="2．优化拓展-3">2．优化拓展</h4><p>从上述算法可以看出，每次交换都是在和基准元素进行交换，实际上没必要这样做，我们的目的就是想把原序列分成以基准元素为界的两个子序列，左侧子序列小于等于基准元素，右侧子序列大于基准元素。那么有很多方法可以实现，我们可以从右向左扫描，找小于等于pivot的数R[j]，然后从左向右扫描，找大于pivot的数R[i]，让R[i]和R[j]交换，一直交替进行，直到i和j碰头为止，这时将基准元素与R[i]交换即可。这样就完成了一次划分过程，但交换元素的个数少了很多。</p><p>假设当前待排序的序列为R[low: high]，其中low≤high。</p><p>步骤1：首先取数组的第一个元素作为基准元素pivot=R[low]。i=low，j=high。</p><p>步骤2：从右向左扫描，找小于等于pivot的数R[i]。</p><p>步骤3：从左向右扫描，找大于pivot的数R[j]。</p><p>步骤4：R[i]和R[j]交换，i++，j−−。</p><p>步骤5：重复步骤2～步骤4，直到i和j相等，如果R[i]大于pivot，则R[i−1]和基准元素R[low]交换，返回该位置mid=i−1；否则，R[i]和基准元素R[low]交换，返回该位置mid=i，该位置的数正好是基准元素。</p><p>至此完成一趟排序。此时以mid为界，将原数据分为两个子序列，左侧子序列元素都比pivot小，右侧子序列元素都比pivot大。</p><p>然后再分别对这两个子序列进行快速排序。</p><p>以序列（30，24，5，58，18，36，12，42，39）为例。</p><p>（1）初始化。i= low，j= high，pivot= R[low]=30，如图3-40所示。</p><p><img src="https://source.drie.cn/qxsf-images/198.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-40　快速排序初始化</b></center><p>（2）向左走。从数组的右边位置向左找，一直找小于等于pivot的数，找到R[j]=12，如图3-41所示。</p><p><img src="https://source.drie.cn/qxsf-images/199.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-41　快速排序过程（向左走）</b></center><p>（3）向右走。从数组的左边位置向右找，一直找比pivot大的数，找到R[i]=58，如图3-42所示。</p><p><img src="https://source.drie.cn/qxsf-images/200.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-42　快速排序过程（向右走）</b></center><p>（4）R[i]和R[j]交换，i++，j−−，如图3-43所示。</p><p><img src="https://source.drie.cn/qxsf-images/201.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-43　快速排序过程（交换元素）</b></center><p>（5）向左走。从数组的右边位置向左找，一直找小于等于pivot的数，找到R[j]=18，如图3-44所示。</p><p><img src="https://source.drie.cn/qxsf-images/202.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-44　快速排序过程（向左走）</b></center><p>（6）向右走。从数组的左边位置向右找，一直找比pivot大的数，这时i=j，停止，如图3-45所示。</p><p><img src="https://source.drie.cn/qxsf-images/203.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-45　快速排序过程（向右走）</b></center><p>（7）R[i]和R[low]交换，返回i的位置，mid=i，第一轮排序结束，如图3-46所示。</p><p><img src="https://source.drie.cn/qxsf-images/204.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-46　快速排序过程（R[i]和R[low]交换）</b></center><p>至此完成一轮排序。此时以mid为界，将原数据分为两个子序列，左侧子序列都比pivot小，右侧子序列都比pivot大，如图3-47所示。</p><p><img src="https://source.drie.cn/qxsf-images/205.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-47　快速排序第一次划分结果</b></center><p>然后再分别对这两个子序列（18，24，5，12）和（36，58，42，39）进行快速排序。</p><p>相比之下，上述的方法比每次和基准元素交换的方法更加快速高效！</p><p>优化后算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition2</span><span class="params">(<span class="type">int</span> r[],<span class="type">int</span> low,<span class="type">int</span> high)</span><span class="comment">//划分函数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i=low,j=high,pivot=r[low];<span class="comment">//基准元素</span></span><br><span class="line">     <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">     &#123;</span><br><span class="line">           <span class="keyword">while</span>(i&lt;j&amp;&amp;r[j]&gt;pivot) j--;<span class="comment">//向左扫描</span></span><br><span class="line">           <span class="keyword">while</span>(i&lt;j&amp;&amp;r[i]&lt;=pivot) i++;<span class="comment">//向右扫描</span></span><br><span class="line">           <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">           &#123;</span><br><span class="line">                 swap(r[i++],r[j--]);<span class="comment">//r[i]和r[j]交换，交换后i++, j--</span></span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(r[i]&gt;pivot)</span><br><span class="line">     &#123;</span><br><span class="line">           swap(r[i<span class="number">-1</span>],r[low]);<span class="comment">//r[i-1]和r[low]交换</span></span><br><span class="line">           <span class="keyword">return</span> i<span class="number">-1</span>;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">swap(r[i],r[low]);<span class="comment">//r[i]和r[low]交换</span></span><br><span class="line">    <span class="keyword">return</span> i;<span class="comment">//返回最终划分完成后基准元素所在的位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家可以思考是否还有更好的算法来解决这个问题呢？</p><h3 id="3-5-效率至上——大整数乘法">3.5　效率至上——大整数乘法</h3><p>在进行算法分析时，我们往往将加法和乘法运算当作一次基本运算处理，这个假定是建立在进行运算的整数能在计算机硬件对整数的表示范围内直接被处理的情况下，如果要处理很大的整数，则计算机硬件无法直接表示处理。那么我们能否将一个大的整数乘法分而治之？将大问题变成小问题，变成简单的小数乘法，这样既解决了计算机硬件处理的问题，又能够提高乘法的计算效率呢？</p><p><img src="https://source.drie.cn/qxsf-images/206.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-48　大整数乘法</b></center><h3 id="3-5-1-问题分析">3.5.1　问题分析</h3><p>有时，我们想要在计算机上处理一些大数据相乘时，由于计算机硬件的限制，不能直接进行相乘得到想要的结果。在解决两个大的整数相乘时，我们可以将一个大的整数乘法分而治之，将大问题变成小问题，变成简单的小数乘法再进行合并，从而解决上述问题。这样既解决了计算机硬件处理的问题，又能够提高乘法的计算效率。</p><p>例如：</p><p><img src="https://source.drie.cn/qxsf-images/207.gif" alt="code"><br>继续分治：</p><p><img src="https://source.drie.cn/qxsf-images/208.gif" alt="code"><br>我们可以看到当分解到只有一位数时，乘法就很简单了，如图3-49所示。</p><p><img src="https://source.drie.cn/qxsf-images/209.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-49　大整数乘法分治图</b></center><h3 id="3-5-2-算法设计">3.5.2　算法设计</h3><p>算法思想：解决本问题可以使用分治策略。</p><p>（1）分解</p><p>首先将2个大整数a（n位）、b（m位）分解为两部分，如图3-50所示。</p><p><img src="https://source.drie.cn/qxsf-images/210.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-50　大整数a、b分解为高位和低位</b></center><p>ah表示大整数a的高位，al表示大整数a的低位。bh表示大整数b的高位，bl表示大整数b的低位。</p><p><img src="https://source.drie.cn/qxsf-images/211.gif" alt="code"><br>ah、al为n/2位，bh、bl为m/2位。</p><p>2个大整数a（n位）、b（m位）相乘转换成了4个乘法运算ah<em>bh、ah</em>bl、al<em>bh、al</em>bl，而 <strong>乘数的位数变为了原来的一半</strong> 。</p><p>（2）求解子问题</p><p>继续分解每个乘法运算，直到分解有一个乘数为1位数时停止分解，进行乘法运算并记录结果。</p><p>（3）合并</p><p>将计算出的结果相加并回溯，求出最终结果。</p><h3 id="3-5-3-完美图解">3.5.3　完美图解</h3><p>分治进行大整数乘法的道理非常简单，但具体怎么处理呢？</p><p>首先将两个大数以字符串的形式输入，转换成数字后， <strong>倒序存储</strong> 在数组s[]中，l用来表示数的长度，c表示次幂。两个大数的初始次幂为0。</p><p><strong>想一想，为什么要倒序存储，正序存储会怎样？</strong></p><ul><li>cp()函数：用于将一个n位的数分成两个n/2的数并存储，记录它的长度和次幂。</li><li>mul()函数：用于将两个数进行相乘，不断地进行分解，直到有一个乘数为1位数时停止分解，进行乘法运算并记录结果。</li><li>add()函数：将分解得到的数进行相加合并。</li></ul><p>例如：a=3278，b=41926，求a*b的值。</p><p>（1）初始化</p><p>将a、b <strong>倒序存储</strong> 在数组a.s[]，b.s[]中，如图3-51所示。</p><p><img src="https://source.drie.cn/qxsf-images/212.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-51　大整数a、b存储数组（倒序）</b></center><p>（2）分解</p><p>cp()函数用于将一个n位的数分成两个n/2的数并存储，记录它的长度和次幂。ah表示高位，al表示低位，l用来表示数的长度，c表示次幂，如图3-52所示。</p><p><img src="https://source.drie.cn/qxsf-images/213.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-52　大整数a、b分解为高位和低位</b></center><p>转换为4次乘法运算：<img class="my_markdown" src="https://source.drie.cn/qxsf-images/214.gif" style="width:55px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/215.gif" style="width:50px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/216.gif" style="width:51px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/217.gif" style="width:46px;  height: 13px; "/>。如图3-53所示。</p><p><img src="https://source.drie.cn/qxsf-images/218.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-53　原乘法分解为4次乘法</b></center><p>（3）求解子问题</p><p><img class="my_markdown" src="https://source.drie.cn/qxsf-images/214.gif" style="width:55px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/215.gif" style="width:50px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/216.gif" style="width:51px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/217.gif" style="width:46px;  height: 13px; "/>。下面以<img class="my_markdown" src="https://source.drie.cn/qxsf-images/214.gif" style="width:55px;  height: 13px; "/>为例说明。如图3-54所示。</p><p><img src="https://source.drie.cn/qxsf-images/219.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-54　ah*bh相乘分解</b></center><p>（4）继续求解子问题</p><p>继续求解上面4个乘法运算<img class="my_markdown" src="https://source.drie.cn/qxsf-images/220.gif" style="width:75px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/221.gif" style="width:70px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/222.gif" style="width:71px;  height: 13px; "/>，<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/223.gif" style="width:66px;  height: 13px; "/>。可以看出这4个乘法运算都有一个乘数为1位数，可以直接进行乘法运算。</p><p>怎么进行乘法运算呢？以图3-53中<img class="my_markdown" src="https://source.drie.cn/qxsf-images/220.gif" style="width:75px;  height: 13px; "/>为例，如图3-55所示。</p><p><img src="https://source.drie.cn/qxsf-images/224.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-55　乘法运算</b></center><p>3首先和1相乘得到3存储在下面数组的第0位，然后3和4相乘得到12，那怎么存储呢，先存储12%10=2，然后存储进位12/10=1，这样乘法运算的结果是321， <strong>注意是倒序</strong> ，实际含义是3×41=123，还有一件事很重要，就是次幂！两数相乘时，结果的次幂是两个乘数次幂之和，3×10<sup class="my_markdown">3</sup>×41×10<sup class="my_markdown">3</sup>=123×10<sup>6</sup>。</p><p>4个乘法运算结果如图3-56所示。</p><p><img src="https://source.drie.cn/qxsf-images/225.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-56　4个乘法运算</b></center><p>（5）合并</p><p><strong>合并子问题结果，返回给</strong> <img class="my_markdown" src="https://source.drie.cn/qxsf-images/214.gif" style="width:55px;  height: 13px; "/>，将上面4个乘法运算的结果加起来返回给<img class="my_markdown" src="https://source.drie.cn/qxsf-images/214.gif" style="width:55px;  height: 13px; "/>。如图3-57所示。</p><p><img src="https://source.drie.cn/qxsf-images/226.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/227.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-57　4个乘法运算结果相加</b></center><p>由此得到ah*bh=13408×10<sup class="my_markdown">4</sup>。</p><p>用同样的方法求得ah<em>bl=832×10<sup class="my_markdown">2</sup>，al</em>bh=32682×10<sup class="my_markdown">2</sup>，al<em>bl=2028。将这4个子问题结果加起来，合并得到原问题a</em>b=137433428。</p><h3 id="3-5-4-伪代码详解">3.5.4　伪代码详解</h3><p>（1）数据结构</p><p>将两个大数以字符串的形式输入，然后定义结构体Node，其中s[]数组用于存储大数， <strong>注意是倒序存储！</strong> （因为乘法加法运算中有可能产生进位，倒序存储时可以让进位存储在数组的末尾），l用于表示长度，c表示次幂。两个大数的初始次幂为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> sa[<span class="number">1000</span>]; <span class="comment">//接收大数的字符串</span></span><br><span class="line"><span class="type">char</span> sb[<span class="number">1000</span>]; <span class="comment">//接收大数的字符串</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> s[M];  <span class="comment">//数组，倒序存储大数</span></span><br><span class="line">     <span class="type">int</span> l;     <span class="comment">//代表数的长度</span></span><br><span class="line">     <span class="type">int</span> c;     <span class="comment">//代表数的次幂，例如32*105，那么将23存储在s[]中，l=2，c=5</span></span><br><span class="line">&#125; Node,*pNode; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（2）划分函数</p><p>其中，cp()函数用于将一个n位的数分成两个n/2的数并存储，记录它的次幂。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">cp</span><span class="params">(pNode src, pNode des, <span class="type">int</span> st, <span class="type">int</span> l)</span> </span><br><span class="line">&#123;    <span class="comment">//src表示待分解的数结点，des表示分解后得到的数结点</span></span><br><span class="line">     <span class="comment">//st表示从src结点数组中取数的开始位置，l表示取数的长度</span></span><br><span class="line">     <span class="type">int</span> i, j; </span><br><span class="line">     <span class="keyword">for</span>(i=st, j=<span class="number">0</span>; i&lt;st+l; i++, j++) <span class="comment">//从src结点数组中st位置开始，取l个数</span></span><br><span class="line">     &#123;</span><br><span class="line">          des-&gt;s[j] = src-&gt;s[i];      <span class="comment">//将这些数放入到des结点的数组中</span></span><br><span class="line">     &#125;</span><br><span class="line">     des-&gt;l = l;                      <span class="comment">//des长度等于取数的长度</span></span><br><span class="line">     des-&gt;c = st + src-&gt;c;            <span class="comment">//des次幂等于开始取数的位置加上src次幂</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例说明：如果有大数43579，我们首先把该数存储在结点a中，如图3-58所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ma = a.l/<span class="number">2</span>;                           <span class="comment">//ma表示a长度的一半，此例中a.l=5，ma=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/228.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-58　大整数a存储数组（倒序）</b></center><p>分解得到a的高位ah，如图3-59所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp(&amp;a, &amp;ah, ma, a.l-ma);              <span class="comment">//相当于cp(a, &amp;ah, 2, 3)；</span></span><br><span class="line">          <span class="comment">//即从a中数组第2个字符位置开始取3个字符，赋值给ah; </span></span><br><span class="line">          <span class="comment">//ah的长度等于3；ah的次幂等于开始位置2加上a的次幂，即2+a.c=2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/229.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-59　大整数a的高位（倒序真实含义是435×10<sup class="my_markdown">2</sup>）</b></center><p>然后分解得到a的低位al，如图3-60所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp(&amp;a, &amp;al, <span class="number">0</span>, ma);                   <span class="comment">//相当于cp(a, &amp;al, 0, 2)；</span></span><br><span class="line">          <span class="comment">//即从a中数组第0个字符位置开始取2个字符，赋值给al; </span></span><br><span class="line">          <span class="comment">//al的长度等于2；al的次幂等于开始位置0加上a的次幂，即0+a.c=0</span></span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/230.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-60　大整数a的低位（倒序真实含义是79）</b></center><p>这样两次调用cp()函数，我们就把一个大的整数分解成了两个长度约为原来一半的整数。</p><p>（3）乘法运算</p><p>定义的mul()函数用于将两个数进行相乘，不断地进行分解， <strong>直到有一个乘数为1位时停止</strong> ，让这两个数相乘，并记录结果回溯。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ma = pa-&gt;l/<span class="number">2</span>; <span class="comment">//ma表示a长度的一半</span></span><br><span class="line">mb = pb-&gt;l/<span class="number">2</span>; <span class="comment">//mb表示b长度的一半</span></span><br><span class="line"><span class="keyword">if</span>(!ma || !mb) <span class="comment">//如果!ma说明ma=0，即a的长度为1，该乘数为1位数</span></span><br><span class="line">               <span class="comment">//如果!mb说明mb=0，即b的长度为1，该乘数为1位数</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(!ma)   <span class="comment">//!ma说明a为1位数，a、b交换，保证a的长度大于等于b的长度</span></span><br><span class="line">     &#123;</span><br><span class="line">          temp =pa; </span><br><span class="line">          pa = pb; </span><br><span class="line">          pb = temp; </span><br><span class="line">     &#125;         <span class="comment">//交换后b的长度为1</span></span><br><span class="line">     ans-&gt;c = pa-&gt;c + pb-&gt;c;          <span class="comment">//结果的次幂等于两乘数次幂之和</span></span><br><span class="line">     w = pb-&gt;s[<span class="number">0</span>];<span class="comment">//因为交换后b的长度为1，用变量 w记录即可</span></span><br><span class="line">     cc= <span class="number">0</span>;    <span class="comment">//初始化进位cc为0</span></span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt;pa-&gt;l; i++)          <span class="comment">//把a中的数依次取出与w相乘，记录结果和进位</span></span><br><span class="line">     &#123;</span><br><span class="line">         ans-&gt;s[i] = (w*pa-&gt;s[i] + cc)%<span class="number">10</span>;<span class="comment">//存储相乘结果的个位，十位做进位处理</span></span><br><span class="line">         cc = (w*pa-&gt;s[i] + cc)/<span class="number">10</span>;   <span class="comment">//处理进位</span></span><br><span class="line">     &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>举例说明：两个数a=9×10<sup class="my_markdown">2</sup>，b=87×10<sup>3</sup>相乘。a的数字为1位，a、b交换，保证a的长度大于等于b的长度，交换后a=87×10<sup>3</sup>，b=9×10<sup class="my_markdown">2</sup>，倒序存储如图3-61所示。</p><p><img src="https://source.drie.cn/qxsf-images/231.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-61　大整数a、b存储数组（倒序）</b></center><p>初始化进位cc=0。</p><p>先计算9×7=63，（63+cc）%10=3，ans−&gt;s[0]=3，进位cc=（63+cc）/10=6。</p><p>再计算9×8=72，（72+cc）%10=8，ans−&gt;s[1]=8，进位cc=（72+cc）/10=7。</p><p>a中的数处理完毕，退出for循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cc)                 <span class="comment">//上例中退出时cc=7</span></span><br><span class="line">    ans-&gt;s[i++] = cc;  <span class="comment">//如果到最后还有进位，则存入数组末尾ans-&gt;s[2]=7</span></span><br><span class="line">ans-&gt;l = i;            <span class="comment">//记录结果的长度，上例中最后i=3</span></span><br></pre></td></tr></table></figure><p>退出for循环时，cc不为0说明仍有进位，记录该进位，如图3-62所示。</p><p><img src="https://source.drie.cn/qxsf-images/232.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-62　大整数a、b相乘结果（倒序）</b></center><p>ans结果为387，结果其实际含义是9×10<sup class="my_markdown">2</sup>×87×10<sup>3</sup>=783×10<sup>5</sup>。</p><p>（4）合并函数</p><p>add()函数将分解得到的数进行相加合并。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(pNode pa, pNode pb, pNode ans)</span> </span><br><span class="line">&#123;   <span class="comment">//程序调用时把 a、b地址传递给pa、pb参数，表示待合并的两个数</span></span><br><span class="line">    <span class="comment">//ans记录它们相加的结果</span></span><br><span class="line">    <span class="type">int</span> i, cc, k,alen,blen,len; </span><br><span class="line">    <span class="type">int</span> ta, tb;         <span class="comment">//ta、tb分别记录a、b相加时对应位上的数</span></span><br><span class="line">    pNode temp; </span><br><span class="line">    <span class="keyword">if</span>(pa-&gt;c &lt;pb-&gt;c)    <span class="comment">//交换以保证a的次幂大</span></span><br><span class="line">    &#123;</span><br><span class="line">          temp = pa; </span><br><span class="line">          pa = b; </span><br><span class="line">          pb =temp; </span><br><span class="line">    &#125;</span><br><span class="line">    ans-&gt;c = pb-&gt;c;  <span class="comment">//结果的次幂为两个数中小的次幂</span></span><br><span class="line">    cc = <span class="number">0</span>;          <span class="comment">//初始化进位cc为0</span></span><br><span class="line">    k=pa-&gt;c - pb-&gt;c  <span class="comment">//k为a左侧需要补零的个数</span></span><br></pre></td></tr></table></figure><p>举例说明：两个数a=673×10<sup class="my_markdown">2</sup>，b=98×10<sup>4</sup>相加。a的次幂为2，比b的次幂小，a、b交换，保证a的次幂大于等于b的次幂，交换后a=98×10<sup>4</sup>，b=673×10<sup class="my_markdown">2</sup>，倒序存储如图3-63所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ans-&gt;c = pb-&gt;c;     <span class="comment">//最低次幂作为结果的次幂，ans-&gt;c =pb-&gt;c=2</span></span><br><span class="line">cc = <span class="number">0</span>;             <span class="comment">//初始化进位cc为0</span></span><br><span class="line">k= pa-&gt;c - pb-&gt;c;   <span class="comment">//k为a左侧需要补零的个数，k=4-2=2</span></span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/233.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-63　大整数a、b存储数组（倒序）</b></center><p>如图3-64所示。</p><p><img src="https://source.drie.cn/qxsf-images/234.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-64　大整数a、b加法</b></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">alen=pa-&gt;l + pa-&gt;c;       <span class="comment">//a数加上次幂的总长度，上例中alen=6</span></span><br><span class="line">blen=pb-&gt;l + pb-&gt;c;       <span class="comment">//b数加上次幂的总长度，上例中alen= 5</span></span><br><span class="line"><span class="keyword">if</span>(alen&gt;blen) </span><br><span class="line">      len=alen;           <span class="comment">//取a、b总长度的最大值</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">      len=blen; </span><br><span class="line">len=len-pb-&gt;c;         <span class="comment">//结果的长度为a，b之中的最大值减去最低次幂，上例中len= 4</span></span><br><span class="line">             <span class="comment">//最低次幂是不进行加法运算的位数) </span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len; i++) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i &lt;k)             <span class="comment">//k为a左侧需要补零的个数</span></span><br><span class="line">           ta = <span class="number">0</span>;        <span class="comment">//a左侧补零</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">           ta =pa-&gt;s[i-k];<span class="comment">//i=k时，补0结束，从a数组中第0位开始取数字</span></span><br><span class="line">     <span class="keyword">if</span>(i &lt;b-&gt;l) </span><br><span class="line">           tb = pb-&gt;s[i]; <span class="comment">//从b数组中第0位开始取数字</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">           tb = <span class="number">0</span>;        <span class="comment">//b数字先取完，b右侧补0</span></span><br><span class="line">     <span class="keyword">if</span>(i&gt;=pa-&gt;l+k)       <span class="comment">//a数字先取完，a右侧补0</span></span><br><span class="line">           ta = <span class="number">0</span>; </span><br><span class="line">     ans-&gt;s[i] = (ta + tb + cc)%<span class="number">10</span>;  <span class="comment">//记录两位之和的个位数，十位做进位处理</span></span><br><span class="line">     cc = (ta + tb + cc)/<span class="number">10</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如图3-65所示。</p><p><img src="https://source.drie.cn/qxsf-images/235.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-65　大整数a、b加法结果</b></center><p>i=0时，ta=0，tb=3，ans-&gt;s[0] =（ta+tb+cc）%10=3，cc=（ta+tb+cc）/10=0。</p><p>i=1时，ta=0，tb=7，ans-&gt;s[1] =（ta+tb+cc）%10=7，cc=（ta+tb+cc）/10=0。</p><p>i=2时，ta=8，tb=6，ans-&gt;s[2] =（ta+tb+cc）%10=4，cc=（ta+tb+cc）/10=1。</p><p>i=3时，ta=9，tb=0，ans-&gt;s[3] =（ta+tb+cc）%10=0，cc=（ta+tb+cc）/10=1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(cc)    <span class="comment">//如果上面退出时有进位，即cc不为0</span></span><br><span class="line">     ans-&gt;s[i++] = cc;<span class="comment">//有进位，则存入数组末尾ans-&gt;s[4]=1</span></span><br><span class="line">ans-&gt;l = i;<span class="comment">//上例中ans-&gt;l = 5;</span></span><br></pre></td></tr></table></figure><p>如图3-66所示。</p><p><img src="https://source.drie.cn/qxsf-images/236.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-66　大整数a、b加法结果存储数组</b></center><h3 id="3-5-5-实战演练">3.5.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 3-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 100</span></span><br><span class="line"><span class="type">char</span> sa[<span class="number">1000</span>];</span><br><span class="line"><span class="type">char</span> sb[<span class="number">1000</span>];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> s[M];</span><br><span class="line">     <span class="type">int</span> l;                 <span class="comment">//代表字符串的长度</span></span><br><span class="line">     <span class="type">int</span> c;</span><br><span class="line">&#125; Node,*pNode;</span><br><span class="line"><span class="type">void</span> <span class="title function_">cp</span><span class="params">(pNode src, pNode des, <span class="type">int</span> st, <span class="type">int</span> l)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i, j;</span><br><span class="line">     <span class="keyword">for</span>(i=st, j=<span class="number">0</span>; i&lt;st+l; i++, j++)</span><br><span class="line">     &#123;</span><br><span class="line">          des-&gt;s[j] = src-&gt;s[i];</span><br><span class="line">     &#125;</span><br><span class="line">     des-&gt;l = l;</span><br><span class="line">     des-&gt;c = st + src-&gt;c;  <span class="comment">//次幂</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">add</span><span class="params">(pNode pa, pNode pb, pNode ans)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i,cc,k,palen,pblen,len;</span><br><span class="line">     <span class="type">int</span> ta, tb;</span><br><span class="line">     pNode temp;</span><br><span class="line">     <span class="keyword">if</span>((pa-&gt;c&lt;pb-&gt;c))          <span class="comment">//保证Pa的次幂大</span></span><br><span class="line">     &#123;</span><br><span class="line">          temp = pa;</span><br><span class="line">          pa = pb;</span><br><span class="line">          pb = temp;</span><br><span class="line">     &#125;</span><br><span class="line">     ans-&gt;c = pb-&gt;c;</span><br><span class="line">     cc = <span class="number">0</span>;</span><br><span class="line">     palen=pa-&gt;l + pa-&gt;c;</span><br><span class="line">     pblen=pb-&gt;l + pb-&gt;c;</span><br><span class="line">     <span class="keyword">if</span>(palen&gt;pblen)</span><br><span class="line">          len=palen;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">          len=pblen;</span><br><span class="line">     k=pa-&gt;c - pb-&gt;c;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;len-ans-&gt;c; i++) <span class="comment">//结果的长度最长为pa，pb之中的最大长度减去最低次幂</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(i&lt;k)</span><br><span class="line">               ta = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               ta = pa-&gt;s[i-k];        <span class="comment">//次幂高的补0，大于低的长度后与0进行计算</span></span><br><span class="line">          <span class="keyword">if</span>(i&lt;pb-&gt;l)</span><br><span class="line">               tb = pb-&gt;s[i];</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">               tb = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">if</span>(i&gt;=pa-&gt;l+k)</span><br><span class="line">               ta = <span class="number">0</span>;</span><br><span class="line">          ans-&gt;s[i] = (ta + tb + cc)%<span class="number">10</span>;</span><br><span class="line">          cc = (ta + tb + cc)/<span class="number">10</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span>(cc)</span><br><span class="line">          ans-&gt;s[i++] = cc;</span><br><span class="line">     ans-&gt;l = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mul</span><span class="params">(pNode pa, pNode pb, pNode ans)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> i, cc, w;</span><br><span class="line">     <span class="type">int</span> ma = pa-&gt;l&gt;&gt;<span class="number">1</span>, mb = pb-&gt;l&gt;&gt;<span class="number">1</span>; <span class="comment">//长度除2</span></span><br><span class="line">     Node ah, al, bh, bl;</span><br><span class="line">     Node t1, t2, t3, t4, z;</span><br><span class="line">     pNode temp;</span><br><span class="line">     <span class="keyword">if</span>(!ma || !mb)                    <span class="comment">//如果其中个数为1</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(!ma)  <span class="comment">//如果a串的长度为1，pa,pb交换，pa的长度大于等于pb的长度</span></span><br><span class="line">          &#123;</span><br><span class="line">               temp = pa;</span><br><span class="line">               pa = pb;</span><br><span class="line">               pb = temp;</span><br><span class="line">          &#125;</span><br><span class="line">          ans-&gt;c = pa-&gt;c + pb-&gt;c;</span><br><span class="line">          w = pb-&gt;s[<span class="number">0</span>];</span><br><span class="line">          cc = <span class="number">0</span>;                   <span class="comment">//此时的进位为c</span></span><br><span class="line">          <span class="keyword">for</span>(i=<span class="number">0</span>; i &lt; pa-&gt;l; i++)</span><br><span class="line">          &#123;</span><br><span class="line">               ans-&gt;s[i] = (w*pa-&gt;s[i] + cc)%<span class="number">10</span>;</span><br><span class="line">               cc= (w*pa-&gt;s[i] + cc)/<span class="number">10</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>(cc)</span><br><span class="line">               ans-&gt;s[i++] = cc;   <span class="comment">//如果到最后还有进位，则存入结果</span></span><br><span class="line">          ans-&gt;l = i;              <span class="comment">//记录结果的长度</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//分治的核心</span></span><br><span class="line">     cp(pa, &amp;ah, ma, pa-&gt;l-ma);    <span class="comment">//先分成4部分al,ah,bl,bh</span></span><br><span class="line">     cp(pa, &amp;al, <span class="number">0</span>, ma);</span><br><span class="line">     cp(pb, &amp;bh, mb, pb-&gt;l-mb);</span><br><span class="line">     cp(pb, &amp;bl, <span class="number">0</span>, mb);</span><br><span class="line">     mul(&amp;ah, &amp;bh, &amp;t1);           <span class="comment">//分成4部分相乘</span></span><br><span class="line">     mul(&amp;ah, &amp;bl, &amp;t2);</span><br><span class="line">     mul(&amp;al, &amp;bh, &amp;t3);</span><br><span class="line">     mul(&amp;al, &amp;bl, &amp;t4);</span><br><span class="line">     add(&amp;t3, &amp;t4, ans);</span><br><span class="line">     add(&amp;t2, ans, &amp;z);</span><br><span class="line">     add(&amp;t1, &amp;z, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     Node ans,a,b;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入大整数 a：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; sa;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入大整数 b：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; sb;</span><br><span class="line">     a.l=<span class="built_in">strlen</span>(sa);               <span class="comment">//sa,sb以字符串进行处理</span></span><br><span class="line">     b.l=<span class="built_in">strlen</span>(sb);</span><br><span class="line">     <span class="type">int</span> z=<span class="number">0</span>,i;</span><br><span class="line">     <span class="keyword">for</span>(i = a.l<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">          a.s[z++]=sa[i]-<span class="string">&#x27;0&#x27;</span>;      <span class="comment">//倒向存储</span></span><br><span class="line">     a.c=<span class="number">0</span>;</span><br><span class="line">     z=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(i = b.l<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">          b.s[z++] = sb[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">     b.c = <span class="number">0</span>;</span><br><span class="line">     mul(&amp;a, &amp;b, &amp;ans);</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最终结果为：&quot;</span>;</span><br><span class="line">     <span class="keyword">for</span>(i = ans.l<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; ans.s[i];        <span class="comment">//ans用来存储结果，倒向存储</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>Visual C++ 6.0</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入大整数a：</span><br><span class="line"><span class="number">123456789</span></span><br><span class="line">输入大整数b：</span><br><span class="line"><span class="number">123456789</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最终结果为：<span class="number">15241578750190521</span></span><br></pre></td></tr></table></figure><h3 id="3-5-6-算法解析与拓展">3.5.6　算法解析与拓展</h3><h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4><p>（1）时间复杂度：我们假设大整数a、b都是n位数，根据分治策略，<img class="my_markdown" src="https://source.drie.cn/qxsf-images/237.gif" style="width:35px;  height: 13px; "/>相乘将转换成了4个乘法运算ah<em>bh、ah</em>bl、al<em>bh、al</em>bl，而 <strong>乘数的位数变为了原来的一半</strong> 。直到最后递归分解到其中一个乘数为1位为止，每次递归就会使数据规模减小为原来的一半。假设两个n位大整数相乘的时间复杂度为T(n)，则：</p><p><img src="https://source.drie.cn/qxsf-images/238.gif" alt="code"><br>当n&gt;1时，可以递推求解如下：</p><p><img src="https://source.drie.cn/qxsf-images/239.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么有：</p><p><img src="https://source.drie.cn/qxsf-images/240.gif" alt="code"><br>大整数乘法的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：程序中变量占用了一些辅助空间，都是常数阶的，但合并时结点数组占用的辅助空间为O(n)，递归调用所使用的栈空间是O(logn)，想一想为什么？</p><p>大整数乘法的空间复杂度为O(n)。</p><h4 id="2．优化拓展-4">2．优化拓展</h4><p>如果两个大整数都是n位数，那么有：</p><p>A<em>B=a</em>c<em>10<sup class="my_markdown">n</sup>+（a</em>d+c*b）<em>10<sup>n / 2</sup>+b</em>d</p><p>还记得快速算出1+2+3+…+100的小高斯吗？这孩子长大以后更聪明，他把4次乘法运算变成了3次乘法：</p><p>a<em>d+c</em>b=（a−b）（d−c）+a<em>c+b</em>d</p><p>A<em>B= a</em>c<em>10 <sup class="my_markdown">n</sup> +（（a−b）（d−c）+a</em>c+b*d）<em>10 <sup>n / 2</sup> +b</em>d</p><p>这样公式中，就只有a<em>c、（a−b）（d−c）、b</em>d， <strong>只需要进行3次乘法</strong> 。</p><p>那么时间复杂度为：</p><p><img src="https://source.drie.cn/qxsf-images/241.gif" alt="code"><br>当n&gt;1时，可以递推求解如下：</p><p><img src="https://source.drie.cn/qxsf-images/242.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么有：</p><p><img src="https://source.drie.cn/qxsf-images/243.gif" alt="code"><br>优化改进后的大整数乘法的时间复杂度从O(n<sup class="my_markdown">2</sup>)降为O(n<sup>1.59</sup>)，这是一个巨大的改进！</p><p>但是 <strong>需要注意</strong> ：在上面的公式中，A和B必须2<sup class="my_markdown">n</sup>位。很容易证明，如果不为2<sup class="my_markdown">n</sup>，那么A或者B在分解过程中必会出现奇数，那么a<em>c和（（a−b）（d−c）+a</em>c+b*d）的次幂就有可能不同，无法变为3次乘法了，解决方法也很简单，只需要补齐位数即可，在数前（高位）补0。</p><h3 id="3-6-分治算法复杂度求解秘籍">3.6　分治算法复杂度求解秘籍</h3><p>分治法的道理非常简单，就是把一个大的复杂问题分为a（a&gt;1）个形式相同的子问题，这些子问题的规模为n/b，如果分解或者合并的复杂度为f(n)，那么总的时间复杂度可以表示为：</p><p><img src="https://source.drie.cn/qxsf-images/244.gif" alt="code"><br>那么如何求解时间复杂度呢？</p><p>上面的求解方式都是递推求解，写出其递推式，最后求出结果。</p><p>例如，合并排序算法的时间复杂度递推求解如下：</p><p><img src="https://source.drie.cn/qxsf-images/173.gif" alt="code"><br>递推最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/155.gif" style="width:51px;  height: 13px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么有：</p><p><img src="https://source.drie.cn/qxsf-images/175.gif" alt="code"></p><h4 id="1．递归树求解法">1．递归树求解法</h4><p>递归树求解方式其实和递推求解一样，只是递归树更清楚直观地显示出来，更能够形象地表达每层分解的结点和每层产生的成本。例如：<img class="my_markdown" src="https://source.drie.cn/qxsf-images/245.gif" style="width:172px;  height: 18px; "/>，如图3-67所示。</p><p>时间复杂度=叶子数*T(1)+成本和=<img class="my_markdown" src="https://source.drie.cn/qxsf-images/246.gif" style="width:123px;  height: 18px; "/>。</p><p><img src="https://source.drie.cn/qxsf-images/247.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-67　分治递归树</b></center><p>因为<img class="my_markdown" src="https://source.drie.cn/qxsf-images/248.gif" style="width:47px;  height: 12px; "/>，则<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/174.gif" style="width:72px;  height: 16px; "/>，那么时间复杂度=<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/246.gif" style="width:123px;  height: 18px; "/><img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/249.gif" style="width:229px;  height: 18px; "/>。</p><h4 id="2．大师解法">2．大师解法</h4><p>我们用递归树来说明大师解法：</p><p><img src="https://source.drie.cn/qxsf-images/250.gif" alt="code"><br>如果<img class="my_markdown" src="https://source.drie.cn/qxsf-images/251.gif" style="width:35px;  height: 18px; "/>的数量级是<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/252.gif" style="width:45px;  height: 20px; "/>，那么原公式转化为<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/253.gif" style="width:193px;  height: 21px; "/>，如图3-68所示。</p><p><img src="https://source.drie.cn/qxsf-images/254.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-68　大师解法递归树</b></center><p>递归最终的规模为1，令<img class="my_markdown" src="https://source.drie.cn/qxsf-images/255.gif" style="width:35px;  height: 18px; "/>=1，那么<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/256.gif" style="width:75px;  height: 18px; "/>，即树高<img src="https://cdn.ptpress.cn/pubcloud/5B0A982E/ushu/N13082/online/FBOL6c69757cef863/Images/257.gif" style="width:74px;  height: 18px; "/>。</p><p>叶子数：。</p><p><img src="https://source.drie.cn/qxsf-images/258.gif" alt="code"><br>成本和：。</p><p><img src="https://source.drie.cn/qxsf-images/259.gif" alt="code"><br>时间复杂度=叶子数*T(1)+成本和</p><p>第1层成本：。</p><p><img src="https://source.drie.cn/qxsf-images/252.gif" alt="code"><br>最后1层成本：</p><p><img src="https://source.drie.cn/qxsf-images/260.gif" alt="code"><br>最后1层成本约等于叶子数<img class="my_markdown" src="https://source.drie.cn/qxsf-images/261.gif" style="width:40px;  height: 17px; "/>，既然最后一层成本约等于叶子数，那么叶子数*T(1)就可以省略了，即 <strong>时间复杂度=成本和。</strong></p><p>现在我们只需要观察每层产生的成本的发展趋势，是递减的还是递增的，还是每层都一样？每层成本的公比为<img class="my_markdown" src="https://source.drie.cn/qxsf-images/262.gif" style="width:33px;  height: 21px; "/>。</p><p>（1）每层成本是递减的（a/b<sup class="my_markdown">d</sup>&lt;1）那么时间复杂度在渐进趋势上，成本和可以按 <strong>第1层</strong> 计算，其他忽略不计，即 <strong>时间复杂度</strong> 为：</p><p><img src="https://source.drie.cn/qxsf-images/263.gif" alt="code"><br>（2）每层成本是递增的（a/b<sup class="my_markdown">d</sup>&gt;1)那么时间复杂度在渐进趋势上，成本和可以按 <strong>最后1层</strong> 计算，其他忽略不计，即 <strong>时间复杂度</strong> 为：</p><p><img src="https://source.drie.cn/qxsf-images/264.gif" alt="code"><br>（3）每层成本是相同的（<img class="my_markdown" src="https://source.drie.cn/qxsf-images/265.gif" style="width:66px;  height: 21px; "/>)，那么时间复杂度在渐进趋势上，每层成本都一样，我们把 <strong>第一层的成本乘以树高</strong> 即可。 <strong>时间复杂度</strong> 为：</p><p><img src="https://source.drie.cn/qxsf-images/266.gif" alt="code"><br>形如<img class="my_markdown" src="https://source.drie.cn/qxsf-images/253.gif" style="width:193px;  height: 21px; "/>的时间复杂度 <strong>求解秘籍</strong> ：</p><p><img src="https://source.drie.cn/qxsf-images/267.jpg" alt="code"><br>举例如下。</p><ul><li>猜数游戏</li></ul><p><img src="https://source.drie.cn/qxsf-images/268.gif" alt="code"><br>a=1，b=2，d=0，公比a/b<sup class="my_markdown">d</sup>=1，则<img class="my_markdown" src="https://source.drie.cn/qxsf-images/269.gif" style="width:236px;  height: 21px; "/>。</p><ul><li>快速排序</li></ul><p><img src="https://source.drie.cn/qxsf-images/270.gif" alt="code"><br>a=2，b=2，d=1，公比a/b<sup class="my_markdown">d</sup>=1，则<img class="my_markdown" src="https://source.drie.cn/qxsf-images/271.gif" style="width:250px;  height: 21px; "/>。</p><ul><li>大整数乘法</li></ul><p><img src="https://source.drie.cn/qxsf-images/272.gif" alt="code"><br>a=4，b=2，d=1，公比a/b<sup class="my_markdown">d</sup>&gt;1，则<img class="my_markdown" src="https://source.drie.cn/qxsf-images/273.gif" style="width:200px;  height: 21px; "/>。</p><ul><li>大整数乘法改进算法</li></ul><p><img src="https://source.drie.cn/qxsf-images/274.gif" alt="code"><br>a=3，b=2，d=1，公比a/b<sup class="my_markdown">d</sup>&gt;1，则<img class="my_markdown" src="https://source.drie.cn/qxsf-images/275.gif" style="width:216px;  height: 21px; "/>。</p><p>那么，如果时间复杂度公式不是<img class="my_markdown" src="https://source.drie.cn/qxsf-images/253.gif" style="width:193px;  height: 21px; "/>怎么办呢？</p><p>画出递归树，观察每层产生的成本：</p><p>成本的公比小于1，时间复杂度按 <strong>第1层</strong> 计算；</p><p>成本的公比大于1，时间复杂度按 <strong>最后1层</strong> 计算；</p><p>成本的公比等于1，时间复杂度按 <strong>第1层*树高</strong> 计算。</p><p>以求解为例。</p><p><img src="https://source.drie.cn/qxsf-images/276.gif" alt="code"><br>递推式解法如下：</p><p><img src="https://source.drie.cn/qxsf-images/277.gif" alt="code"><br>大师解法如下：</p><p>递归树如图3-69所示。</p><p><img src="https://source.drie.cn/qxsf-images/278.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图3-69　大师解法递归树</b></center><p>首先从递归树中观察每层产生的成本发展趋势，每层的成本有时不是那么有规律，需要仔细验证。例如第3层是(5/16)<sup class="my_markdown">2</sup>n<sup class="my_markdown">2</sup>，需要验证第4层是(5/16)<sup>3</sup>n<sup class="my_markdown">2</sup>。经过验证，我们发现每层成本是一个等比数列，公比为5/16（小于1），呈递减趋势，那么只计算第1项即可，时间复杂度为T(n)=O(n<sup class="my_markdown">2</sup>)。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第三章-分治法&quot;&gt;第三章　分治法&lt;/h3&gt;
&lt;p&gt;分而治之是一种很古老但很实用的策略，或者说战略，本意是将一个较大的力量打碎分成小的力量，这样每个小的力量都不足以对抗大的力量。在现实应用中，分而治之往往是将大片区域分成小块区域治理。战国时期，秦国破坏合纵连横即是一</summary>
      
    
    
    
    <category term="算法" scheme="https://drie.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>《趣学算法》——第二章（贪心算法）</title>
    <link href="https://drie.cn/posts/7177a99d.html"/>
    <id>https://drie.cn/posts/7177a99d.html</id>
    <published>2024-07-02T01:00:00.000Z</published>
    <updated>2024-07-02T01:44:15.348Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第二章-贪心算法">第二章　贪心算法</h3><p>从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相还不满足，还要求做皇帝。蛇此时终于明白了，人的贪心是永无止境的，于是一口就把这个人吞掉了。</p><p>所以，蛇吞掉的是宰相，而不是大象。故此，留下了“人心不足蛇吞相”的典故。</p><h3 id="2-1-人之初，性本贪">2.1　人之初，性本贪</h3><p>我们小时候背诵《三字经》，“人之初，性本善，性相近，习相远。”其实我觉得很多时候“人之初，性本贪”。小孩子吃糖果，总是想要多多的；吃水果，想要最大的；买玩具，总是想要最好的，这些东西并不是大人教的，而是与生俱来的。对美好事物的趋优性，就像植物的趋光性，“良禽择木而栖，贤臣择主而事”“窈窕淑女，君子好逑”，我们似乎永远在追求美而优的东西。现实中的很多事情，正是因为趋优性使我们的生活一步一步走向美好。例如，我们竭尽所能买了一套房子，然后就想要添置一些新的家具，再就想着可能还需要一辆车子……</p><p>凡事都有两面性，一把刀可以做出美味佳肴，也可以变成杀人凶器。在这里，我们只谈好的“贪心”。</p><h3 id="2-1-1-贪心本质">2.1.1　贪心本质</h3><p>一个贪心算法总是做出当前最好的选择，也就是说，它期望通过局部最优选择从而得到全局最优的解决方案。</p><p>——《算法导论》</p><p>我们经常会听到这些话：“人要活在当下”“看清楚眼前”……贪心算法正是“活在当下，看清楚眼前”的办法，从问题的初始解开始，一步一歩地做出当前最好的选择，逐步逼近问题的目标，尽可能地得到最优解，即使达不到最优解，也可以得到最优解的近似解。</p><p>贪心算法在解决问题的策略上“目光短浅”，只根据当前已有的信息就做出选择，而且一旦做出了选择，不管将来有什么结果，这个选择都不会改变。换言之，贪心算法并不是从整体最优考虑，它所做出的选择只是在某种意义上的局部最优。贪心算法能得到许多问题的整体最优解或整体最优解的近似解。因此，贪心算法在实际中得到大量的应用。</p><p>在贪心算法中，我们需要注意以下几个问题。</p><p>（1）没有后悔药。一旦做出选择，不可以反悔。</p><p>（2）有可能得到的不是最优解，而是最优解的近似解。</p><p>（3）选择什么样的贪心策略，直接决定算法的好坏。</p><p>那么，贪心算法需要遵循什么样的原则呢？</p><h3 id="2-1-2-贪亦有道">2.1.2　贪亦有道</h3><p>“君子爱财，取之有道”，我们在贪心算法中“贪亦有道”。通常我们在遇到具体问题时，往往分不清哪些问题该用贪心策略求解，哪些问题不能使用贪心策略。经过实践我们发现，利用贪心算法求解的问题往往具有两个重要的特性：贪心选择性质和最优子结构性质。如果满足这两个性质就可以使用贪心算法了。</p><p>（1）贪心选择</p><p>所谓贪心选择性质是指原问题的整体最优解可以通过一系列局部最优的选择得到。应用同一规则，将原问题变为一个相似的但规模更小的子问题，而后的每一步都是当前最佳的选择。这种选择依赖于已做出的选择，但不依赖于未做出的选择。运用贪心策略解决的问题在程序的运行过程中无回溯过程。关于贪心选择性质，读者可在后续的贪心策略状态空间图中得到深刻的体会。</p><p>（2）最优子结构</p><p>当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质。问题的最优子结构性质是该问题是否可用贪心算法求解的关键。例如原问题S={a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…，a<sub class="my_markdown">i</sub>，…，a<sub class="my_markdown">n</sub>}，通过贪心选择选出一个当前最优解{a<sub class="my_markdown">i</sub>}之后，转化为求解子问题S−{a<sub class="my_markdown">i</sub>}，如果原问题的最优解包含子问题的最优解，则说明该问题满足最优子结构性质，如图2-1所示。</p><p><img src="https://source.drie.cn/qxsf-images/27.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-1　原问题和子问题</b></center><h3 id="2-1-3-贪心算法秘籍">2.1.3　贪心算法秘籍</h3><p>武林中有武功秘籍，算法中也有贪心秘籍。上面我们已经知道了具有贪心选择和最优子结构性质就可以使用贪心算法，那么如何使用呢？下面介绍贪心算法秘籍。</p><p>（1）贪心策略</p><p>首先要确定贪心策略，选择当前看上去最好的一个方案。例如，挑选苹果，如果你认为个大的是最好的，那你每次都从苹果堆中拿一个最大的，作为局部最优解，贪心策略就是选择当前最大的苹果；如果你认为最红的苹果是最好的，那你每次都从苹果堆中拿一个最红的，贪心策略就是选择当前最红的苹果。因此根据求解目标不同，贪心策略也会不同。</p><p>（2）局部最优解</p><p>根据贪心策略，一步一步地得到局部最优解。例如，第一次选一个最大的苹果放起来，记为a<sub class="my_markdown">1</sub>，第二次再从剩下的苹果堆中选择一个最大的苹果放起来，记为a<sub>2</sub>，以此类推。</p><p>（3）全局最优解</p><p>把所有的局部最优解合成为原来问题的一个最优解（a<sub class="my_markdown">1</sub>，a<sub>2</sub>，…）。</p><blockquote><p>怎么有点儿像冒泡排序啊？</p></blockquote><p>“不是六郎似荷花，而是荷花似六郎”！不是贪心算法像冒泡排序，而是冒泡排序使用了贪心算法，它的贪心策略就是每一次从剩下的序列中选一个最大的数，把这些选出来的数放在一起，就得到了从大到小的排序结果，如图2-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/28.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-2　冒泡排序</b></center><h3 id="2-2-加勒比海盗船——最优装载问题">2.2　加勒比海盗船——最优装载问题</h3><p>在北美洲东南部，有一片神秘的海域，那里碧海蓝天、阳光明媚，这正是传说中海盗最活跃的加勒比海（Caribbean Sea）。17世纪时，这里更是欧洲大陆的商旅舰队到达美洲的必经之地，所以当时的海盗活动非常猖獗，海盗不仅攻击过往商人，甚至攻击英国皇家舰……</p><p>有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值。虽然海盗船足够大，但载重量为C，每件古董的重量为w<sub class="my_markdown">i</sub>，海盗们该如何把尽可能多数量的宝贝装上海盗船呢？</p><p><img src="https://source.drie.cn/qxsf-images/29.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-3　加勒比海盗</b></center><h3 id="2-2-1-问题分析">2.2.1　问题分析</h3><p>根据问题描述可知这是一个可以用贪心算法求解的最优装载问题，要求装载的物品的数量尽可能多，而船的容量是固定的，那么优先把重量小的物品放进去，在容量固定的情况下，装的物品最多。采用重量最轻者先装的贪心选择策略，从局部最优达到全局最优，从而产生最优装载问题的最优解。</p><h3 id="2-2-2-算法设计">2.2.2　算法设计</h3><p>（1）当载重量为定值c时，w<sub class="my_markdown">i</sub>越小时，可装载的古董数量n越大。只要依次选择最小重量古董，直到不能再装为止。</p><p>（2）把n个古董的重量从小到大（非递减）排序，然后根据贪心策略尽可能多地选出前i个古董，直到不能继续装为止，此时达到最优。</p><h3 id="2-2-3-完美图解">2.2.3　完美图解</h3><p>我们现在假设这批古董如图2-4所示。</p><p><img src="https://source.drie.cn/qxsf-images/30.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-4　古董图片</b></center><p>每个古董的重量如表2-1所示，海盗船的载重量c为30，那么在不能打碎古董又不超过载重的情况下，怎么装入最多的古董？</p><center class="my_markdown"><b class="my_markdown">表2-1　古董重量清单</b></center><p>| 重量w[i] | 4 | 10 | 7 | 11 | 3 | 5 | 14 | 2 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p><p>（1）因为贪心策略是每次选择重量最小的古董装入海盗船，因此可以按照古董重量非递减排序，排序后如表2-2所示。</p><center class="my_markdown"><b class="my_markdown">表2-2　按重量排序后古董清单</b></center><p>| 重量w[i] | 2 | 3 | 4 | 5 | 7 | 10 | 11 | 14 || :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |</p><p>（2）按照贪心策略，每次选择重量最小的古董放入（tmp 代表古董的重量，ans 代表已装裁的古董个数）。</p><p>i=0，选择排序后的第1个，装入重量tmp=2，不超过载重量30，ans =1。</p><p>i=1，选择排序后的第2个，装入重量tmp=2+3=5，不超过载重量30，ans =2。</p><p>i=2，选择排序后的第3个，装入重量tmp=5+4=9，不超过载重量30，ans =3。</p><p>i=3，选择排序后的第4个，装入重量tmp=9+5=14，不超过载重量30，ans =4。</p><p>i=4，选择排序后的第5个，装入重量tmp=14+7=21，不超过载重量30，ans =5。</p><p>i=5，选择排序后的第6个，装入重量tmp=21+10=31，超过载重量30，算法结束。</p><p>即放入古董的个数为ans=5个。</p><h3 id="2-2-4-伪代码详解">2.2.4　伪代码详解</h3><p>（1）数据结构定义</p><p>根据算法设计描述，我们用一维数组存储古董的重量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> w[N];  <span class="comment">//一维数组存储古董的重量</span></span><br></pre></td></tr></table></figure><p>（2）按重量排序</p><p>可以利用C++中的排序函数sort（见附录B），对古董的重量进行从小到大（非递减）排序。要使用此函数需引入头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>语法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">//参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                <span class="comment">//sort函数默认为升序</span></span><br></pre></td></tr></table></figure><p>在本例中只需要调用sort函数对古董的重量进行从小到大排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(w, w+n); <span class="comment">//按古董重量升序排序</span></span><br></pre></td></tr></table></figure><p>（3）按照贪心策略找最优解</p><p>首先用变量ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量，两个变量都初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果小于等于载重量c，则令ans ++；否则，退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = <span class="number">0</span>;  <span class="comment">//tmp代表装载到船上的古董的重量，ans记录已经装载的古董个数</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">     ans ++;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-2-5-实战演练">2.2.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-1</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000005</span>;</span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">double</span> w[N]; <span class="comment">//古董的重量数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> c;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入载重量c及古董个数n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;c&gt;&gt;n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个古董的重量，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;w[i]; <span class="comment">//输入每个物品重量</span></span><br><span class="line">    &#125;</span><br><span class="line">    sort(w,w+n); <span class="comment">//按古董重量升序排序</span></span><br><span class="line">    <span class="type">double</span> temp=<span class="number">0.0</span>;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>; <span class="comment">// tmp为已装载到船上的古董重量，ans为已装载的古董个数 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        tmp+=w[i];</span><br><span class="line">        <span class="keyword">if</span>(tmp&lt;=c)</span><br><span class="line">           ans ++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;能装入的古董最大数量为Ans=&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans&lt;&lt;<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入载重量c及古董个数n：</span><br><span class="line"><span class="number">30</span> <span class="number">8</span>   <span class="comment">//载重量c及古董的个数n </span></span><br><span class="line">请输入每个古董的重量，用空格分开：</span><br><span class="line"><span class="number">4</span> <span class="number">10</span> <span class="number">7</span> <span class="number">11</span> <span class="number">3</span> <span class="number">5</span> <span class="number">14</span> <span class="number">2</span>  <span class="comment">//每个古董的重量，用空格隔开</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">能装入的古董最大数量为Ans=<span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="2-2-6-算法解析及优化拓展">2.2.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析">1．算法复杂度分析</h4><p>（1）时间复杂度：首先需要按古董重量排序，调用sort函数，其平均时间复杂度为O(nlogn)，输入和贪心策略求解的两个for语句时间复杂度均为O(n)，因此时间复杂度为O(n + nlog(n))。</p><p>（2）空间复杂度：程序中变量tmp、ans等占用了一些辅助空间，这些辅助空间都是常数阶的，因此空间复杂度为O(1)。</p><h4 id="2．优化拓展">2．优化拓展</h4><p>（1）这一个问题为什么在没有装满的情况下，仍然是最优解？算法要求装入最多数量，假如c为5，4个物品重量分别为1、3、5、7。排序后，可以装入1和3，最多装入两个。分析发现是最优的，如果装大的物品，最多装一个或者装不下，所以选最小的先装才能装入最多的数量，得到解是最优的。</p><p>（2）在伪代码详解的第3步“按照贪心策略找最优解”，如果把代码替换成下面代码，有什么不同？</p><p>首先用变量ans记录已经装载的古董个数，初始化为n；tmp代表装载到船上的古董的重量，初始化为0。然后按照重量从小到大排序，依次检查每个古董，tmp加上该古董的重量，如果tmp大于等于载重量c，则判断是否正好等于载重量c，并令ans=i+1；否则ans = i，退出。如果tmp小于载重量c，i++，继续下一个循环。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> tmp = <span class="number">0</span>,ans = n;  <span class="comment">//ans记录已经装载的古董个数，tmp代表装载到船上的古董的重量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line">  tmp += w[i];</span><br><span class="line">  <span class="keyword">if</span>(tmp&gt;=c)</span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>(tmp==c) <span class="comment">//假如刚好，最后一个可以放</span></span><br><span class="line">        ans = i+<span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        ans = i; <span class="comment">//如果满了，最后一个不能放</span></span><br><span class="line">     <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）如果想知道装入了哪些古董，需要添加什么程序来实现呢？请大家动手试一试吧！</p><p>那么，还有没有更好的算法来解决这个问题呢？</p><h3 id="2-3-阿里巴巴与四十大盗——背包问题">2.3　阿里巴巴与四十大盗——背包问题</h3><p>有一天，阿里巴巴赶着一头毛驴上山砍柴。砍好柴准备下山时，远处突然出现一股烟尘，弥漫着直向上空飞扬，朝他这儿卷过来，而且越来越近。靠近以后，他才看清原来是一支马队，他们共有四十人，一个个年轻力壮、行动敏捷。一个首领模样的人背负沉重的鞍袋，从丛林中一直来到那个大石头跟前，喃喃地说道：“芝麻，开门吧！”随着那个头目的喊声，大石头前突然出现一道宽阔的门路，于是强盗们鱼贯而入。阿里巴巴待在树上观察他们，直到他们走得无影无踪之后，才从树上下来。他大声喊道：“芝麻，开门吧！”他的喊声刚落，洞门立刻打开了。他小心翼翼地走了进去，一下子惊呆了，洞中堆满了财物，还有多得无法计数的金银珠宝，有的散堆在地上，有的盛在皮袋中。突然看见这么多的金银财富，阿里巴巴深信这肯定是一个强盗们数代经营、掠夺所积累起来的宝窟。为了让乡亲们开开眼界，见识一下这些宝物，他想一种宝物只拿一个，如果太重就用锤子凿开，但毛驴的运载能力是有限的，怎么才能用驴子运走最大价值的财宝分给穷人呢？</p><p>阿里巴巴陷入沉思中……</p><p><img src="https://source.drie.cn/qxsf-images/31.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-5　阿里巴巴与四十大盗</b></center><h3 id="2-3-1-问题分析">2.3.1　问题分析</h3><p>假设山洞中有n种宝物，每种宝物有一定重量w和相应的价值v，毛驴运载能力有限，只能运走m重量的宝物，一种宝物只能拿一样，宝物可以分割。那么怎么才能使毛驴运走宝物的价值最大呢？</p><p>我们可以尝试贪心策略：</p><p>（1）每次挑选价值最大的宝物装入背包，得到的结果是否最优？</p><p>（2）每次挑选重量最小的宝物装入，能否得到最优解？</p><p>（3）每次选取单位重量价值最大的宝物，能否使价值最高？</p><p>思考一下，如果选价值最大的宝物，但重量非常大，也是不行的，因为运载能力是有限的，所以第1种策略舍弃；如果选重量最小的物品装入，那么其价值不一定高，所以不能在总重限制的情况下保证价值最大，第2种策略舍弃；而第3种是每次选取单位重量价值最大的宝物，也就是说每次选择性价比（价值/重量）最高的宝物，如果可以达到运载重量m，那么一定能得到价值最大。</p><p>因此采用第3种贪心策略，每次从剩下的宝物中选择性价比最高的宝物。</p><h3 id="2-3-2-算法设计">2.3.2　算法设计</h3><p>（1）数据结构及初始化。将n种宝物的重量和价值存储在结构体three（包含重量、价值、性价比3个成员）中，同时求出每种宝物的性价比也存储在对应的结构体three中，将其按照性价比从高到低排序。采用sum来存储毛驴能够运走的最大价值，初始化为0。</p><p>（2）根据贪心策略，按照性价比从大到小选取宝物，直到达到毛驴的运载能力。每次选择性价比高的物品，判断是否小于m（毛驴运载能力），如果小于m，则放入，sum（已放入物品的价值）加上当前宝物的价值，m减去放入宝物的重量；如果不小于m，则取该宝物的一部分m * p[i]，m=0，程序结束。m减少到0，则sum得到最大值。</p><h3 id="2-3-3-完美图解">2.3.3　完美图解</h3><p>假设现在有一批宝物，价值和重量如表 2-3 所示，毛驴运载能力 m=30，那么怎么装入最大价值的物品？</p><center class="my_markdown"><b class="my_markdown">表2-3　宝物清单</b></center><p>| 宝物i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 4 | 2 | 9 | 5 | 5 | 8 | 5 | 4 | 5 | 5 |<br>| 价值v[i] | 3 | 8 | 18 | 6 | 8 | 20 | 5 | 6 | 7 | 15 |</p><p>（1）因为贪心策略是每次选择性价比（价值/重量）高的宝物，可以按照性价比降序排序，排序后如表2-4所示。</p><center class="my_markdown"><b class="my_markdown">表2-4　排序后宝物清单</b></center><p>| 宝物i | 2 | 10 | 6 | 3 | 5 | 8 | 9 | 4 | 7 | 1 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 2 | 5 | 8 | 9 | 5 | 4 | 5 | 5 | 5 | 4 |<br>| 价值v[i] | 8 | 15 | 20 | 18 | 8 | 6 | 7 | 6 | 5 | 3 |<br>| 性价比p[i] | 4 | 3 | 2.5 | 2 | 1.6 | 1.5 | 1.4 | 1.2 | 1 | 0.75 |</p><p>（2）按照贪心策略，每次选择性价比高的宝物放入：</p><p>第1次选择宝物2，剩余容量30−2=28，目前装入最大价值为8。</p><p>第2次选择宝物10，剩余容量28−5=23，目前装入最大价值为8+15=23。</p><p>第3次选择宝物6，剩余容量23−8=15，目前装入最大价值为23+20=43。</p><p>第4次选择宝物3，剩余容量15−9=6，目前装入最大价值为43+18=61。</p><p>第5次选择宝物5，剩余容量6−5=1，目前装入最大价值为61+8=69。</p><p>第6次选择宝物8，发现上次处理完时剩余容量为1，而8号宝物重量为4，无法全部放入，那么可以采用部分装入的形式，装入1个重量单位，因为8号宝物的单位重量价值为1.5，因此放入价值1×1.5=1.5，你也可以认为装入了8号宝物的1/4，目前装入最大价值为69+1.5=70.5，剩余容量为0。</p><p>（3）构造最优解</p><p>把这些放入的宝物序号组合在一起，就得到了最优解（2，10，6，3，5，8），其中最后一个宝物为部分装入（装了8号财宝的1/4），能够装入宝物的最大价值为70.5。</p><h3 id="2-3-4-伪代码详解">2.3.4　伪代码详解</h3><p>（1）数据结构定义</p><p>根据算法设计中的数据结构，我们首先定义一个结构体three：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w; <span class="comment">//每种宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v; <span class="comment">//每种宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p; <span class="comment">//每种宝物的性价比（价值/重量）</span></span><br><span class="line">     ｝</span><br></pre></td></tr></table></figure><p>（2）性价比排序</p><p>我们可以利用C++中的排序函数sort（见附录B），对宝物的性价比从大到小（非递增）排序。要使用此函数需引入头文件：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br></pre></td></tr></table></figure><p>语法描述为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort(begin, end)<span class="comment">// 参数begin和end表示一个范围，分别为待排序数组的首地址和尾地址</span></span><br></pre></td></tr></table></figure><p>在本例中我们采用结构体形式存储，按结构体中的一个字段，即按性价比排序。如果不使用自定义比较函数，那么sort函数排序时不知道按哪一项的值排序，因此采用自定义比较函数的办法实现宝物性价比的降序排序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span><span class="comment">//比较函数按照宝物性价比降序排列</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a.p &gt; b.p; <span class="comment">//指明按照宝物性价比降序排列</span></span><br><span class="line">&#125;</span><br><span class="line">sort(s, s+n, cmp); <span class="comment">//前两个参数分别为待排序数组的首地址和尾地址</span></span><br><span class="line">                   <span class="comment">//最后一个参数compare表示比较的类型</span></span><br></pre></td></tr></table></figure><p>（3）贪心算法求解</p><p>在性价比排序的基础上，进行贪心算法运算。如果剩余容量比当前宝物的重量大，则可以放入，剩余容量减去当前宝物的重量，已放入物品的价值加上当前宝物的价值。如果剩余容量比当前宝物的重量小，表示不可以全部放入，可以切割下来一部分（正好是剩余容量），然后令剩余容量乘以当前物品的单位重量价值，已放入物品的价值加上该价值，即为能放入宝物的最大价值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n;i++)<span class="comment">//按照排好的顺序，执行贪心策略</span></span><br><span class="line">  &#123;</span><br><span class="line">     <span class="keyword">if</span>( m &gt; s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的运载能力，即剩余容量</span></span><br><span class="line">     &#123;</span><br><span class="line">        m -= s[i].w;</span><br><span class="line">        sum += s[i].v;</span><br><span class="line">      &#125;</span><br><span class="line">     <span class="keyword">else</span>  <span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">      &#123;</span><br><span class="line">         sum += m乘以s[i].p;  <span class="comment">//进行宝物切割，切割一部分(m重量)，正好达到驴子承重</span></span><br><span class="line">         <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-5-实战演练">2.3.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-2</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> M=<span class="number">1000005</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">three</span>&#123;</span></span><br><span class="line">     <span class="type">double</span> w;<span class="comment">//每个宝物的重量</span></span><br><span class="line">     <span class="type">double</span> v;<span class="comment">//每个宝物的价值</span></span><br><span class="line">     <span class="type">double</span> p;<span class="comment">//性价比</span></span><br><span class="line">&#125;s[M];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(three a,three b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> a.p&gt;b.p;<span class="comment">//根据宝物的单位价值从大到小排序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> n;<span class="comment">//n 表示有n个宝物</span></span><br><span class="line">     <span class="type">double</span> m ;<span class="comment">//m 表示毛驴的承载能力</span></span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入宝物数量n及毛驴的承载能力m ：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入每个宝物的重量和价值，用空格分开： &quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s[i].w&gt;&gt;s[i].v;</span><br><span class="line">         s[i].p=s[i].v/s[i].w;<span class="comment">//每个宝物单位价值</span></span><br><span class="line">     &#125;</span><br><span class="line">     sort(s,s+n,cmp);</span><br><span class="line">     <span class="type">double</span> sum=<span class="number">0.0</span>;<span class="comment">// sum表示贪心记录运走宝物的价值之和</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="comment">//按照排好的顺序贪心</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">if</span>( m&gt;s[i].w )<span class="comment">//如果宝物的重量小于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              m-=s[i].w;</span><br><span class="line">              sum+=s[i].v;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span><span class="comment">//如果宝物的重量大于毛驴剩下的承载能力</span></span><br><span class="line">         &#123;</span><br><span class="line">              sum+=m*s[i].p;<span class="comment">//部分装入</span></span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;装入宝物的最大价值Maximum value=&quot;</span>&lt;&lt;sum&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">19</span> <span class="comment">//宝物数量，驴子的承载重量</span></span><br><span class="line"><span class="number">2</span> <span class="number">8</span> <span class="comment">//第1个宝物的重量和价值</span></span><br><span class="line"><span class="number">6</span> <span class="number">1</span> <span class="comment">//第2个宝物的重量和价值</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">10</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Maxinum value=<span class="number">24.6</span></span><br></pre></td></tr></table></figure><h3 id="2-3-6-算法解析及优化拓展">2.3.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-2">1．算法复杂度分析</h4><p>（1）时间复杂度：该算法的时间主要耗费在将宝物按照性价比排序上，采用的是快速排序，算法时间复杂度为O(nlogn)。</p><p>（2）空间复杂度：空间主要耗费在存储宝物的性价比，空间复杂度为O(n)。</p><p>为了使 m 重量里的所有物品的价值最大，利用贪心思想，每次取剩下物品里面性价比最高的物品，这样可以使得在相同重量条件下比选其他物品所得到的价值更大，因此采用贪心策略能得到最优解。</p><h4 id="2．算法优化拓展">2．算法优化拓展</h4><p>那么想一想，如果宝物不可分割，贪心算法是否能得到最优解？</p><p>下面我们看一个简单的例子。</p><p>假定物品的重量和价值已知，如表2-5所示，最大运载能力为10。采用贪心算法会得到怎样的结果？</p><center class="my_markdown"><b class="my_markdown">表2-5　物品清单</b></center><p>| 物品i | 1 | 2 | 3 | 4 | 5 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 重量w[i] | 3 | 4 | 6 | 10 | 7 |<br>| 价值v[i] | 15 | 16 | 18 | 25 | 14 |<br>| 性价比p[i] | 5 | 4 | 3 | 2.5 | 2 |</p><p>如果我们采用贪心算法，先装性价比高的物品，且物品不能分割，剩余容量如果无法再装入剩余的物品，不管还有没有运载能力，算法都会结束。那么我们选择的物品为 1和2，总价值为 31，而实际上还有 3 个剩余容量，但不足以装下剩余其他物品，因此得到的最大价值为31。但实际上我们如果选择物品2和3，正好达到运载能力，得到的最大价值为34。也就是说，在物品不可分割、没法装满的情况下，贪心算法并不能得到最优解，仅仅是最优解的近似解。</p><p>想一想，为什么会这样呢？</p><p>物品可分割的装载问题我们称为 <strong>背包问题</strong> ，物品不可分割的装载问题我们称之为 <strong>0-1背包问题</strong> 。</p><p>在物品不可分割的情况下，即0-1背包问题，已经不具有贪心选择性质，原问题的整体最优解无法通过一系列局部最优的选择得到，因此这类问题得到的是近似解。如果一个问题不要求得到最优解，而只需要一个最优解的近似解，则不管该问题有没有贪心选择性质都可以使用贪心算法。</p><p>想一想，2.3节中加勒比海盗船问题为什么在没有装满的情况下，仍然是最优解，而0-1背包问题在没装满的情况下有可能只是最优解的近似解？</p><h3 id="2-4-高级钟点秘书——会议安排">2.4　高级钟点秘书——会议安排</h3><p>所谓“钟点秘书”，是指年轻白领女性利用工余时间为客户提供秘书服务，并按钟点收取酬金。</p><p>“钟点秘书”为客户提供有偿服务的方式一般是：采用电话、电传、上网等“遥控”式服务，或亲自到客户公司处理部分业务。其服务对象主要有三类：一是外地前来考察商务经营、项目投资的商人或政要人员，他们由于初来乍到，急需有经验和熟悉本地情况的秘书帮忙；二是前来开展短暂商务活动，或召开小型资讯发布会的国外客商；三是本地一些请不起长期秘书的企、事业单位。这些客户普遍认为：请“钟点秘书”，一则可免去专门租楼请人的大笔开销；二则可根据开展的商务活动请有某方面专长的可用人才；三则由于对方是临时雇用关系，工作效率往往比固定的秘书更高。据调查，在上海“钟点秘书”的行情日趋看好。对此，业内人士认为：为了便于管理，各大城市有必要组建若干家“钟点秘书服务公司”，通过会员制的形式，为众多客户提供规范、优良、全面的服务，这也是建设国际化大都市所必需的。</p><p>某跨国公司总裁正分身无术，为一大堆会议时间表焦头烂额，希望高级钟点秘书能做出合理的安排，能在有限的时间内召开更多的会议。</p><p><img src="https://source.drie.cn/qxsf-images/32.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-6　高级钟点秘书</b></center><h3 id="2-4-1-问题分析">2.4.1　问题分析</h3><p>这是一个典型的会议安排问题，会议安排的目的是能在有限的时间内召开更多的会议（任何两个会议不能同时进行）。在会议安排中，每个会议i都有起始时间b<sub class="my_markdown">i</sub>和结束时间e<sub class="my_markdown">i</sub>，且b<sub class="my_markdown">i</sub>&lt;e<sub class="my_markdown">i</sub>，即一个会议进行的时间为半开区间[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）。如果[b<sub class="my_markdown">i</sub>，e<sub class="my_markdown">i</sub>）与[b<sub class="my_markdown">j</sub>，e<sub class="my_markdown">j</sub>）均在“有限的时间内”，且不相交，则称会议i与会议j相容的。也就是说，当b<sub class="my_markdown">i</sub>≥e<sub class="my_markdown">j</sub>或b<sub class="my_markdown">j</sub>≥e<sub class="my_markdown">i</sub>时，会议i与会议j相容。会议安排问题要求在所给的会议集合中选出最大的相容活动子集，即尽可能在有限的时间内召开更多的会议。</p><p>在这个问题中，“有限的时间内（这段时间应该是连续的）”是其中的一个限制条件，也应该是有一个起始时间和一个结束时间（简单化，起始时间可以是会议最早开始的时间，结束时间可以是会议最晚结束的时间），任务就是实现召开更多的满足在这个“有限的时间内”等待安排的会议，会议时间表如表2-6所示。</p><center class="my_markdown"><b class="my_markdown">表2-6　会议时间表</b></center><p>| 会议i | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间b<sub class="my_markdown">i</sub> | 8 | 9 | 10 | 11 | 13 | 14 | 15 | 17 | 18 | 16 |<br>| 结束时间e<sub class="my_markdown">i</sub> | 10 | 11 | 15 | 14 | 16 | 17 | 17 | 18 | 20 | 19 |</p><p>会议安排的时间段如图2-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/33.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-7　会议安排时间段</b></center><p>从图2-7中可以看出，{会议1，会议4，会议6，会议8，会议9}，{会议2，会议4，会议7，会议8，会议9}都是能安排最多的会议集合。</p><p>要让会议数最多，我们需要选择最多的不相交时间段。我们可以尝试贪心策略：</p><p>（1）每次从剩下未安排的会议中选择会议 <strong>具有最早开始时间且与已安排的会议相容</strong> 的会议安排，以增大时间资源的利用率。</p><p>（2）每次从剩下未安排的会议中选择 <strong>持续时间最短且与已安排的会议相容</strong> 的会议安排，这样可以安排更多一些的会议。</p><p>（3）每次从剩下未安排的会议中选择 <strong>具有最早结束时间且与已安排的会议相容</strong> 的会议安排，这样可以尽快安排下一个会议。</p><p>思考一下，如果选择最早开始时间，则如果会议持续时间很长，例如8点开始，却要持续12个小时，这样一天就只能安排一个会议；如果选择持续时间最短，则可能开始时间很晚，例如19点开始，20点结束，这样也只能安排一个会议，所以我们最好选择那些开始时间要早，而且持续时间短的会议，即最早开始时间+持续时间最短，就是 <strong>最早结束</strong> 时间。</p><p>因此采用第（3）种 <strong>贪心策略，每次从剩下的会议中选择具有最早结束时间且与已安排的会议相容的会议安排</strong> 。</p><h3 id="2-4-2-算法设计">2.4.2　算法设计</h3><p>（1）初始化：将n个会议的开始时间、结束时间存放在结构体数组中（想一想，为什么不用两个一维数组分别存储？），如果需要知道选中了哪些会议，还需要在结构体中增加会议编号，然后按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）；</p><p>（2）根据贪心策略就是选择第一个具有最早结束时间的会议，用last记录刚选中会议的结束时间；</p><p>（3）选择第一个会议之后，依次 <strong>从剩下未安排的会议中选择</strong> ，如果会议i开始时间大于等于最后一个选中的会议的结束时间last，那么会议i与已选中的会议相容，可以安排，更新last为刚选中会议的结束时间；否则，舍弃会议i，检查下一个会议是否可以安排。</p><h3 id="2-4-3-完美图解">2.4.3　完美图解</h3><h4 id="1．原始的会议时间表（见表2-7）：">1．原始的会议时间表（见表2-7）：</h4><center class="my_markdown"><b class="my_markdown">表2-7　原始会议时间表</b></center><p>| 会议num | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间beg | 3 | 1 | 5 | 2 | 5 | 3 | 8 | 6 | 8 | 12 |<br>| 结束时间end | 6 | 4 | 7 | 5 | 9 | 8 | 11 | 10 | 12 | 14 |</p><h4 id="2．排序后的会议时间表（见表2-8）：">2．排序后的会议时间表（见表2-8）：</h4><center class="my_markdown"><b class="my_markdown">表2-8　排序后的会议时间表</b></center><p>| 会议num | 2 | 4 | 1 | 3 | 6 | 5 | 8 | 7 | 9 | 10 |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 开始时间beg | 1 | 2 | 3 | 5 | 3 | 5 | 6 | 8 | 8 | 12 |<br>| 结束时间end | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 14 |</p><h4 id="3．贪心选择过程">3．贪心选择过程</h4><p>（1）首先选择排序后的第一个会议即最早结束的会议（编号为2），用last记录最后一个被选中会议的结束时间，last=4。</p><p>（2）检查余下的会议，找到第一个开始时间大于等于 last（last=4）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-9所示。</p><center class="my_markdown"><b class="my_markdown">表2-9　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/34.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为3)，更新last为刚选中会议的结束时间last=7。</p><p>（3）检查余下的会议，找到第一个开始时间大于等于last（last=7）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-10所示。</p><center class="my_markdown"><b class="my_markdown">表2-10　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/35.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为 7)，更新 last 为刚选中会议的结束时间last=11。</p><p>（4）检查余下的会议，找到第一个开始时间大于等于last（last=11）的会议，子问题转化为从该会议开始，余下的所有会议。如表2-11所示。</p><center class="my_markdown"><b class="my_markdown">表2-11　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/36.jpg" alt="code"><br>从子问题中，选择第一个会议即最早结束的会议（编号为10)，更新last为刚选中会议的结束时间last=14；所有会议检查完毕，算法结束。如表2-12所示。</p><h4 id="4．构造最优解">4．构造最优解</h4><p>从贪心选择的结果，可以看出，被选中的会议编号为{2，3，7，10}，可以安排的会议数量最多为4，如表2-12所示。</p><center class="my_markdown"><b class="my_markdown">表2-12　会议时间表</b></center><p><img src="https://source.drie.cn/qxsf-images/37.jpg" alt="code"></p><h3 id="2-4-4-伪代码详解">2.4.4　伪代码详解</h3><p>（1）数据结构定义</p><p>以下C++程序代码中，结构体meet中定义了beg表示会议的开始时间，end表示会议的结束时间，会议meet的数据结构：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">&#125; meet[<span class="number">1000</span>]；</span><br></pre></td></tr></table></figure><p>（2）对会议按照结束时间非递减排序</p><p>我们采用C++中自带的sort函数，自定义比较函数的办法，实现会议排序，按结束时间从小到大排序（非递减），结束时间相等时，按开始时间从大到小排序（非递增）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x.end==y.end)  <span class="comment">//结束时间相等时 </span></span><br><span class="line">        <span class="keyword">return</span> x.beg&gt;y.beg; <span class="comment">//按开始时间从大到小排序</span></span><br><span class="line">     <span class="keyword">return</span> x.end&lt;y.end; <span class="comment">//按结束时间从小到大排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(meet,meet+n,cmp);</span><br></pre></td></tr></table></figure><p>（3）会议安排问题的贪心算法求解</p><p>在会议按结束时间非递减排序的基础上，首先选中第一个会议，用last变量记录刚刚被选中会议的结束时间。下一个会议的开始时间与last比较，如果大于等于last，则选中。每次选中一个会议，更新last为最后一个被选中会议的结束时间，被选中的会议数ans加1；如果会议的开始时间不大于等于last，继续考查下一个会议，直到所有会议考查完毕。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ans=<span class="number">1</span>;     <span class="comment">//用来记录可以安排会议的个数，初始时选中了第一个会议</span></span><br><span class="line"><span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//last记录第一个会议的结束时间</span></span><br><span class="line"><span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n; i++)   <span class="comment">//依次检查每个会议</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(meet[i].beg &gt; =last) </span><br><span class="line">    &#123;     <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">       ans++;</span><br><span class="line">       last = meet[i].end; <span class="comment">//更新last为最后一个选中会议的结束时间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans; <span class="comment">//返回可以安排的会议最大数</span></span><br></pre></td></tr></table></figure><p>上面介绍的程序中，只是返回了可以安排的会议最大数，而不知道安排了哪些会议，这显然是不满足需要的。我们可以改进一下，在会议结构体meet中添加会议编号num变量，选中会议时，显示选中了第几个会议。</p><h3 id="2-4-5-实战演练">2.4.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-3</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Meet</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> beg;   <span class="comment">//会议的开始时间</span></span><br><span class="line">     <span class="type">int</span> end;   <span class="comment">//会议的结束时间</span></span><br><span class="line">     <span class="type">int</span> num;   <span class="comment">//记录会议的编号</span></span><br><span class="line">&#125;meet[<span class="number">1000</span>];    <span class="comment">//会议的最大个数为1000</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">setMeet</span>&#123;</span></span><br><span class="line">  public:</span><br><span class="line">    <span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">solve</span><span class="params">()</span>;</span><br><span class="line">  private:</span><br><span class="line">    <span class="type">int</span> n,ans; <span class="comment">// n:会议总数 ans: 最大的安排会议总数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//读入数据</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> s,e;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议总数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入会议的开始时间和结束时间，以空格分开：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;s&gt;&gt;e;</span><br><span class="line">         meet[i].beg=s;</span><br><span class="line">         meet[i].end=e;</span><br><span class="line">         meet[i].num=i+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">cmp</span><span class="params">(Meet x,Meet y)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (x.end == y.end)</span><br><span class="line">           <span class="keyword">return</span> x.beg &gt; y.beg;</span><br><span class="line">     <span class="keyword">return</span> x.end &lt; y.end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">setMeet::solve</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     sort(meet,meet+n,cmp);    <span class="comment">//对会议按结束时间排序</span></span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;排完序的会议时间如下：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;会议编号&quot;</span>&lt;&lt;<span class="string">&quot;  开始时间 &quot;</span>&lt;&lt;<span class="string">&quot; 结束时间&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n;i++)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; meet[i].num&lt;&lt;<span class="string">&quot;\t\t&quot;</span>&lt;&lt;meet[i].beg &lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt; meet[i].end &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;-------------------------------------------------&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;选择的会议的过程：&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt; meet[<span class="number">0</span>].num&lt;&lt;<span class="string">&quot;个会议&quot;</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">//选中了第一个会议</span></span><br><span class="line">     ans=<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> last = meet[<span class="number">0</span>].end;  <span class="comment">//记录刚刚被选中会议的结束时间</span></span><br><span class="line">     <span class="keyword">for</span>( i = <span class="number">1</span>;i &lt; n;++i)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="keyword">if</span>(meet[i].beg&gt;=last)</span><br><span class="line">          &#123;            <span class="comment">//如果会议i开始时间大于等于最后一个选中的会议的结束时间</span></span><br><span class="line">             ans++;</span><br><span class="line">             last = meet[i].end;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;  选择第&quot;</span>&lt;&lt;meet[i].num&lt;&lt;<span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;最多可以安排&quot;</span> &lt;&lt;ans &lt;&lt; <span class="string">&quot;个会议&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  setMeet sm;</span><br><span class="line">  sm.init();<span class="comment">//读入数据</span></span><br><span class="line">  sm.solve();<span class="comment">//贪心算法求解</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入会议总数：</span><br><span class="line"><span class="number">10</span></span><br><span class="line">输入会议的开始时间和结束时间，以空格分开：</span><br><span class="line"><span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">3</span> <span class="number">8</span></span><br><span class="line"><span class="number">8</span> <span class="number">11</span></span><br><span class="line"><span class="number">6</span> <span class="number">10</span></span><br><span class="line"><span class="number">8</span> <span class="number">12</span></span><br><span class="line"><span class="number">12</span> <span class="number">14</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">排完序的会议时间如下：</span><br><span class="line">会议编号    开始时间    结束时间</span><br><span class="line">   <span class="number">2</span>           <span class="number">1</span>          <span class="number">4</span></span><br><span class="line">   <span class="number">4</span>           <span class="number">2</span>          <span class="number">5</span></span><br><span class="line">   <span class="number">1</span>           <span class="number">3</span>          <span class="number">6</span></span><br><span class="line">   <span class="number">3</span>           <span class="number">5</span>          <span class="number">7</span></span><br><span class="line">   <span class="number">6</span>           <span class="number">3</span>          <span class="number">8</span></span><br><span class="line">   <span class="number">5</span>           <span class="number">5</span>          <span class="number">9</span></span><br><span class="line">   <span class="number">8</span>           <span class="number">6</span>          <span class="number">10</span></span><br><span class="line">   <span class="number">7</span>           <span class="number">8</span>          <span class="number">11</span></span><br><span class="line">   <span class="number">9</span>           <span class="number">8</span>          <span class="number">12</span></span><br><span class="line">   <span class="number">10</span>          <span class="number">12</span>         <span class="number">14</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">选择的会议的过程：</span><br><span class="line">  选择第<span class="number">2</span>个会议</span><br><span class="line">  选择第<span class="number">3</span>个会议</span><br><span class="line">  选择第<span class="number">7</span>个会议</span><br><span class="line">  选择第<span class="number">10</span>个会议</span><br><span class="line">最多可以安排<span class="number">4</span>个会议</span><br></pre></td></tr></table></figure><p>使用上面贪心算法可得，选择的会议是第2、3、7、10个会议，输出最优值是4。</p><h3 id="2-4-6-算法解析及优化拓展">2.4.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-3">1．算法复杂度分析</h4><p>（1）时间复杂度：在该算法中，问题的规模就是会议总个数n。显然，执行次数随问题规模的增大而变化。首先在成员函数setMeet::init()中，输入n个结构体数据。输入作为基本语句，显然，共执行n次。而后在调用成员函数setMeet::solve()中进行排序，易知sort排序函数的平均时间复杂度为O(nlogn)。随后进行选择会议，贡献最大的为if(meet[i].beg&gt;=last)语句，时间复杂度为O(n)，总时间复杂度为O(n +nlogn)= O(nlogn)。</p><p>（2）空间复杂度：在该算法中，meet[]结构体数组为输入数据，不计算在空间复杂度内。辅助空间有i、n、ans等变量，则该程序空间复杂度为常数阶，即O(1)。</p><h4 id="2．算法优化拓展-2">2．算法优化拓展</h4><p>想一想，你有没有更好的办法来处理此问题，比如有更小的算法时间复杂度？</p><h3 id="2-5-一场说走就走的旅行——最短路径">2.5　一场说走就走的旅行——最短路径</h3><p>有一天，孩子回来对我说：“妈妈，听说马尔代夫很不错，放假了我想去玩。”马尔代夫？我也想去！没有人不向往一场说走就走的旅行！“其实我想去的地方很多，呼伦贝尔大草原、玉龙雪山、布达拉宫、艾菲尔铁塔……”小孩子还说着他感兴趣的地方。于是我们拿出地图，标出想去的地点，然后计算最短路线，估算大约所需的时间，有了这张秘制地图，一场说走就走的旅行不是梦！</p><p>“哇，感觉我们像凡尔纳的《环游地球八十天》，好激动！可是老妈你也太out了，学计算机的最短路线你用手算？”</p><p>暴汗……，“小子你别牛，你知道怎么算？”</p><p>“呃，好像是叫什么迪科斯彻的人会算。”</p><p>哈哈，关键时刻还要老妈上场了！</p><p><img src="https://source.drie.cn/qxsf-images/38.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-8　一场说走就走的旅行</b></center><h3 id="2-5-1-问题分析">2.5.1　问题分析</h3><p>根据题目描述可知，这是一个求单源最短路径的问题。给定有向带权图<strong>G</strong> =（V，Ｅ），其中每条边的权是非负实数。此外，给定V中的一个顶点，称为源点。现在要计算从源到所有其他各顶点的最短路径长度，这里路径长度指路上各边的权之和。</p><p>如何求源点到其他各点的最短路径呢？</p><p>如图2-9所示，艾兹格•W•迪科斯彻（Edsger Wybe Dijkstra），荷兰人，计算机科学家。他早年钻研物理及数学，后转而研究计算学。他曾在1972年获得过素有“计算机科学界的诺贝尔奖”之称的图灵奖，与Donald Ervin Knuth并称为我们这个时代最伟大的计算机科学家。</p><p><img src="https://source.drie.cn/qxsf-images/39.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-9　艾兹格•W•迪科斯彻</b></center><h3 id="2-5-2-算法设计">2.5.2　算法设计</h3><p>Dijkstra 算法是解决单源最短路径问题的贪心算法，它先求出长度最短的一条路径，再参照该最短路径求出长度次短的一条路径，直到求出从源点到其他各个顶点的最短路径。</p><p>Dijkstra算法的基本思想是首先假定源点为u，顶点集合V被划分为两部分：集合S和 V−S。初始时 S 中仅含有源点 u，其中 S 中的顶点到源点的最短路径已经确定。集合V−S中所包含的顶点到源点的最短路径的长度待定，称从源点出发只经过S中的点到达V−S中的点的路径为特殊路径，并用数组dist[]记录当前每个顶点所对应的最短特殊路径长度。</p><p>Dijkstra算法采用的贪心策略是选择特殊路径长度最短的路径，将其连接的V−S中的顶点加入到集合S中，同时更新数组dist[]。一旦S包含了所有顶点，dist[]就是从源到所有其他顶点之间的最短路径长度。</p><p>（1）数据结构。设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从源点u到顶点i有边，就令 <strong>map</strong>[u][i]等于&lt;u，i&gt;的权值，否则 <strong>map</strong>[u][i]=∞（无穷大）；采用一维数组 dist[i]来记录从源点到i顶点的最短路径长度；采用一维数组p[i]来记录最短路径上i顶点的前驱。</p><p>（2）初始化。令集合S={u}，对于集合V−S中的所有顶点x，初始化dist[i]=<strong>map</strong>[u][i]，如果源点u到顶点i有边相连，初始化p[i]=u，否则p[i]= −1。</p><p>（3）找最小。在集合V−S中依照贪心策略来寻找使得dist[j]具有最小值的顶点t，即dist[t]=min（dist[j]|j属于V−S集合），则顶点t就是集合V−S中距离源点u最近的顶点。</p><p>（4）加入S战队。将顶点t加入集合S中，同时更新V−S。</p><p>（5）判结束。如果集合V−S为空，算法结束，否则转（6）。</p><p>（6）借东风。在（3）中已经找到了源点到t的最短路径，那么对集合V−S中所有与顶点t相邻的顶点j，都可以借助t走捷径。如果dis[j]&gt;dist[t]+<strong>map</strong>[t][j]，则dist[j]=dist[t]+<strong>map</strong>[t][j]，记录顶点j的前驱为t，有p[j]= t，转（3）。</p><p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过数组p[]逆向找到最短路径上经过的城市。</p><h3 id="2-5-3-完美图解">2.5.3　完美图解</h3><p>现在我们有一个景点地图，如图2-10所示，假设从1号结点出发，求到其他各个结点的最短路径。</p><p><img src="https://source.drie.cn/qxsf-images/40.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-10　景点地图</b></center><p>算法步骤如下。</p><p>（1）数据结构</p><p>设置地图的带权邻接矩阵为<strong>map</strong>[][]，即如果从顶点i到顶点j有边，则<strong>map</strong>[i][j]等于&lt;i，j&gt;的权值，否则<strong>map</strong>[i][j]=∞（无穷大），如图2-11所示。</p><p><img src="https://source.drie.cn/qxsf-images/41.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-11　邻接矩阵**map**[][]</b></center><p>（2）初始化</p><p>令集合S={1}，V−S={2，3，4，5}，对于集合V−S中的所有顶点x，初始化最短距离数组dist[i]=<strong>map</strong>[1][i]，dist[u]=0，如图2-12所示。如果源点1到顶点i有边相连，初始化前驱数组p[i]=1，否则p[i]= −1，如图2-13所示。</p><p><img src="https://source.drie.cn/qxsf-images/42.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-12　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/43.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-13　前驱数组p[]</b></center><p>（3）找最小</p><p>在集合V−S={2，3，4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-14所示。</p><p><img src="https://source.drie.cn/qxsf-images/44.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-14　最短距离数组dist[]</b></center><p>找到最小值为2，对应的结点t=2。</p><p>（4）加入S战队</p><p>将顶点t=2加入集合S中S={1，2}，同时更新V−S={3，4，5}，如图2-15所示。</p><p><img src="https://source.drie.cn/qxsf-images/45.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-15　景点地图</b></center><p>（5）借东风</p><p>刚刚找到了源点到t=2的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵都可以看出，2号结点的邻接点是3和4号结点，如图2-16所示。</p><p><img src="https://source.drie.cn/qxsf-images/46.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-16　邻接矩阵**map**[][]</b></center><p>先看3号结点能否借助2号走捷径：dist[2]+<strong>map</strong>[2][3]=2+2=4，而当前dist[3]=5&gt;4，因此可以走捷径即2—3，更新dist[3]=4，记录顶点3的前驱为2，即p[3]= 2。</p><p>再看4号结点能否借助2号走捷径：如果dist[2]+<strong>map</strong>[2][4]=2+6=8，而当前dist[4]=∞&gt;8，因此可以走捷径即2—4，更新dist[4]=8，记录顶点4的前驱为2，即p[4]= 2。</p><p>更新后如图2-17和图2-18所示。</p><p><img src="https://source.drie.cn/qxsf-images/47.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-17　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/48.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-18　前驱数组p[]</b></center><p>（6）找最小</p><p>在集合V−S={3，4，5}中，依照贪心策略来寻找dist[]具有最小值的顶点t，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-19所示。</p><p><img src="https://source.drie.cn/qxsf-images/49.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-19　最短距离数组dist[]</b></center><p>找到最小值为4，对应的结点t=3。</p><p>（7）加入S战队</p><p>将顶点t=3加入集合S中S={1，2，3}，同时更新V−S={4，5}，如图2-20所示。</p><p><img src="https://source.drie.cn/qxsf-images/50.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-20　景点地图</b></center><p>（8）借东风</p><p>刚刚找到了源点到t =3的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，3号结点的邻接点是4和5号结点。</p><p>先看4号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][4]=4+7=11，而当前dist[4]=8&lt;11，比当前路径还长，因此不更新。</p><p>再看5号结点能否借助3号走捷径：dist[3]+<strong>map</strong>[3][5]=4+1=5，而当前dist[5]=∞&gt;5，因此可以走捷径即3—5，更新dist[5]=5，记录顶点5的前驱为3，即p[5]=3。</p><p>更新后如图2-21和图2-22所示。</p><p><img src="https://source.drie.cn/qxsf-images/51.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-21　最短距离数组dist[]</b></center><p><img src="https://source.drie.cn/qxsf-images/52.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-22　前驱数组p[]</b></center><p>（9）找最小</p><p>在集合V−S={4，5}中，依照贪心策略来寻找V−S集合中dist[]最小的顶点t，如图2-23所示。</p><p><img src="https://source.drie.cn/qxsf-images/53.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-23　最短距离数组dist[]</b></center><p>找到最小值为5，对应的结点t=5。</p><p>（10）加入S战队</p><p>将顶点t=5加入集合S中S={1，2，3，5}，同时更新V−S={4}，如图2-24所示。</p><p><img src="https://source.drie.cn/qxsf-images/54.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-24　景点地图</b></center><p>（11）借东风</p><p>刚刚找到了源点到t =5的最短路径，那么对集合V−S中所有t的邻接点j，都可以借助t走捷径。我们从图或邻接矩阵可以看出，5号结点没有邻接点，因此不更新，如图2-25和图2-26所示。</p><p><img src="https://source.drie.cn/qxsf-images/56.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-26　前驱数组p[]</b></center><p>（12）找最小</p><p>在集合V−S={4}中，依照贪心策略来寻找dist[]最小的顶点t，只有一个顶点，所以很容易找到，如图2-27所示。</p><p><img src="https://source.drie.cn/qxsf-images/57.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-27　最短距离数组dist[]</b></center><p>找到最小值为8，对应的结点t=4。</p><p>（13）加入S战队</p><p>将顶点t加入集合S中S={1，2，3，5，4}，同时更新V−S={ }，如图2-28所示。</p><p><img src="https://source.drie.cn/qxsf-images/58.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-28　景点地图</b></center><p>（14）算法结束</p><p>V−S={ }为空时，算法停止。</p><p>由此，可求得从源点u到图<strong>G</strong>的其余各个顶点的最短路径及长度，也可通过前驱数组p[]逆向找到最短路径上经过的城市，如图2-29所示。</p><p><img src="https://source.drie.cn/qxsf-images/59.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-29　前驱数组p[]</b></center><p>例如，p[5]=3，即5的前驱是3；p[3]=2，即3的前驱是2；p[2]=1，即2的前驱是1；p[1]= −1，1没有前驱，那么从源点1到5的最短路径为1—2—3—5。</p><h3 id="2-5-4-伪代码详解">2.5.4　伪代码详解</h3><p>（1）数据结构</p><p>n：城市顶点个数。m：城市间路线的条数。<strong>map</strong>[][]：地图对应的带权邻接矩阵。dist[]：记录源点u到某顶点的最短路径长度。p[]：记录源点到某顶点的最短路径上的该顶点的前一个顶点（前驱）。flag[]：flag[i]等于true，说明顶点i已经加入到集合S，否则顶点i属于集合V−S。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">//初始化城市的个数，可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">//无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;</span><br><span class="line"><span class="type">bool</span> flag[N];</span><br></pre></td></tr></table></figure><p>（2）初始化源点u到其他各个顶点的最短路径长度，初始化源点u出边邻接点（t的出边相关联的顶点）的前驱为u：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> flag[n];<span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则i属于集合V-S</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">      dist[i] = <span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">      flag[i]=<span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">         p[i]=<span class="number">-1</span>;   <span class="comment">//说明源点u到顶点i无边相连，设置p[i]=-1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">         p[i]=u;   <span class="comment">//说明源点u到顶点i有边相连，设置p[i]=u</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>（3）初始化集合S，令集合S={u}，从源点到u的最短路径为0。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flag[u]=<span class="literal">true</span>;   <span class="comment">//初始化集合S中，只有一个元素：源点 u </span></span><br><span class="line">dist[u] = <span class="number">0</span>;   <span class="comment">//初始化源点 u的最短路径为0，自己到自己的最短路径</span></span><br></pre></td></tr></table></figure><p>（4）找最小</p><p>在集合V−S中寻找距离源点u最近的顶点t，若找不到t，则跳出循环；否则，将t加入集合S。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF,t = u ;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n ; j ++) <span class="comment">//在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">  <span class="keyword">if</span>( !flag[j] &amp;&amp; dist[j] &lt; temp)</span><br><span class="line">  &#123;</span><br><span class="line">     t=j;   <span class="comment">//记录距离源点u最近的顶点</span></span><br><span class="line">     temp=dist[j];</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span>(t == u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">flag[t] = <span class="literal">true</span>;      <span class="comment">//否则，将t加入集合S</span></span><br></pre></td></tr></table></figure><p>（5）借东风</p><p>考查集合V−S中源点u到t的邻接点j的距离，如果源点u经过t到达j的路径更短，则更新dist[j] =dist[t]+<strong>map</strong>[t][j]，即松弛操作，并记录j的前驱为t：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j ++)  <span class="comment">//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">   <span class="keyword">if</span>(!flag[j] &amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF) <span class="comment">//!flag[j]表示j在V-S中，map[t][j]&lt;INF表示t与j邻接</span></span><br><span class="line">      <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j])) <span class="comment">//经过t到达j的路径更短</span></span><br><span class="line">      &#123;</span><br><span class="line">         dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">         p[j]=t; <span class="comment">//记录j的前驱为t </span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>重复（4）～（5），直到源点u到所有顶点的最短路径被找到。</p><h3 id="2-5-5-实战演练">2.5.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-4</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stack&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 初始化无穷大为10000000</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],p[N],n,m;<span class="comment">//n城市的个数，m为城市间路线的条数</span></span><br><span class="line"><span class="type">bool</span> flag[N]; <span class="comment">//如果flag[i]等于true，说明顶点i已经加入到集合S;否则顶点i属于集合V-S</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//①</span></span><br><span class="line">    &#123;</span><br><span class="line">     dist[i] =<span class="built_in">map</span>[u][i]; <span class="comment">//初始化源点u到其他各个顶点的最短路径长度</span></span><br><span class="line">     flag[i]=<span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">        p[i]=<span class="number">-1</span>; <span class="comment">//源点u到该顶点的路径长度为无穷大，说明顶点i与源点u不相邻</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        p[i]=u; <span class="comment">//说明顶点i与源点u相邻，设置顶点i的前驱p[i]=u</span></span><br><span class="line">     &#125;</span><br><span class="line">    dist[u] = <span class="number">0</span>;</span><br><span class="line">    flag[u]=<span class="literal">true</span>;   <span class="comment">//初始时，集合S中只有一个元素：源点u</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)<span class="comment">//②</span></span><br><span class="line">     &#123;</span><br><span class="line">         <span class="type">int</span> temp = INF,t = u;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) <span class="comment">//③在集合V-S中寻找距离源点u最近的顶点t</span></span><br><span class="line">           <span class="keyword">if</span>(!flag[j]&amp;&amp;dist[j]&lt;temp)</span><br><span class="line">             &#123;</span><br><span class="line">              t=j;</span><br><span class="line">              temp=dist[j];</span><br><span class="line">             &#125;</span><br><span class="line">           <span class="keyword">if</span>(t==u) <span class="keyword">return</span> ; <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">           flag[t]= <span class="literal">true</span>;  <span class="comment">//否则，将t加入集合</span></span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)<span class="comment">//④//更新集合V-S中与t邻接的顶点到源点u的距离</span></span><br><span class="line">             <span class="keyword">if</span>(!flag[j]&amp;&amp; <span class="built_in">map</span>[t][j]&lt;INF)<span class="comment">//!s[j]表示j在V-S中  </span></span><br><span class="line">                <span class="keyword">if</span>(dist[j]&gt;(dist[t]+<span class="built_in">map</span>[t][j]))</span><br><span class="line">                 &#123;</span><br><span class="line">                   dist[j]=dist[t]+<span class="built_in">map</span>[t][j] ;</span><br><span class="line">                   p[j]=t ;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">     &#123;</span><br><span class="line">             <span class="type">int</span> u,v,w,st;</span><br><span class="line">             system(<span class="string">&quot;color 0d&quot;</span>);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线以及距离：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">               <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">               &#123;</span><br><span class="line">                   <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">               &#125;</span><br><span class="line">             <span class="keyword">while</span>(m--)</span><br><span class="line">             &#123;</span><br><span class="line">               <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">               <span class="built_in">map</span>[u][v] =min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">             &#125;</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">             <span class="built_in">cin</span> &gt;&gt; st;</span><br><span class="line">             Dijkstra(st);</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明：&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot; - &quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">if</span>(dist[i] == INF)</span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                   <span class="keyword">else</span></span><br><span class="line">                      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最短距离为:&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">11</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">12</span></span><br><span class="line"><span class="number">5</span> <span class="number">1</span> <span class="number">8</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">16</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">29</span></span><br><span class="line"><span class="number">5</span> <span class="number">2</span> <span class="number">32</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">13</span></span><br><span class="line"><span class="number">4</span> <span class="number">2</span> <span class="number">27</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">21</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">19</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">5</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">1</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">2</span> 最短距离为：<span class="number">24</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">3</span> 最短距离为：<span class="number">23</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">4</span> 最短距离为：<span class="number">30</span></span><br><span class="line">小明:<span class="number">5</span> - 要去的位置:<span class="number">5</span> 最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure><p>想一想：因为我们在程序中使用p[]数组记录了最短路径上每一个结点的前驱，因此除了显示最短距离外，还可以显示最短路径上经过了哪些城市，可以增加一段程序逆向找到该最短路径上的城市序列。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">findpath</span><span class="params">(<span class="type">int</span> u)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> x;</span><br><span class="line">  <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;s;<span class="comment">//利用C++自带的函数创建一个栈s，需要程序头部引入#include&lt;stack&gt;</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点为：&quot;</span>&lt;&lt;u&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">  &#123;</span><br><span class="line">    x=p[i];</span><br><span class="line">    <span class="keyword">while</span>(x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      s.push(x);<span class="comment">//将前驱依次压入栈中</span></span><br><span class="line">      x=p[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;源点到其他各顶点最短路径为：&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!s.empty())</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="string">&quot;--&quot;</span>;<span class="comment">//依次取栈顶元素</span></span><br><span class="line">      s.pop();<span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;;最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只需要在主函数末尾调用该函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">findpath(st);<span class="comment">//主函数中st为源点</span></span><br></pre></td></tr></table></figure><p>输出结果如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">源点为：<span class="number">5</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>；最短距离为：<span class="number">8</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-2</span>；最短距离为：<span class="number">24</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>；最短距离为：<span class="number">23</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>-<span class="number">-1</span>-<span class="number">-3</span>-<span class="number">-4</span>；最短距离为：<span class="number">30</span></span><br><span class="line">源点到其他各顶点最短路径为：<span class="number">5</span>；最短距离为：<span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="2-5-6-算法解析及优化拓展">2.5.6　算法解析及优化拓展</h3><h4 id="1．算法时间复杂度">1．算法时间复杂度</h4><p>（1）时间复杂度：在Dijkstra算法描述中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大，当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n= n²，算法的时间复杂度为O(n²)。</p><p>（2）空间复杂度：由以上算法可以得出，实现该算法所需要的辅助空间包含为数组flag、变量i、j、t和temp所分配的空间，因此，空间复杂度为O(n)。</p><h4 id="2．算法优化拓展-3">2．算法优化拓展</h4><p>在for语句③中，即在集合V−S中寻找距离源点u最近的顶点t，其时间复杂度为O(n)，如果我们使用优先队列，则可以把时间复杂度降为O(log n)。那么如何使用优先队列呢？</p><p>（1）优先队列（见附录C）</p><p>（2）数据结构</p><p>在上面的例子中，我们使用了一维数组dist[t]来记录源点u到顶点t的最短路径长度。在此为了操作方便，我们使用结构体的形式来实现，定义一个结构体Node，里面包含两个成员：u为顶点，step为源点到顶点u的最短路径。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         v = a;   <span class="comment">//参数传递，v为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递，step为源点到顶点v的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123; </span><br><span class="line">         <span class="keyword">return</span> step &gt; a.step; <span class="comment">//重载 &lt;，step(源点到顶点v的最短路径)最小值优先</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的结构体中除了两个成员变量外，还有一个构造函数和运算符优先级重载，下面详细介绍其含义用途。</p><p>为什么要使用构造函数？</p><p>如果不使用构造函数也是可以的，只定义一般的结构体，里面包含两个参数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> v,step; <span class="comment">// v为顶点，step为源点到顶点v的最短路径</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么在变量参数赋值时，需要这样赋值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node vs ; <span class="comment">//先定义一个Node结点类型变量</span></span><br><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>; <span class="comment">//分别对该变量的两个成员进行赋值</span></span><br></pre></td></tr></table></figure><p>采用构造函数的形式定义结构体：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u = a;   <span class="comment">//参数传递u为顶点</span></span><br><span class="line">         step = sp; <span class="comment">//参数传递step为源点到顶点u的最短路径</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>则变量参数赋值就可以直接通过参数传递：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Node <span class="title function_">vs</span><span class="params">(<span class="number">3</span>,<span class="number">5</span>)</span></span><br></pre></td></tr></table></figure><p>上面语句等价于：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vs.v =<span class="number">3</span> ,vs.step = <span class="number">5</span>;</span><br></pre></td></tr></table></figure><p>很明显通过构造函数的形式定义结构体，参数赋值更方便快捷，后面程序中会将结点压入优先队列：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 创建优先队列，最小值优先</span></span><br><span class="line">Q.push(Node(i,dist[i])); <span class="comment">//将结点Node压入优先队列Q</span></span><br><span class="line">                         <span class="comment">//参数i传递给顶点v， dist[i]传递给step</span></span><br></pre></td></tr></table></figure><p>（3）使用优先队列优化的Dijkstra算法源代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-5</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>; <span class="comment">// 城市的个数可修改</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">1e7</span>; <span class="comment">// 无穷大</span></span><br><span class="line"><span class="type">int</span> <span class="built_in">map</span>[N][N],dist[N],n,m;</span><br><span class="line"><span class="type">int</span> flag[N];</span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">Node</span>&#123;</span></span><br><span class="line">     <span class="type">int</span> u,step;</span><br><span class="line">     Node()&#123;&#125;;</span><br><span class="line">     Node(<span class="type">int</span> a,<span class="type">int</span> sp)&#123;</span><br><span class="line">         u=a;step=sp;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="type">bool</span> operator &lt; (<span class="type">const</span>  Node&amp; a)<span class="type">const</span>&#123;  <span class="comment">// 重载 &lt;</span></span><br><span class="line">          <span class="keyword">return</span> step&gt;a.step;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Dijkstra</span><span class="params">(<span class="type">int</span> st)</span>&#123;</span><br><span class="line">     <span class="built_in">priority_queue</span> &lt;Node&gt; Q;  <span class="comment">// 优先队列优化</span></span><br><span class="line">     Q.push(Node(st,<span class="number">0</span>));</span><br><span class="line">     <span class="built_in">memset</span>(flag,<span class="number">0</span>,<span class="keyword">sizeof</span>(flag));<span class="comment">//初始化flag数组为0</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">       dist[i]=INF; <span class="comment">// 初始化所有距离为，无穷大</span></span><br><span class="line">     dist[st]=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(!Q.empty())</span><br><span class="line">     &#123;</span><br><span class="line">          Node it=Q.top();<span class="comment">//优先队列队头元素为最小值</span></span><br><span class="line">          Q.pop();</span><br><span class="line">          <span class="type">int</span> t=it.u;</span><br><span class="line">          <span class="keyword">if</span>(flag[t])<span class="comment">//说明已经找到了最短距离，该结点是队列里面的重复元素</span></span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">          flag[t]=<span class="number">1</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(!flag[i]&amp;&amp;<span class="built_in">map</span>[t][i]&lt;INF)&#123; <span class="comment">// 判断与当前点有关系的点，并且自己不能到自己</span></span><br><span class="line">                  <span class="keyword">if</span>(dist[i]&gt;dist[t]+<span class="built_in">map</span>[t][i])</span><br><span class="line">                  &#123;   <span class="comment">// 求距离当前点的每个点的最短距离,进行松弛操作</span></span><br><span class="line">                      dist[i]=dist[t]+<span class="built_in">map</span>[t][i];</span><br><span class="line">                      Q.push(Node(i,dist[i]));<span class="comment">// 把更新后的最短距离压入优先队列，注意：里面的元素有重复</span></span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">          <span class="type">int</span> u,v,w,st;</span><br><span class="line">          system(<span class="string">&quot;color 0d&quot;</span>);<span class="comment">//设置背景及字体颜色</span></span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间的路线的个数：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="built_in">cin</span> &gt;&gt;m;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//初始化图的邻接矩阵</span></span><br><span class="line">             <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">             &#123;</span><br><span class="line">                 <span class="built_in">map</span>[i][j]=INF;<span class="comment">//初始化邻接矩阵为无穷大</span></span><br><span class="line">             &#125;</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入城市之间u,v的路线以及距离w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">while</span>(m--)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cin</span>&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">               <span class="built_in">map</span>[u][v]=min(<span class="built_in">map</span>[u][v],w); <span class="comment">//邻接矩阵储存，保留最小的距离</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;请输入小明所在的位置：&quot;</span>&lt;&lt;<span class="built_in">endl</span>; ;</span><br><span class="line">          <span class="built_in">cin</span>&gt;&gt;st;</span><br><span class="line">          Dijkstra(st);</span><br><span class="line">          <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明所在的位置：&quot;</span>&lt;&lt;st&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;小明:&quot;</span>&lt;&lt;st&lt;&lt;<span class="string">&quot;---&gt;&quot;</span>&lt;&lt;<span class="string">&quot;要去的位置：&quot;</span>&lt;&lt;i;</span><br><span class="line">               <span class="keyword">if</span>(dist[i]==INF)</span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sorry,无路可达&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 最短距离为：&quot;</span>&lt;&lt;dist[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">请输入城市的个数：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">请输入城市之间的路线的个数：</span><br><span class="line"><span class="number">7</span></span><br><span class="line">请输入城市之间的路线以及距离：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span> </span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">5</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line">请输入小明所在的位置：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">小明所在的位置：<span class="number">1</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">1</span> 最短距离为：<span class="number">0</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">2</span> 最短距离为：<span class="number">2</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">3</span> 最短距离为：<span class="number">3</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">4</span> 最短距离为：<span class="number">8</span></span><br><span class="line">小明：<span class="number">1</span> - 要去的位置：<span class="number">5</span> 最短距离为：<span class="number">4</span></span><br></pre></td></tr></table></figure><p>在使用优先队列的 Dijkstra 算法描述中，while (!Q.empty())语句执行的次数为n，因为要弹出n个最小值队列才会空；Q.pop()语句的时间复杂度为logn，while语句中的for语句执行n次，for语句中的Q.push (Node(i,dist[i]))时间复杂度为logn。因此，总的语句的执行次数为n* logn+n²*logn，算法的时间复杂度为O(n²logn)。</p><p>貌似时间复杂度又变大了？</p><p>这是因为我们采用的邻接矩阵存储的，如果采用邻接表存储（见附录D），那么for语句④松弛操作就不用每次执行n次，而是执行t结点的邻接边数x，每个结点的邻接边加起来为边数E，那么总的时间复杂度为O(n<em>logn+E</em>logn)，如果E≥n，则时间复杂度为O(E*logn)。</p><p><strong>注意：</strong> 优先队列中尽管有重复的结点，但重复结点最坏是n<sup class="my_markdown">2</sup>，log n<sup class="my_markdown">2</sup>=2 log n，并不改变时间复杂度的数量级。</p><p>想一想，还能不能把时间复杂度再降低呢？如果我们使用斐波那契堆，那么松弛操作的时间复杂度O(1)，总的时间复杂度为O(n* logn+E)。</p><h3 id="2-6-神秘电报密码——哈夫曼编码">2.6　神秘电报密码——哈夫曼编码</h3><p>看过谍战电影《风声》的观众都会对影片中神奇的消息传递惊叹不已！吴志国大队长在受了残忍的“针刑”之后躺在手术台上唱空城计，变了音调，把消息传给了护士，顾晓梦在衣服上缝补了长短不一的针脚……那么，片中无处不在的摩尔斯码到底是什么？它又有着怎样的神秘力量呢？</p><p>摩尔斯电码（Morse code）由点dot（. ）、划dash（-）两种符号组成。它的基本原理是：把英文字母表中的字母、标点符号和空格按照出现的频率排序，然后用点和划的组合来代表这些字母、标点符号和空格，使频率最高的符号具有最短的点划组合。</p><p><img src="https://source.drie.cn/qxsf-images/60.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-30　神秘电报密码</b></center><h3 id="2-6-1-问题分析">2.6.1　问题分析</h3><p>我们先看一个生活中的例子：</p><p>有一群退休的老教授聚会，其中一个老教授带着刚会说话的漂亮小孙女，于是大家逗她：“你能猜猜我们多大了吗？猜对了有糖吃哦！”小女孩就开始猜：“你是1岁了吗？”，老教授摇摇头。“你是两岁了吗？”，老教授仍然摇摇头。“那一定是3岁了！”……大家哈哈大笑。或许我们都感觉到了小女孩的天真可爱，然而生活中的确有很多类似这样的判断。</p><p>曾经有这样一个C++设计题目：将一个班级的成绩从百分制转为等级制。一同学设计的程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">70</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">80</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>在上面程序中，如果分数小于60，我们做1次判定即可；如果分数为60～70，需要判定2次；如果分数为70～80，需要判定3次；如果分数为80～90，需要判定4次；如果分数为90～100，需要判定5次。</p><p>这段程序貌似是没有任何问题，但是我们却犯了从1岁开始判断一个老教授年龄的错误，因为我们的考试成绩往往是呈正态分布的，如图2-31所示。</p><p><img src="https://source.drie.cn/qxsf-images/61.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-31　运行结果</b></center><p>也就是说，大多数（70%）人的成绩要判断3次或3次以上才能成功，假设班级人数为100人，则判定次数为：</p><p>100×10%×1+100×20%×2+100×40%×3+100×20%×4+100×10%×5=300（次）</p><p>如果我们改写程序为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(score &lt;<span class="number">80</span>) </span><br><span class="line">   <span class="keyword">if</span> (score &lt;<span class="number">70</span>) </span><br><span class="line">       <span class="keyword">if</span> (score &lt;<span class="number">60</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;及格&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;中等&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (score &lt;<span class="number">90</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;良好&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">   <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;优秀&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>则判定次数为：</p><p>100×10%×3+100×20%×3+100×40%×2+100×20%×2+100×10%×2=230（次）</p><p>为什么会有这样大的差别呢？我们来看两种判断方式的树形图，如图2-32所示。</p><p><img src="https://source.drie.cn/qxsf-images/62.jpg" alt="code"><br><img src="https://source.drie.cn/qxsf-images/63.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-32　两种判断方式的树形图</b></center><p>从图2-32中我们可以看到，当频率高的分数越靠近树根（先判断）时，我们只用1次猜中的可能性越大。</p><p>再看五笔字型的编码方式：</p><p>我们在学习五笔时，需要背一级简码。所谓一级简码，就是指25个汉字，对应着25个按键，打1个字母键再加1个空格键就可打出来相应的字。为什么要这样设置呢？因为根据文字统计，这25个汉字是使用频率最高的。</p><p>五笔字根之一级简码：</p><p>G 一　F 地　D 在　 S 要　 A 工</p><p>H 上　J 是　K 中　 L 国　 M 同</p><p>T 和　R 的　E 有　 W 人　Q 我</p><p>Y 主　U 产　I 不　 O 为　 P 这</p><p>N 民　B 了　V 发　C 以　 X 经</p><p>通常的编码方法有固定长度编码和不等长度编码两种。这是一个设计最优编码方案的问题，目的是使总码长度最短。这个问题利用字符的使用频率来编码，是不等长编码方法，使得经常使用的字符编码较短，不常使用的字符编码较长。如果采用等长的编码方案，假设所有字符的编码都等长，则表示n个不同的字符需要<img class="my_markdown" src="https://source.drie.cn/qxsf-images/64.gif" style="width:47px;  height: 19px; "/>位。例如，3个不同的字符a、b、c，至少需要2位二进制数表示，a为00，b为01，c为10。如果每个字符的使用频率相等，固定长度编码是空间效率最高的方法。</p><p>不等长编码方法需要解决两个关键问题：</p><p>（1）编码尽可能短</p><p>我们可以让使用频率高的字符编码较短，使用频率低的编码较长，这种方法可以提高压缩率，节省空间，也能提高运算和通信速度。即 <strong>频率越高，编码越短</strong> 。</p><p>（2）不能有二义性</p><p>例如，ABCD四个字符如果编码如下。</p><p>A：0。B：1。C：01。D：10。</p><p>那么现在有一列数0110，该怎样翻译呢？是翻译为ABBA，ABD，CBA，还是CD？那么如何消除二义性呢？解决的办法是：任何一个字符的编码不能是另一个字符编码的前缀，即 <strong>前缀码特性</strong> 。</p><p>1952年，数学家D.A.Huffman提出了根据字符在文件中出现的频率，用0、1的数字串表示各字符的最佳编码方式，称为哈夫曼（Huffman）编码。哈夫曼编码很好地解决了上述两个关键问题，被广泛应用于数据压缩，尤其是远距离通信和大容量数据存储方面，常用的JPEG图片就是采用哈夫曼编码压缩的。</p><h3 id="2-6-2-算法设计">2.6.2　算法设计</h3><p>哈夫曼编码的基本思想是以字符的使用频率作为权构建一棵哈夫曼树，然后利用哈夫曼树对字符进行编码。构造一棵哈夫曼树，是将所要编码的字符作为叶子结点，该字符在文件中的使用频率作为叶子结点的权值，以自底向上的方式，通过n−1次的“合并”运算后构造出的一棵树，核心思想是权值越大的叶子离根越近。</p><p>哈夫曼算法采取的 <strong>贪心策略是每次从树的集合中取出没有双亲且权值最小的两棵树作为左右子树</strong> ，构造一棵新树，新树根节点的权值为其左右孩子结点权值之和，将新树插入到树的集合中，求解步骤如下。</p><p>（1）确定合适的数据结构。编写程序前需要考虑的情况有：</p><ul><li>哈夫曼树中没有度为1的结点，则一棵有n个叶子结点的哈夫曼树共有2n−1个结点（n−1次的“合并”，每次产生一个新结点），</li><li>构成哈夫曼树后，为求编码，需从叶子结点出发走一条从叶子到根的路径。</li><li>译码需要从根出发走一条从根到叶子的路径，那么我们需要知道每个结点的权值、双亲、左孩子、右孩子和结点的信息。</li></ul><p>（2）初始化。构造n棵结点为n个字符的单结点树集合T={t<sub class="my_markdown">1</sub>，t<sub>2</sub>，t<sub>3</sub>，…，t<sub class="my_markdown">n</sub>}，每棵树只有一个带权的根结点，权值为该字符的使用频率。</p><p>（3）如果T中只剩下一棵树，则哈夫曼树构造成功，跳到步骤（6）。否则，从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左孩子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p><p>（4）从集合T中删去t<sub class="my_markdown">i</sub>，t<sub class="my_markdown">j</sub>，加入z<sub class="my_markdown">k</sub>。</p><p>（5）重复以上（3）～（4）步。</p><p>（6）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码。算法结束。</p><h3 id="2-6-3-完美图解">2.6.3　完美图解</h3><p>假设我们现在有一些字符和它们的使用频率（见表2-13），如何得到它们的哈夫曼编码呢？</p><center class="my_markdown"><b class="my_markdown">表2-13　字符频率</b></center><p>| 字符 | a | b | c | d | e | f |<br>| :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  | :-----  |<br>| 频率 | 0.05 | 0.32 | 0.18 | 0.07 | 0.25 | 0.13 |</p><p>我们可以把每一个字符作为叶子，它们对应的频率作为其权值，为了比较大小方便，可以对其同时扩大100倍，得到a～f分别对应5、32、18、7、25、13。</p><p>（1）初始化。构造n棵结点为n个字符的单结点树集合T={a，b，c，d，e，f}，如图2-33所示。</p><p><img src="https://source.drie.cn/qxsf-images/65.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-33　叶子结点</b></center><p>（2）从集合T中取出没有双亲的且权值最小的两棵树a和d，将它们合并成一棵新树t<sub class="my_markdown">1</sub>，新树的左孩子为a，右孩子为d，新树的权值为a和d的权值之和为12。新树的树根t<sub class="my_markdown">1</sub>加入集合T，a和d从集合T中删除，如图2-34所示。</p><p><img src="https://source.drie.cn/qxsf-images/66.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-34　构建新树</b></center><p>（3）从集合T中取出没有双亲的且权值最小的两棵树t<sub class="my_markdown">1</sub>和f，将它们合并成一棵新树t<sub>2</sub>，新树的左孩子为t<sub class="my_markdown">1</sub>，右孩子为f，新树的权值为t<sub class="my_markdown">1</sub>和f的权值之和为25。新树的树根t<sub>2</sub>加入集合T，将t<sub class="my_markdown">1</sub>和f从集合T中删除，如图2-35所示。</p><p><img src="https://source.drie.cn/qxsf-images/67.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-35　构建新树</b></center><p>（4）从集合T中取出没有双亲且权值最小的两棵树c和e，将它们合并成一棵新树t<sub class="my_markdown">3</sub>，新树的左孩子为c，右孩子为e，新树的权值为c和e的权值之和为43。新树的树根t<sub class="my_markdown">3</sub>加入集合T，将c和e从集合T中删除，如图2-36所示。</p><p><img src="https://source.drie.cn/qxsf-images/68.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-36　构建新树</b></center><p>（5）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">2</sub>和b，将它们合并成一棵新树t<sub>4</sub>，新树的左孩子为t<sub class="my_markdown">2</sub>，右孩子为b，新树的权值为t<sub class="my_markdown">2</sub>和b的权值之和为57。新树的树根t<sub>4</sub>加入集合T，将t<sub class="my_markdown">2</sub>和b从集合T中删除，如图2-37所示。</p><p><img src="https://source.drie.cn/qxsf-images/69.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-37　构建新树</b></center><p>（6）从集合T中取出没有双亲且权值最小的两棵树t<sub class="my_markdown">3</sub>和t<sub>4</sub>，将它们合并成一棵新树t<sub>5</sub>，新树的左孩子为t<sub>4</sub>，右孩子为t<sub class="my_markdown">3</sub>，新树的权值为t<sub class="my_markdown">3</sub>和t<sub>4</sub>的权值之和为 100。新树的树根t<sub>5</sub>加入集合T，将t<sub class="my_markdown">3</sub>和t<sub>4</sub>从集合T中删除，如图 2-38所示。</p><p><img src="https://source.drie.cn/qxsf-images/70.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-38　哈夫曼树</b></center><p>（7）T中只剩下一棵树，哈夫曼树构造成功。</p><p>（8）约定左分支上的编码为“0”，右分支上的编码为“1”。从叶子结点到根结点逆向求出每个字符的哈夫曼编码，从根结点到叶子结点路径上的字符组成的字符串为该叶子结点的哈夫曼编码，如图2-39所示。</p><p><img src="https://source.drie.cn/qxsf-images/71.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-39　哈夫曼编码</b></center><h3 id="2-6-4-伪代码详解">2.6.4　伪代码详解</h3><p>在构造哈夫曼树的过程中，首先给每个结点的双亲、左孩子、右孩子初始化为−1，找出所有结点中双亲为−1、权值最小的两个结点t<sub class="my_markdown">1</sub>、t<sub>2</sub>，并合并为一棵二叉树，更新信息（双亲结点的权值为t<sub class="my_markdown">1</sub>、t<sub>2</sub>权值之和，其左孩子为权值最小的结点t<sub class="my_markdown">1</sub>，右孩子为次小的结点t<sub>2</sub>，t<sub class="my_markdown">1</sub>、t<sub>2</sub>的双亲为双亲结点的编号）。重复此过程，构造一棵哈夫曼树。</p><p>（1）数据结构</p><p>每个结点的结构包括权值、双亲、左孩子、右孩子、结点字符信息这 5 个域。如图 2-40所示，定义为结构体形式，定义结点结构体HnodeType：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">double</span> weight; <span class="comment">//权值</span></span><br><span class="line">     <span class="type">int</span> parent;  <span class="comment">//双亲</span></span><br><span class="line">     <span class="type">int</span> lchild;  <span class="comment">//左孩子</span></span><br><span class="line">     <span class="type">int</span> rchild;  <span class="comment">//右孩子</span></span><br><span class="line">     <span class="type">char</span> value; <span class="comment">//该节点表示的字符</span></span><br><span class="line">&#125; HNodeType;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/72.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-40　结点结构体</b></center><p>在编码结构体中，bit[]存放结点的编码，start 记录编码开始下标，逆向译码（从叶子到根，想一想为什么不从根到叶子呢？）。存储时，start从n−1开始依次递减，从后向前存储；读取时，从start+1开始到n−1，从前向后输出，即为该字符的编码。如图2-41所示。</p><p><img src="https://source.drie.cn/qxsf-images/73.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-41　编码数组</b></center><p>编码结构体HcodeType：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">int</span> bit[MAXBIT]; <span class="comment">//存储编码的数组</span></span><br><span class="line">     <span class="type">int</span> start;       <span class="comment">//编码开始下标</span></span><br><span class="line">&#125; HCodeType;          <span class="comment">/* 编码结构体 */</span></span><br></pre></td></tr></table></figure><p>（2）初始化</p><p>初始化存放哈夫曼树数组HuffNode[]中的结点（见表2-14）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">     HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">     HuffNode[i].parent =<span class="number">-1</span>; <span class="comment">//双亲</span></span><br><span class="line">     HuffNode[i].lchild =<span class="number">-1</span>; <span class="comment">//左孩子</span></span><br><span class="line">     HuffNode[i].rchild =<span class="number">-1</span>; <span class="comment">//右孩子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><center class="my_markdown"><b class="my_markdown">表2-14　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/74.jpg" alt="code"><br>输入n个叶子结点的字符及权值：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">     <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）循环构造Huffman树</p><p>从集合T中取出双亲为−1且权值最小的两棵树t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>，将它们合并成一棵新树z<sub class="my_markdown">k</sub>，新树的左儿子为t<sub class="my_markdown">i</sub>，右孩子为t<sub class="my_markdown">j</sub>，z<sub class="my_markdown">k</sub>的权值为t<sub class="my_markdown">i</sub>和t<sub class="my_markdown">j</sub>的权值之和。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span> i, j, x1, x2; <span class="comment">//x1、x2为两个最小权值结点的序号。</span></span><br><span class="line">    <span class="type">double</span> m1,m2; <span class="comment">//m1、m2为两个最小权值结点的权值。</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">         m1=m2=MAXVALUE;  <span class="comment">//初始化为最大值</span></span><br><span class="line">         x1=x2=<span class="number">-1</span>;  <span class="comment">//初始化为-1</span></span><br><span class="line">         <span class="comment">//找出所有结点中权值最小、无双亲结点的两个结点</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)&#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2 = m1;</span><br><span class="line">                   x2 = x1;</span><br><span class="line">                   m1 = HuffNode[j].weight;</span><br><span class="line">                   x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)&#123;</span><br><span class="line">                   m2=HuffNode[j].weight;</span><br><span class="line">                   x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 更新新树信息 */</span></span><br><span class="line">         HuffNode[x1].parent = n+i; <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[x2].parent = n+i; <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">         HuffNode[n+i].weight =m1+m2; <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">         HuffNode[n+i].lchild = x1; <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">         HuffNode[n+i].rchild = x2; <span class="comment">//新结点n+i的右孩子为x2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：</p><p>（1）i=0时，j=0；j&lt;6；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">0</span>   x2=<span class="number">3</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">5</span>  m2=<span class="number">7</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">0</span>].parent = <span class="number">6</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">3</span>].parent = <span class="number">6</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].weight =<span class="number">12</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">6</span>].lchild = <span class="number">0</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">6</span>].rchild = <span class="number">3</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-15所示。</p><center class="my_markdown"><b class="my_markdown">表2-15　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/75.jpg" alt="code"><br>对应的哈夫曼树如图2-42所示。</p><p><img src="https://source.drie.cn/qxsf-images/76.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-42　哈夫曼树生成过程</b></center><p>（2）i=1时，j=0；j&lt;7；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">6</span>    x2=<span class="number">5</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">12</span>  m2=<span class="number">13</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">5</span>].parent = <span class="number">7</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">6</span>].parent = <span class="number">7</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">7</span>].weight =<span class="number">25</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">7</span>].lchild = <span class="number">6</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">7</span>].rchild = <span class="number">5</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-16所示。</p><center class="my_markdown"><b class="my_markdown">表2-16　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/77.jpg" alt="code"><br>对应的哈夫曼树如图2-43所示。</p><p><img src="https://source.drie.cn/qxsf-images/78.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-43　哈夫曼树生成过程</b></center><p>（3）i=2时，j=0；j&lt;8；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">2</span>    x2=<span class="number">4</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">18</span>  m2=<span class="number">25</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">2</span>].parent = <span class="number">8</span>;   <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">4</span>].parent = <span class="number">8</span>;   <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">43</span>;   <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">2</span>;   <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">4</span>;   <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-17所示。</p><center class="my_markdown"><b class="my_markdown">表2-17　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/79.jpg" alt="code"><br>对应的哈夫曼树如图2-44所示。</p><p><img src="https://source.drie.cn/qxsf-images/80.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-44　哈夫曼树生成过程</b></center><p>（4）i=3时，j=0；j&lt;9；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">7</span>    x2=<span class="number">1</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">25</span>  m2=<span class="number">32</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">7</span>].parent = <span class="number">9</span>;    <span class="comment">//x1的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">1</span>].parent = <span class="number">9</span>;     <span class="comment">//x2的父亲为新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">8</span>].weight =<span class="number">57</span>;     <span class="comment">//新结点权值为两个最小权值之和m1+m2</span></span><br><span class="line">HuffNode[<span class="number">8</span>].lchild = <span class="number">7</span>;     <span class="comment">//新结点n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">8</span>].rchild = <span class="number">1</span>;     <span class="comment">//新结点n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-18所示。</p><center class="my_markdown"><b class="my_markdown">表2-18　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/81.jpg" alt="code"><br>对应的哈夫曼树如图2-45所示。</p><p><img src="https://source.drie.cn/qxsf-images/82.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-45　哈夫曼树生成过程</b></center><p>（5）i=4时，j=0；j&lt;10；找双亲为−1，权值最小的两个数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x1=<span class="number">8</span>    x2=<span class="number">9</span>；<span class="comment">//x1、x2为两个最小权值结点的序号</span></span><br><span class="line">m1=<span class="number">43</span>  m2=<span class="number">57</span>；<span class="comment">//m1、m2为两个最小权值结点的权值</span></span><br><span class="line">HuffNode[<span class="number">8</span>].parent = <span class="number">10</span>;  <span class="comment">//x1的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">9</span>].parent =<span class="number">10</span>;   <span class="comment">//x2的父亲为生成的新结点编号n+i</span></span><br><span class="line">HuffNode[<span class="number">10</span>].weight =<span class="number">100</span>;  <span class="comment">//新结点权值为两个最小权值之和m1+ m2</span></span><br><span class="line">HuffNode[<span class="number">10</span>].lchild = <span class="number">8</span>; <span class="comment">//新结点编号n+i的左孩子为x1 </span></span><br><span class="line">HuffNode[<span class="number">10</span>].rchild = <span class="number">9</span>; <span class="comment">//新结点编号n+i的右孩子为x2</span></span><br></pre></td></tr></table></figure><p>数据更新后如表2-19所示。</p><center class="my_markdown"><b class="my_markdown">表2-19　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/83.jpg" alt="code"><br>对应的哈夫曼树如图2-46所示。</p><p><img src="https://source.drie.cn/qxsf-images/84.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-46　哈夫曼树生成过程</b></center><p>（6）输出哈夫曼编码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">   &#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)&#123;</span><br><span class="line">          cd.start = n<span class="number">-1</span>;</span><br><span class="line">          c = i;  <span class="comment">//i为叶子结点编号</span></span><br><span class="line">          p = HuffNode[c].parent;</span><br><span class="line">          <span class="keyword">while</span>(p != <span class="number">-1</span>)&#123;</span><br><span class="line">              <span class="keyword">if</span>(HuffNode[p].lchild == c)&#123;</span><br><span class="line">                  cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                  cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">              cd.start--;         <span class="comment">/* start向前移动一位 */</span></span><br><span class="line">              c = p;              <span class="comment">/* c,p变量上移，准备下一循环 */</span></span><br><span class="line">              p = HuffNode[c].parent;    </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">          <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">              HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">          HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图解：哈夫曼编码数组如图2-47所示。</p><p><img src="https://source.drie.cn/qxsf-images/85.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-47　哈夫曼编码数组</b></center><p>（1）i=0时，c=0；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd.start = n<span class="number">-1</span>=<span class="number">5</span>;</span><br><span class="line">p = HuffNode[<span class="number">0</span>].parent=<span class="number">6</span>;<span class="comment">//从哈夫曼树建成后的表HuffNode[]中读出</span></span><br><span class="line">                         <span class="comment">//p指向0号结点的父亲6号</span></span><br></pre></td></tr></table></figure><p>构建完成的哈夫曼树数组如表2-20所示。</p><center class="my_markdown"><b class="my_markdown">表2-20　哈夫曼树构建数组</b></center><p><img src="https://source.drie.cn/qxsf-images/86.jpg" alt="code"><br>如果p != −1，那么从表HuffNode[]中读出6号结点的左孩子和右孩子，判断0号结点是它的左孩子还是右孩子，如果是左孩子编码为0；如果是右孩子编码为1。</p><p>从表2-20可以看出：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HuffNode[<span class="number">6</span>].lchild=<span class="number">0</span>;<span class="comment">//0号结点是其父亲6号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">5</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">4</span>; <span class="comment">/* start向前移动一位*/</span></span><br></pre></td></tr></table></figure><p>哈夫曼编码树如图2-48所示，哈夫曼编码数组如图2-49所示。</p><p><img src="https://source.drie.cn/qxsf-images/87.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-48　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/88.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-49　哈夫曼编码数组</b></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c = p=<span class="number">6</span>;                      <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">6</span>].parent=<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>c、p变量上移后如图2-50所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">7</span>].lchild=<span class="number">6</span>;<span class="comment">//6号结点是其父亲7号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">4</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">3</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">7</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">7</span>].parent=<span class="number">9</span>;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/89.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-50　哈夫曼编码树</b></center><p>哈夫曼编码树如图2-51所示，哈夫曼编码数组如图2-52所示。</p><p><img src="https://source.drie.cn/qxsf-images/90.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-51　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/91.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-52　哈夫曼编码数组</b></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">9</span>].lchild=<span class="number">7</span>;<span class="comment">//7号结点是其父亲9号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">3</span>] = <span class="number">0</span>;<span class="comment">//编码为0</span></span><br><span class="line">cd.start--=<span class="number">2</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">9</span>;             <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">9</span>].parent=<span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>哈夫曼编码树如图2-53所示，哈夫曼编码数组如图2-54所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p != <span class="number">-1</span>;</span><br><span class="line">HuffNode[<span class="number">10</span>].lchild!=<span class="number">9</span>;<span class="comment">//9号结点不是其父亲10号的左孩子</span></span><br><span class="line">cd.bit[<span class="number">2</span>] = <span class="number">1</span>;<span class="comment">//编码为1</span></span><br><span class="line">cd.start--=<span class="number">1</span>;        <span class="comment">/* start向前移动一位*/</span></span><br><span class="line">c = p=<span class="number">10</span>;            <span class="comment">/* c、p变量上移，准备下一循环 */</span></span><br><span class="line">p = HuffNode[<span class="number">10</span>].parent=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/92.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-53　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/93.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-54　哈夫曼编码数组</b></center><p>哈夫曼编码树如图2-55所示，哈夫曼编码数组如图2-56所示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = <span class="number">-1</span>;该叶子结点编码结束。</span><br><span class="line"><span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">   <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">        HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">   HuffCode[i].start = cd.start;</span><br></pre></td></tr></table></figure><p><img src="https://source.drie.cn/qxsf-images/94.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-55　哈夫曼编码树</b></center><p><img src="https://source.drie.cn/qxsf-images/95.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-56　哈夫曼编码数组</b></center><p>HuffCode[]数组如图2-57所示。</p><p><img src="https://source.drie.cn/qxsf-images/96.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-57　哈夫曼编码HuffCode[]数组</b></center><p>注意：图中的箭头不表示指针。</p><h3 id="2-6-5-实战演练">2.6.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-6</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXBIT    100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXVALUE  10000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXLEAF   30</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXNODE   MAXLEAF*2 -1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">double</span> weight;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">    <span class="type">int</span> lchild;</span><br><span class="line">    <span class="type">int</span> rchild;</span><br><span class="line">    <span class="type">char</span> value;</span><br><span class="line">&#125; HNodeType;        <span class="comment">/* 结点结构体 */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> bit[MAXBIT];</span><br><span class="line">    <span class="type">int</span> start;</span><br><span class="line">&#125; HCodeType;        <span class="comment">/* 编码结构体 */</span></span><br><span class="line">HNodeType HuffNode[MAXNODE]; <span class="comment">/* 定义一个结点结构体数组 */</span></span><br><span class="line">HCodeType HuffCode[MAXLEAF];<span class="comment">/* 定义一个编码结构体数组*/</span></span><br><span class="line"><span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanTree</span> <span class="params">(HNodeType HuffNode[MAXNODE],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* i、j： 循环变量，m1、m2：构造哈夫曼树不同过程中两个最小权值结点的权值，</span></span><br><span class="line"><span class="comment">       x1、x2：构造哈夫曼树不同过程中两个最小权值结点在数组中的序号。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">int</span> i, j, x1, x2;</span><br><span class="line">    <span class="type">double</span> m1,m2;</span><br><span class="line">    <span class="comment">/* 初始化存放哈夫曼树数组 HuffNode[] 中的结点 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">2</span>*n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         HuffNode[i].weight = <span class="number">0</span>;<span class="comment">//权值</span></span><br><span class="line">         HuffNode[i].parent =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].lchild =<span class="number">-1</span>;</span><br><span class="line">         HuffNode[i].rchild =<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 输入 n 个叶子结点的权值 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input value and weight of leaf node &quot;</span>&lt;&lt;i + <span class="number">1</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">         <span class="built_in">cin</span>&gt;&gt;HuffNode[i].value&gt;&gt;HuffNode[i].weight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 构造 Huffman 树 */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n<span class="number">-1</span>; i++)</span><br><span class="line">    &#123;<span class="comment">//执行n-1次合并</span></span><br><span class="line">         m1=m2=MAXVALUE;</span><br><span class="line">         <span class="comment">/* m1、m2中存放两个无父结点且结点权值最小的两个结点 */</span></span><br><span class="line">         x1=x2=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">/* 找出所有结点中权值最小、无父结点的两个结点，并合并之为一棵二叉树 */</span></span><br><span class="line">         <span class="keyword">for</span> (j=<span class="number">0</span>; j&lt;n+i; j++)</span><br><span class="line">         &#123;</span><br><span class="line">              <span class="keyword">if</span> (HuffNode[j].weight &lt; m1 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2 = m1;</span><br><span class="line">                  x2 = x1;</span><br><span class="line">                  m1 = HuffNode[j].weight;</span><br><span class="line">                  x1 = j;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span> <span class="keyword">if</span> (HuffNode[j].weight &lt; m2 &amp;&amp; HuffNode[j].parent==<span class="number">-1</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  m2=HuffNode[j].weight;</span><br><span class="line">                  x2=j;</span><br><span class="line">              &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/* 设置找到的两个子结点 x1、x2 的父结点信息 */</span></span><br><span class="line">         HuffNode[x1].parent  = n+i;</span><br><span class="line">         HuffNode[x2].parent  = n+i;</span><br><span class="line">         HuffNode[n+i].weight = m1+m2;</span><br><span class="line">         HuffNode[n+i].lchild = x1;</span><br><span class="line">         HuffNode[n+i].rchild = x2;</span><br><span class="line">         <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;x1.weight and x2.weight in round &quot;</span>&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x1]. weight&lt;&lt;<span class="string">&quot;\t&quot;</span>&lt;&lt;HuffNode[x2].weight&lt;&lt;<span class="built_in">endl</span>; <span class="comment">/* 用于测试 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HuffmanCode</span><span class="params">(HCodeType HuffCode[MAXLEAF],  <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    HCodeType cd;       <span class="comment">/* 定义一个临时变量来存放求解编码时的信息 */</span></span><br><span class="line">    <span class="type">int</span> i,j,c,p;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cd.start = n<span class="number">-1</span>;</span><br><span class="line">        c = i;</span><br><span class="line">        p = HuffNode[c].parent;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(HuffNode[p].lchild == c)</span><br><span class="line">                cd.bit[cd.start] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cd.bit[cd.start] = <span class="number">1</span>;</span><br><span class="line">            cd.start--;        <span class="comment">/* 求编码的低一位 */</span></span><br><span class="line">            c = p;</span><br><span class="line">            p = HuffNode[c].parent;    <span class="comment">/* 设置下一循环条件 */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* 把叶子结点的编码信息从临时编码cd中复制出来，放入编码结构体数组 */</span></span><br><span class="line">        <span class="keyword">for</span> (j=cd.start+<span class="number">1</span>; j&lt;n; j++)</span><br><span class="line">           HuffCode[i].bit[j] = cd.bit[j];</span><br><span class="line">        HuffCode[i].start = cd.start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,n;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Please input n：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line">    HuffmanTree (HuffNode, n);  <span class="comment">/* 构造哈夫曼树 */</span></span><br><span class="line">    HuffmanCode(HuffCode, n);  <span class="comment">/* 哈夫曼树编码 */</span></span><br><span class="line">    <span class="comment">/* 输出已保存好的所有存在编码的哈夫曼编码 */</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;HuffNode[i].value&lt;&lt;<span class="string">&quot;: Huffman code is: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=HuffCode[i].start+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;HuffCode[i].bit[j];</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Please input n：</span><br><span class="line"><span class="number">6</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">1</span></span><br><span class="line">a <span class="number">0.05</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">2</span></span><br><span class="line">b <span class="number">0.32</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">3</span></span><br><span class="line">c <span class="number">0.18</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">4</span></span><br><span class="line">d <span class="number">0.07</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">5</span></span><br><span class="line">e <span class="number">0.25</span></span><br><span class="line">Please input value and weight of leaf node <span class="number">6</span></span><br><span class="line">f <span class="number">0.13</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x1.weight and x2.weight in round <span class="number">1</span>      <span class="number">0.05</span>    <span class="number">0.07</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">2</span>      <span class="number">0.12</span>    <span class="number">0.13</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">3</span>      <span class="number">0.18</span>    <span class="number">0.25</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">4</span>      <span class="number">0.25</span>    <span class="number">0.32</span></span><br><span class="line">x1.weight and x2.weight in round <span class="number">5</span>      <span class="number">0.43</span>    <span class="number">0.57</span></span><br><span class="line">a: Huffman code is: <span class="number">1000</span></span><br><span class="line">b: Huffman code is: <span class="number">11</span></span><br><span class="line">c: Huffman code is: <span class="number">00</span></span><br><span class="line">d: Huffman code is: <span class="number">1001</span></span><br><span class="line">e: Huffman code is: <span class="number">01</span></span><br><span class="line">f: Huffman code is: <span class="number">101</span></span><br></pre></td></tr></table></figure><h3 id="2-6-6-算法解析及优化拓展">2.6.6　算法解析及优化拓展</h3><h4 id="1．算法复杂度分析-4">1．算法复杂度分析</h4><p>（1）时间复杂度：由程序可以看出，在函数HuffmanTree()中，if (HuffNode[j].weight&lt;m1&amp;&amp; HuffNode[j].parent==−1)为基本语句，外层i与j组成双层循环：</p><p>i=0时，该语句执行n次；</p><p>i=1时，该语句执行n+1次；</p><p>i=2时，该语句执行n+2次；</p><p>……</p><p>i=n−2时，该语句执行n+n−2次；</p><p>则基本语句共执行n+（n+1）+（n+2）+…+（n+（n−2））=（n−1）*（3n−2）/2次（等差数列）；在函数HuffmanCode()中，编码和输出编码时间复杂度都接近n<sup class="my_markdown">2</sup>；则该算法时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：所需存储空间为结点结构体数组与编码结构体数组，哈夫曼树数组 HuffNode[]中的结点为n个，每个结点包含bit[MAXBIT]和start两个域，则该算法空间复杂度为O( n* MAXBIT)。</p><h4 id="2．算法优化拓展-4">2．算法优化拓展</h4><p>该算法可以从两个方面优化：</p><p>（1）函数HuffmanTree()中找两个权值最小结点时使用优先队列，时间复杂度为logn，执行n−1次，总时间复杂度为O( n logn)。</p><p>（2）函数HuffmanCode()中，哈夫曼编码数组HuffNode[]中可以定义一个动态分配空间的线性表来存储编码，每个线性表的长度为实际的编码长度，这样可以大大节省空间。</p><h3 id="2-7-沟通无限校园网——最小生成树">2.7　沟通无限校园网——最小生成树</h3><p>校园网是为学校师生提供资源共享、信息交流和协同工作的计算机网络。校园网是一个宽带、具有交互功能和专业性很强的局域网络。如果一所学校包括多个学院及部门，也可以形成多个局域网络，并通过有线或无线方式连接起来。原来的网络系统只局限于以学院、图书馆为单位的局域网，不能形成集中管理以及各种资源的共享，个别学院还远离大学本部，这些情况严重地阻碍了整个学校的网络化需求。现在需要设计网络电缆布线，将各个单位的局域网络连通起来，如何设计能够使费用最少呢？</p><p><img src="https://source.drie.cn/qxsf-images/97.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-58　校园网络</b></center><h3 id="2-7-1-问题分析">2.7.1　问题分析</h3><p>某学校下设10个学院，3个研究所，1个大型图书馆，4个实验室。其中，1～10号节点代表10个学院，11～13号节点代表3个研究所，14号节点代表图书馆，15～18号节点代表4个实验室。该问题用无向连通图<strong>G</strong> =（V，E）来表示通信网络，V表示顶点集，E表示边集。把各个单位抽象为图中的顶点，顶点与顶点之间的边表示单位之间的通信网络，边的权值表示布线的费用。如果两个节点之间没有连线，代表这两个单位之间不能布线，费用为无穷大。如图2-59所示。</p><p><img src="https://source.drie.cn/qxsf-images/98.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-59　校园网连通图</b></center><p>那么我们如何设计网络电缆布线，将各个单位连通起来，并且费用最少呢？</p><p>对于n个顶点的连通图，只需n−1条边就可以使这个图连通，n−1条边要想保证图连通，就必须不含回路，所以我们只需要找出n−1条权值最小且无回路的边即可。</p><p>需要说明几个概念。</p><p>（1）子图：从原图中选中一些顶点和边组成的图，称为原图的子图。</p><p>（2）生成子图：选中一些边和所有顶点组成的图，称为原图的生成子图。</p><p>（3）生成树：如果生成子图恰好是一棵树，则称为生成树。</p><p>（4）最小生成树：权值之和最小的生成树，则称为最小生成树。</p><p>本题就是最小生成树求解问题。</p><h3 id="2-7-2-算法设计">2.7.2　算法设计</h3><p>找出n−1条权值最小的边很容易，那么怎么保证无回路呢?</p><p>如果在一个图中深度搜索或广度搜索有没有回路，是一件繁重的工作。有一个很好的办法—— <strong>避圈法</strong> 。在生成树的过程中，我们把已经在生成树中的结点看作一个集合，把剩下的结点看作另一个集合，从连接两个集合的边中选择一条权值最小的边即可。</p><p>首先任选一个结点，例如1号结点，把它放在集合U中，U={1}，那么剩下的结点即V−U={2，3，4，5，6，7}，V是图的所有顶点集合。如图2-60所示。</p><p><img src="https://source.drie.cn/qxsf-images/99.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-60　最小生成树求解过程</b></center><p>现在只需在连接两个集合（V和V−U）的边中看哪一条边权值最小，把权值最小的边关联的结点加入到集合U。从图2-68可以看出，连接两个集合的3条边中，结点1到结点2的边权值最小，选中此条边，把2号结点加入U集合U={1，2}，V−U={3，4，5，6，7}。</p><p>再从连接两个集合（V和V−U）的边中选择一条权值最小的边。从图2-61可以看出，连接两个集合的4条边中，结点2到结点7的边权值最小，选中此条边，把7号结点加入U集合U={1，2，7}，V−U={3，4，5，6}。</p><p><img src="https://source.drie.cn/qxsf-images/100.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-61　最小生成树求解过程</b></center><p>如此下去，直到U=V结束，选中的边和所有的结点组成的图就是最小生成树。</p><p>是不是非常简单啊？</p><p>这就是Prim算法，1957年由美国计算机科学家Robert C.Prim发现的。那么如何用算法来实现呢？</p><p>首先，令U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，TE={}。u<sub class="my_markdown">0</sub>可以是任何一个结点，因为最小生成树包含所有结点，所以从哪个结点出发都可以得到最小生成树，不影响最终结果。TE为选中的边集。</p><p>然后，做如下 <strong>贪心选择</strong> ：选取连接U和V−U的所有边中的最短边，即满足条件i∈U，j∈V−U，且边（i，j）是连接U和V−U的所有边中的最短边，即该边的权值最小。</p><p>然后，将顶点j加入集合U，边（i，j）加入TE。继续上面的贪心选择一直进行到U=V为止，此时，选取到的所有边恰好构成图<strong>G</strong>的一棵最小生成树T。</p><p>算法设计及步骤如下。</p><p>步骤1：确定合适的数据结构。设置带权邻接矩阵<strong>C</strong>存储图<strong>G</strong>，如果图<strong>G</strong>中存在边（u，x），令<strong>C</strong>[u][x]等于边（u，x）上的权值，否则，<strong>C</strong>[u][x]=∞；bool数组s[]，如果s[i]=true，说明顶点i已加入集合U。</p><p>如图2-62所示，直观地看图很容易找出 U 集合到 V−U集合的边中哪条边是最小的，但是程序中如果穷举这些边，再找最小值就太麻烦了，那怎么办呢？</p><p><img src="https://source.drie.cn/qxsf-images/101.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-62　最小生成树求解过程</b></center><p>可以通过设置两个数组巧妙地解决这个问题，closest[j]表示V−U中的顶点j到集合U中的最邻近点，lowcost[j]表示V−U中的顶点j到集合U中的最邻近点的边值，即边（j,closest[j]）的权值。</p><p>例如，在图2-62中，7号结点到U集合中的最邻近点是2，closest[7]=2，如图2-63所示。7号结点到最邻近点2的边值为1，即边（2，7）的权值，记为lowcost[7]=1，如图2-64所示。</p><p><img src="https://source.drie.cn/qxsf-images/102.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-63　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/103.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-64　lowcost[]数组</b></center><p>只需要在V−U集合中找lowcost[]值最小的顶点即可。</p><p>步骤2：初始化。令集合U={u<sub class="my_markdown">0</sub>}，u<sub class="my_markdown">0</sub>∈V，并初始化数组closest[]、lowcost[]和s[]。</p><p>步骤3：在V−U集合中找lowcost值最小的顶点t，即lowcost[t]=min{lowcost[j]|j∈V−U}，满足该公式的顶点t就是集合V−U中连接集合U的最邻近点。</p><p>步骤4：将顶点t加入集合U。</p><p>步骤5：如果集合V−U，算法结束，否则，转步骤6。</p><p>步骤6：对集合V−U中的所有顶点j，更新其lowcost[]和closest[]。更新公式：if（<strong>C</strong>[t] [j]&lt;lowcost [j] ) { lowcost [j]= <strong>C</strong> [t] [j]; closest [j] = t; }，转步骤3。</p><p>按照上述步骤，最终可以得到一棵权值之和最小的生成树。</p><h3 id="2-7-3-完美图解">2.7.3　完美图解</h3><p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-65所示。</p><p><img src="https://source.drie.cn/qxsf-images/104.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-65　无向连通带权图**G**</b></center><p>（1）数据结构</p><p>设置地图的带权邻接矩阵为<strong>C</strong>[][]，即如果从顶点i到顶点j有边，就让<strong>C</strong>[i][j]=&lt;i，j&gt;的权值，否则<strong>C</strong>[i][j]=∞（无穷大），如图2-66所示。</p><p><img src="https://source.drie.cn/qxsf-images/105.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-66　邻接矩阵**C**[ ][ ]</b></center><p>（2）初始化</p><p>假设u<sub class="my_markdown">0</sub>=1；令集合U={1}，V−U={2，3，4，5，6，7}，TE={}，s[1]=true，初始化数组closest[]：除了1号结点外其余结点均为1，表示V−U中的顶点到集合U的最临近点均为1，如图2-67所示。lowcost[]：1号结点到V−U中的顶点的边值，即读取邻接矩阵第1行，如图2-68所示。</p><p><img src="https://source.drie.cn/qxsf-images/106.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-67　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/107.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-68　lowcost[]数组</b></center><p>初始化后如图2-69所示。</p><p><img src="https://source.drie.cn/qxsf-images/108.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-69　最小生成树求解过程</b></center><p>（3）找最小</p><p>在集合V−U={2，3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-70所示。</p><p><img src="https://source.drie.cn/qxsf-images/109.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-70　lowcost[]数组</b></center><p>找到最小值为23，对应的结点t=2。</p><p>选中的边和结点如图2-71所示。</p><p><img src="https://source.drie.cn/qxsf-images/110.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-71　最小生成树求解过程</b></center><p>（4）加入U战队</p><p>将顶点t加入集合U={1，2}，同时更新V−U={3，4，5，6，7}。</p><p>（5）更新</p><p>刚刚找到了到U集合的最邻近点t = 2，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，2号结点的邻接点是3和7号结点：</p><p><strong>C</strong>[2][3]=20&lt;lowcost[3]=∞，更新最邻近距离lowcost[3]=20，最邻近点closest[3]=2；</p><p><strong>C</strong>[2][7]=1&lt;lowcost[7]=36，更新最邻近距离lowcost[7]=1，最邻近点closest[7]=2；</p><p>更新后的closest[j]和lowcost[j]数组如图2-72和图2-73所示。</p><p><img src="https://source.drie.cn/qxsf-images/111.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-72　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/112.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-73　lowcost[]数组</b></center><p>更新后如图2-74所示。</p><p><img src="https://source.drie.cn/qxsf-images/113.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-74　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为2，最邻近距离为20；4、5号顶点到U集合的最邻近点仍为初始化状态1，最邻近距离为∞；6号顶点到U集合的最邻近点为1，最邻近距离为26；7号顶点到U集合的最邻近点为2，最邻近距离为1。</p><p>（6）找最小</p><p>在集合V−U={3，4，5，6，7}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-75所示。</p><p><img src="https://source.drie.cn/qxsf-images/114.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-75　lowcost[]数组</b></center><p>找到最小值为1，对应的结点t=7。</p><p>选中的边和结点如图2-76所示。</p><p><img src="https://source.drie.cn/qxsf-images/115.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-76　最小生成树求解过程</b></center><p>（7）加入U战队</p><p>将顶点t加入集合U={1，2，7}，同时更新V−U={3，4，5，6}。</p><p>（8）更新</p><p>刚刚找到了到U集合的最邻近点t =7，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图或邻接矩阵可以看出，7号结点在集合V−U中的邻接点是3、4、5、6结点：</p><p><strong>C</strong>[7][3]=4&lt;lowcost[3]=20，更新最邻近距离lowcost[3]=4，最邻近点closest[3]=7；</p><p><strong>C</strong>[7][4]=9&lt;lowcost[4]=∞，更新最邻近距离lowcost[4]=9，最邻近点closest[4]=7；</p><p><strong>C</strong>[7][5]=16&lt;lowcost[5]=∞，更新最邻近距离lowcost[5]=16，最邻近点closest[5]=7；</p><p><strong>C</strong>[7][6]=25&lt;lowcost[6]=28，更新最邻近距离lowcost[6]=25，最邻近点closest[6]=7；</p><p>更新后的closest[j]和lowcost[j]数组如图2-77和图2-78所示。</p><p><img src="https://source.drie.cn/qxsf-images/116.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-77　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/117.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-78　lowcost[]数组</b></center><p>更新后如图2-79所示。</p><p><img src="https://source.drie.cn/qxsf-images/118.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-79　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。3号顶点到U集合的最邻近点为7，最邻近距离为4；4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（9）找最小</p><p>在集合V−U={3，4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-80所示。</p><p><img src="https://source.drie.cn/qxsf-images/119.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-80　lowcost[]数组</b></center><p>找到最小值为4，对应的结点t=3。</p><p>选中的边和结点如图2-81所示。</p><p><img src="https://source.drie.cn/qxsf-images/120.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-81　最小生成树求解过程</b></center><p>（10）加入U战队</p><p>将顶点t加入集合U ={1，2，3，7}，同时更新V−U={4，5，6}。</p><p>（11）更新</p><p>刚刚找到了到U集合的最邻近点t =3，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，3号结点在集合V−U中的邻接点是4号结点：</p><p>C[3][4]=15&gt;lowcost[4]=9，不更新。</p><p>closest[j]和lowcost[j]数组不改变。</p><p>更新后如图2-82所示。</p><p><img src="https://source.drie.cn/qxsf-images/121.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-82　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。4号顶点到U集合的最邻近点为7，最邻近距离为9；5号顶点到U集合的最邻近点为7，最邻近距离为16；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（12）找最小</p><p>在集合V−U={4，5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-83所示。</p><p><img src="https://source.drie.cn/qxsf-images/122.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-83　lowcost[]数组</b></center><p>找到最小值为9，对应的结点t=4。</p><p>选中的边和结点如图2-84所示。</p><p><img src="https://source.drie.cn/qxsf-images/123.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-84　最小生成树求解过程</b></center><p>（13）加入U战队</p><p>将顶点t加入集合U ={1，2，3，4，7}，同时更新V−U={5，6}。</p><p>（14）更新</p><p>刚刚找到了到U集合的最邻近点t =4，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，4号结点在集合V−U中的邻接点是5号结点：</p><p><strong>C</strong>[4][5]=3&lt;lowcost[5]=16，更新最邻近距离lowcost[5]=3，最邻近点closest[5]=4；</p><p>更新后的closest[j]和lowcost[j]数组如图2-85和图2-86所示。</p><p><img src="https://source.drie.cn/qxsf-images/124.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-85　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/125.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-86　lowcost[]数组</b></center><p>更新后如图2-87所示。</p><p><img src="https://source.drie.cn/qxsf-images/126.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-87　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。5号顶点到U集合的最邻近点为4，最邻近距离为3；6号顶点到U集合的最邻近点为7，最邻近距离为25。</p><p>（15）找最小</p><p>在集合V−U={5，6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-88所示。</p><p><img src="https://source.drie.cn/qxsf-images/127.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-88　lowcost[]数组</b></center><p>找到最小值为3，对应的结点t=5。</p><p>选中的边和结点如图2-89所示。</p><p><img src="https://source.drie.cn/qxsf-images/128.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-89　最小生成树求解过程</b></center><p>（16）加入U战队</p><p>将顶点t加入集合U={1，2，3，4，5，7}，同时更新V−U={6}。</p><p>（17）更新</p><p>刚刚找到了到U集合的最邻近点t =5，那么对t在集合V−U中每一个邻接点j，都可以借助t更新。我们从图或邻接矩阵可以看出，5号结点在集合V−U中的邻接点是6号结点：</p><p><strong>C</strong>[5][6]=17&lt;lowcost[6]=25，更新最邻近距离lowcost[6]=17，最邻近点closest[6]=5；</p><p>更新后的closest[j]和lowcost[j]数组如图2-90和图2-91所示。</p><p><img src="https://source.drie.cn/qxsf-images/129.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-90　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/130.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-91　lowcost[]数组</b></center><p>更新后如图2-92所示。</p><p><img src="https://source.drie.cn/qxsf-images/131.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-92　最小生成树求解过程</b></center><p>closest[j]和lowcost[j]分别表示V−U集合中顶点j到U集合的最邻近顶点和最邻近距离。6号顶点到U集合的最邻近点为5，最邻近距离为17。</p><p>（18）找最小</p><p>在集合V−U={6}中，依照贪心策略寻找V−U集合中lowcost最小的顶点t，如图2-93所示。</p><p><img src="https://source.drie.cn/qxsf-images/132.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-93　lowcost[]数组</b></center><p>找到最小值为17，对应的结点t=6。</p><p>选中的边和结点如图2-94所示。</p><p><img src="https://source.drie.cn/qxsf-images/133.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-94　最小生成树求解过程</b></center><p>（19）加入U战队</p><p>将顶点t加入集合U ={1，2，3，4，5，6，7}，同时更新V−U={}。</p><p>（20）更新</p><p>刚刚找到了到U集合的最邻近点t =6，那么对t在集合V−U中每一个邻接点j，都可以借t更新。我们从图2-94可以看出，6号结点在集合V−U中无邻接点，因为V−U={}。</p><p>closest[j]和lowcost[j]数组如图2-95和图2-96所示。</p><p><img src="https://source.drie.cn/qxsf-images/134.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-95　closest[]数组</b></center><p><img src="https://source.drie.cn/qxsf-images/135.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-96　lowcost[]数组</b></center><p>得到的最小生成树如图2-97所示。</p><p><img src="https://source.drie.cn/qxsf-images/136.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-97　最小生成树</b></center><p>最小生成树权值之和为57，即把lowcost数组中的值全部加起来。</p><h3 id="2-7-4-伪代码详解">2.7.4　伪代码详解</h3><p>（1）初始化。s[1]=true，初始化数组closest，除了u<sub class="my_markdown">0</sub>外其余顶点最邻近点均为u<sub class="my_markdown">0</sub>，表示V−U中的顶点到集合U的最临近点均为u<sub class="my_markdown">0</sub>；初始代数组lowcost，u<sub class="my_markdown">0</sub>到V−U中的顶点的边值，无边相连则为∞（无穷大）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(i != u0) <span class="comment">//除u0之外的顶点</span></span><br><span class="line">     &#123;</span><br><span class="line">          lowcost[i] = c[u0][i];   <span class="comment">//u0到其它顶点的边值</span></span><br><span class="line">          closest[i] = u0;  <span class="comment">//最邻近点初始化为u0</span></span><br><span class="line">          s[i] = <span class="literal">false</span>;  <span class="comment">//初始化u0之外的顶点不属于U集合，即属于V-U集合</span></span><br><span class="line">     &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          lowcost[i] =<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）在集合V−U中寻找距离集合U最近的顶点t。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> temp = INF;</span><br><span class="line"><span class="type">int</span> t = u0;</span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//在集合中V-U中寻找距离集合U最近的顶点t</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) <span class="comment">//!s[j] 表示j结点在V-U集合中</span></span><br><span class="line">    &#123; </span><br><span class="line">        t = j;</span><br><span class="line">        temp = lowcost[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(t == u0) <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">   <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>（3）更新lowcost和closest数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">s[t] = <span class="literal">true</span>;     <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line"><span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//更新lowcost和closest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j])) <span class="comment">// !s[j] 表示j结点在V-U集合中</span></span><br><span class="line">                                          <span class="comment">//t到j的边值小于当前的最邻近值</span></span><br><span class="line">    &#123;</span><br><span class="line">         lowcost[j] = c[t][j]; <span class="comment">//更新j的最邻近值为t到j的边值</span></span><br><span class="line">         closest[j] = t;    <span class="comment">//更新j的最邻近点为t</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-5-实战演练">2.7.5　实战演练</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-7</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">0x3fffffff</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">bool</span> s[N];</span><br><span class="line"><span class="type">int</span> closest[N];</span><br><span class="line"><span class="type">int</span> lowcost[N];</span><br><span class="line"><span class="type">void</span> <span class="title function_">Prim</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> u0, <span class="type">int</span> c[N][N])</span> </span><br><span class="line">&#123;  <span class="comment">//顶点个数n、开始顶点u0、带权邻接矩阵C[n][n]</span></span><br><span class="line">  <span class="comment">//如果s[i]=true,说明顶点i已加入最小生成树</span></span><br><span class="line">  <span class="comment">//的顶点集合U；否则顶点i属于集合V-U</span></span><br><span class="line">  <span class="comment">//将最后的相关的最小权值传递到数组lowcost</span></span><br><span class="line">  s[u0] = <span class="literal">true</span>; <span class="comment">//初始时，集合中U只有一个元素，即顶点u0</span></span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line">  <span class="type">int</span> j;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)<span class="comment">//①</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="keyword">if</span>(i != u0) </span><br><span class="line">       &#123;</span><br><span class="line">            lowcost[i] = c[u0][i];</span><br><span class="line">            closest[i] = u0;</span><br><span class="line">            s[i] = <span class="literal">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">            lowcost[i] =<span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)  <span class="comment">//②</span></span><br><span class="line">  &#123;</span><br><span class="line">       <span class="type">int</span> temp = INF;</span><br><span class="line">       <span class="type">int</span> t = u0;</span><br><span class="line">       <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++) <span class="comment">//③在集合中V-u中寻找距离集合U最近的顶点t</span></span><br><span class="line">       &#123; </span><br><span class="line">           <span class="keyword">if</span>((!s[j]) &amp;&amp; (lowcost[j] &lt; temp)) </span><br><span class="line">           &#123;</span><br><span class="line">                t = j;</span><br><span class="line">                temp = lowcost[j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      <span class="keyword">if</span>(t == u0)</span><br><span class="line">         <span class="keyword">break</span>;       <span class="comment">//找不到t，跳出循环</span></span><br><span class="line">      s[t] = <span class="literal">true</span>;    <span class="comment">//否则，讲t加入集合U</span></span><br><span class="line">      <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= n; j++)  <span class="comment">//④更新lowcost和closest</span></span><br><span class="line">      &#123;       </span><br><span class="line">          <span class="keyword">if</span>((!s[j]) &amp;&amp; (c[t][j] &lt; lowcost[j]))</span><br><span class="line">          &#123;</span><br><span class="line">              lowcost[j] = c[t][j];</span><br><span class="line">              closest[j] = t;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n, c[N][N], m, u, v, w;</span><br><span class="line">    <span class="type">int</span> u0;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="type">int</span> sumcost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) </span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) </span><br><span class="line">          c[i][j] = INF;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        c[u][v] = c[v][u] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入任一结点u0：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; u0 ;</span><br><span class="line">    <span class="comment">//计算最后的lowcos的总和，即为最后要求的最小的费用之和</span></span><br><span class="line">    Prim(n, u0, c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;数组lowcost的内容为：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; lowcost[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">                sumcost += lowcost[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; sumcost &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line">输入任一结点u0：</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数组lowcost的内容为：</span><br><span class="line"><span class="number">0</span> <span class="number">23</span> <span class="number">4</span> <span class="number">9</span> <span class="number">3</span> <span class="number">17</span> <span class="number">1</span></span><br><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure><h3 id="2-7-6-算法解析">2.7.6　算法解析</h3><p>（1）时间复杂度：在Prim（int n，int u<sub class="my_markdown">0</sub>，int <strong>c</strong>[N][N]）算法中，一共有4个for语句，第①个for语句的执行次数为n，第②个for语句里面嵌套了两个for语句③、④，它们的执行次数均为n，对算法的运行时间贡献最大。当外层循环标号为1时，③、④语句在内层循环的控制下均执行n次，外层循环②从1～n。因此，该语句的执行次数为n*n=n²，算法的时间复杂度为O(n²)。</p><p>（2）空间复杂度：算法所需要的辅助空间包含i、j、lowcost和closest，则算法的空间复杂度是O(n)。</p><h3 id="2-7-7-算法优化拓展">2.7.7　算法优化拓展</h3><p>该算法可以从两个方面优化：</p><p>（1）for语句③找lowcost最小值时使用优先队列，每次出队一个最小值，时间复杂度为logn，执行n次，总时间复杂度为O( n logn)。</p><p>（2）for语句④更新lowcost和closest数据时，如果图采用邻接表存储，每次只检查t的邻接边，不用从1～n检查，检查更新的次数为E（边数），每次更新数据入队，入队的时间复杂度为logn，这样更新的时间复杂度为O( Elogn)。</p><h4 id="1．算法设计">1．算法设计</h4><p>构造最小生成树还有一种算法，Kurskal算法：设<strong>G</strong>=（V，E）是无向连通带权图，V={1，2，…，n}；设最小生成树<strong>T</strong>=（V，TE），该树的初始状态为只有n个顶点而无边的非连通图<strong>T</strong>=（V，{}），Kruskal算法将这n个顶点看成是n个孤立的连通分支。它首先将所有的边按权值从小到大排序，然后只要<strong>T</strong>中选中的边数不到n−1，就做如下的贪心选择：在边集E中选取权值最小的边（i，j），如果将边（i，j）加入集合TE中不产生回路（圈），则将边（i，j）加入边集TE中，即用边（i，j）将这两个连通分支合并连接成一个连通分支；否则继续选择下一条最短边。把边（i，j）从集合E中删去。继续上面的贪心选择，直到<strong>T</strong>中所有顶点都在同一个连通分支上为止。此时，选取到的n−1条边恰好构成<strong>G</strong>的一棵最小生成树<strong>T</strong>。</p><p>那么，怎样判断加入某条边后图<strong>T</strong>会不会出现回路呢？</p><p>该算法对于手工计算十分方便，因为用肉眼可以很容易看到挑选哪些边能够避免构成回路（避圈法），但使用计算机程序来实现时，还需要一种机制来进行判断。Kruskal算法用了一个非常聪明的方法，就是运用集合避圈：如果所选择加入的边的起点和终点都在<strong>T</strong>的集合中，那么就可以断定一定会形成回路（圈）。其实就是我们前面提到的“避圈法”：边的两个结点不能属于同一集合。</p><p>步骤1：初始化。将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，边集TE={ }，把每个顶点都初始化为一个孤立的分支，即一个顶点对应一个集合。</p><p>步骤2：在E中寻找权值最小的边（i，j）。</p><p>步骤3：如果顶点i和j位于两个不同连通分支，则将边（i，j）加入边集TE，并执行合并操作，将两个连通分支进行合并。</p><p>步骤4：将边（i，j）从集合E中删去，即E=E−{（i，j）}。</p><p>步骤 5：如果选取边数小于n−1，转步骤2；否则，算法结束，生成最小生成树T。</p><h4 id="2．完美图解">2．完美图解</h4><p>设<strong>G</strong> =（V，E）是无向连通带权图，如图2-98所示。</p><p><img src="https://source.drie.cn/qxsf-images/137.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-98　无向连通带权图**G**</b></center><p>（1）初始化</p><p>将图<strong>G</strong>的边集E中的所有边按权值从小到大排序，如图2-99所示。</p><p><img src="https://source.drie.cn/qxsf-images/138.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-99　按边权值排序后的图**G**</b></center><p>边集初始化为空集，TE={ }，把每个结点都初始化为一个孤立的分支，即一个顶点对应一个集合，集合号为该结点的序号，如图2-100所示。</p><p><img src="https://source.drie.cn/qxsf-images/139.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-100　每个结点初始化集合号</b></center><p>（2）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">1</sub>（2，7），边值为1。</p><p>（3）合并</p><p>结点2和结点7的集合号不同，即属于两个不同连通分支，则将边（2，7）加入边集TE，执行合并操作（将两个连通分支所有结点合并为一个集合）；假设把小的集合号赋值给大的集合号，那么7号结点的集合号也改为2，如图2-101所示。</p><p><img src="https://source.drie.cn/qxsf-images/140.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-101　最小生成树求解过程</b></center><p>（4）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">2</sub>（4，5），边值为3。</p><p>（5）合并</p><p>结点4和结点5集合号不同，即属于两个不同连通分支，则将边（4，5）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么5号结点的集合号也改为4，如图2-102所示。</p><p><img src="https://source.drie.cn/qxsf-images/141.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-102　最小生成树求解过程</b></center><p>（6）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">3</sub>（3，7），边值为4。</p><p>（7）合并</p><p>结点3和结点7集合号不同，即属于两个不同连通分支，则将边（3，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么3号结点的集合号也改为2，如图2-103所示。</p><p><img src="https://source.drie.cn/qxsf-images/142.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-103　最小生成树求解过程</b></center><p>（8）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">4</sub>（4，7），边值为9。</p><p>（9）合并</p><p>结点4和结点7集合号不同，即属于两个不同连通分支，则将边（4，7）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么4、5号结点的集合号都改为2，如图2-104所示。</p><p><img src="https://source.drie.cn/qxsf-images/143.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-104　最小生成树求解过程</b></center><p>（10）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">5</sub>（3，4），边值为15。</p><p>（11）合并</p><p>结点3和结点4集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（12）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">6</sub>（5，7），边值为16。</p><p>（13）合并</p><p>结点5和结点7集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（14）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">7</sub>（5，6），边值为17。</p><p>（15）合并</p><p>结点5和结点6集合号不同，即属于两个不同连通分支，则将边（5，6）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么6号结点的集合号都改为2，如图2-105所示。</p><p><img src="https://source.drie.cn/qxsf-images/144.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-105　最小生成树求解过程</b></center><p>（16）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">8</sub>（2，3），边值为20。</p><p>（17）合并</p><p>结点2和结点3集合号相同，属于同一连通分支，不能选择，否则会形成回路。</p><p>（18）找最小</p><p>在E中寻找权值最小的边e<sub class="my_markdown">9</sub>（1，2），边值为23。</p><p>（19）合并</p><p>结点1和结点2集合号不同，即属于两个不同连通分支，则将边（1，2）加入边集TE，执行合并操作将两个连通分支所有结点合并为一个集合；假设我们把小的集合号赋值给大的集合号，那么2、3、4、5、6、7号结点的集合号都改为1，如图2-106所示。</p><p><img src="https://source.drie.cn/qxsf-images/145.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图2-106　最小生成树</b></center><p>（20）选中的各边和所有的顶点就是最小生成树，各边权值之和就是最小生成树的代价。</p><h4 id="3．伪码详解">3．伪码详解</h4><p>（1）数据结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nodeset[N];<span class="comment">//集合号数组</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span><span class="comment">//边的存储结构</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br></pre></td></tr></table></figure><p>（2）初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;<span class="comment">//每个结点赋值一个集合号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）对边进行排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//定义优先级，按边值进行升序排序</span></span><br><span class="line">&#125;</span><br><span class="line">sort(e, e+m, comp);<span class="comment">//调用系统排序函数</span></span><br></pre></td></tr></table></figure><p>（4）合并集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];<span class="comment">//p为a结点的集合号</span></span><br><span class="line">     <span class="type">int</span> q = nodeset[b]; <span class="comment">//q为b结点的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//集合号相同，什么也不做，返回</span></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的全部改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4．实战演练">4．实战演练</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-8</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> nodeset[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          nodeset[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = nodeset[a];</span><br><span class="line">     <span class="type">int</span> q = nodeset[b];</span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="comment">//检查所有结点，把集合号是q的改为p</span></span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">if</span>(nodeset[i]==q)</span><br><span class="line">          nodeset[i] = p;<span class="comment">//a的集合号赋值给b集合号</span></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">  Init(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u,v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">      <span class="built_in">cin</span> &gt;&gt; e[i].u&gt;&gt; e[i].v &gt;&gt;e[i].w;</span><br><span class="line">  sort(e, e+m, comp);</span><br><span class="line">  <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5．算法复杂度分析">5．算法复杂度分析</h4><p>（1）时间复杂度：算法中，需要对边进行排序，若使用快速排序，执行次数为e<em>loge，算法的时间复杂度为O(e</em>loge)。而合并集合需要n−1次合并，每次为O(n)，合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)。</p><p>（2）空间复杂度：算法所需要的辅助空间包含集合号数组 nodeset[n]，则算法的空间复杂度是O(n)。</p><h4 id="6．算法优化拓展">6．算法优化拓展</h4><p>该算法合并集合的时间复杂度为O(n<sup class="my_markdown">2</sup>)，我们可以用并查集（见附录E）的思想优化，使合并集合的时间复杂度降为O(e*logn)，优化后的程序如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program 2-9</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line">using namespace <span class="built_in">std</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> father[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">     <span class="type">int</span> u;</span><br><span class="line">     <span class="type">int</span> v;</span><br><span class="line">     <span class="type">int</span> w;</span><br><span class="line">&#125;e[N*N];</span><br><span class="line"><span class="type">bool</span> <span class="title function_">comp</span><span class="params">(Edge x, Edge y)</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> x.w &lt; y.w;<span class="comment">//排序优先级，按边的权值从小到大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">          father[i] = i;<span class="comment">//顶点所属集合号，初始化每个顶点一个集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Find</span><span class="params">(<span class="type">int</span> x)</span> <span class="comment">//找祖宗</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span>(x != father[x])</span><br><span class="line">     father[x] = Find(father[x]);<span class="comment">//把当前结点到其祖宗路径上的所有结点的集合号改为祖宗集合号</span></span><br><span class="line">     <span class="keyword">return</span> father[x]; <span class="comment">//返回其祖宗的集合号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> <span class="comment">//两结点合并集合号</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> p = Find(a); <span class="comment">//找a的集合号</span></span><br><span class="line">     <span class="type">int</span> q = Find(b); <span class="comment">//找b的集合号</span></span><br><span class="line">     <span class="keyword">if</span>(p==q) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(p &gt; q)</span><br><span class="line">           father[p] = q;<span class="comment">//小的集合号赋值给大的集合号</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">           father[q] = p;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">Kruskal</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">          <span class="keyword">if</span>(Merge(e[i].u, e[i].v))</span><br><span class="line">          &#123;</span><br><span class="line">              ans += e[i].w;</span><br><span class="line">              n--;</span><br><span class="line">              <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">                  <span class="keyword">return</span> ans;</span><br><span class="line">          &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数n和边数m：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    Init(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;输入结点数u，v和边值w：&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;</span><br><span class="line">    sort(e, e+m, comp);</span><br><span class="line">    <span class="type">int</span> ans = Kruskal(n);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最小的花费是：&quot;</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>算法实现和测试</strong></p><p>（1）运行环境</p><p>Code::Blocks</p><p>（2）输入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入结点数n和边数m：</span><br><span class="line"><span class="number">7</span> <span class="number">12</span></span><br><span class="line">输入结点数u，v和边值w：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">23</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">28</span></span><br><span class="line"><span class="number">1</span> <span class="number">7</span> <span class="number">36</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">20</span></span><br><span class="line"><span class="number">2</span> <span class="number">7</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">15</span></span><br><span class="line"><span class="number">3</span> <span class="number">7</span> <span class="number">4</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span> <span class="number">7</span> <span class="number">9</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">17</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="number">6</span> <span class="number">7</span> <span class="number">25</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）输出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最小的花费是：<span class="number">57</span></span><br></pre></td></tr></table></figure><h4 id="7．两种算法的比较">7．两种算法的比较</h4><p>（1）从算法的思想可以看出，如果图<strong>G</strong>中的边数较小时，可以采用Kruskal算法，因为Kruskal算法每次查找最短的边；边数较多可以用Prim算法，因为它是每次加一个结点。可见，Kruskal算法适用于稀疏图，而Prim算法适用于稠密图。</p><p>（2）从时间上讲，Prim算法的时间复杂度为O(n<sup class="my_markdown">2</sup>)，Kruskal算法的时间复杂度为O(eloge)。</p><p>（3）从空间上讲，显然在Prim算法中，只需要很小的空间就可以完成算法，因为每一次都是从V−U集合出发进行扫描的，只扫描与当前结点集到U集合的最小边。但在Kruskal算法中，需要对所有的边进行排序，对于大型图而言，Kruskal算法需要占用比Prim算法大得多的空间。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第二章-贪心算法&quot;&gt;第二章　贪心算法&lt;/h3&gt;
&lt;p&gt;从前，有一个很穷的人救了一条蛇的命，蛇为了报答他的救命之恩，于是就让这个人提出要求，满足他的愿望。这个人一开始只要求简单的衣食，蛇都满足了他的愿望，后来慢慢的贪欲生起，要求做官，蛇也满足了他。这个人直到做了宰相</summary>
      
    
    
    
    <category term="算法" scheme="https://drie.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>《趣学算法》——第一章（算法之美）</title>
    <link href="https://drie.cn/posts/87ab2347.html"/>
    <id>https://drie.cn/posts/87ab2347.html</id>
    <published>2024-06-30T19:01:06.000Z</published>
    <updated>2024-07-01T03:03:14.943Z</updated>
    
    <content type="html"><![CDATA[<h3 id="第一章-算法之美">第一章  算法之美</h3><p>如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路。数学是美学，算法是艺术。走进算法的人，才能体会它的魅力。</p><p>多年来，我有一个梦想，希望每一位提到算法的人，不再立即紧皱眉头，脑海闪现枯燥的公式、冗长的代码；希望每一位阅读和使用算法的人，体会到算法之美，像躺在法国普罗旺斯小镇的长椅上，呷一口红酒，闭上眼睛，体会舌尖上的美味，感受鼻腔中满溢的薰衣草的芳香……</p><p><img src="https://source.drie.cn/qxsf-images/1.png" alt="code"></p><h3 id="1-1-打开算法之门">1.1　打开算法之门</h3><p>瑞士著名的科学家N.Wirth教授曾提出： <strong>数据结构+算法=程序</strong> 。</p><p>数据结构是程序的骨架，算法是程序的灵魂。</p><p>在我们的生活中，算法无处不在。我们每天早上起来，刷牙、洗脸、吃早餐，都在算着时间，以免上班或上课迟到；去超市购物，在资金有限的情况下，考虑先买什么、后买什么，算算是否超额；在家中做饭，用什么食材、调料，做法、步骤，还要品尝一下咸淡，看看是否做熟。所以，不要说你不懂算法，其实你每天都在用！</p><p>但是对计算机专业算法，很多人都有困惑：“I can understand, but I can’tuse！”，我能看懂，但不会用！就像参观莫高窟的壁画，看到它、感受它，却无法走进。我们正需要一把打开算法之门的钥匙，就如陶渊明《桃花源记》中的“初极狭，才通人。复行数十步，豁然开朗。”</p><h3 id="1-2-妙不可言——算法复杂性">1.2　妙不可言——算法复杂性</h3><p>我们首先看一道某跨国公司的招聘试题。</p><p>写一个算法，求下面序列之和：</p><p>−1，1，−1，1，…，(−1)<sup class="my_markdown">n</sup></p><p>当你看到这个题目时，你会怎么想？for语句？while循环？</p><p>先看算法1-1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-1 </span></span><br><span class="line">sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">&#123;</span><br><span class="line">  sum=sum+(<span class="number">-1</span>)^n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码可以实现求和运算，但是为什么不这样算?！</p><p><img src="https://source.drie.cn/qxsf-images/2.jpg" alt="code"><br>再看算法1-2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-2</span></span><br><span class="line"><span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>)  <span class="comment">//判断n是不是偶数，%表示求余数</span></span><br><span class="line">  sum =<span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  sum=<span class="number">-1</span>;</span><br></pre></td></tr></table></figure><p>有的人看到这个代码后恍然大悟，原来可以这样啊？这不就是数学家高斯使用的算法吗？</p><p><img src="https://source.drie.cn/qxsf-images/3.jpg" alt="code"><br>一共50对数，每对之和均为101，那么总和为：</p><p>（1+100）×50=5050</p><p>1787年，10岁的高斯用了很短的时间算出了结果，而其他孩子却要算很长时间。</p><p>可以看出，算法1-1需要运行n+1次，如果n=100 00，就要运行100 01次，而算法1-2仅仅需要运行1次！是不是有很大差别？</p><blockquote><p>高斯的方法我也知道，但遇到类似的题还是……我用的笨办法也是算法吗？</p></blockquote><p><strong>答：是算法。</strong></p><p><strong>算法是指对特定问题求解步骤的一种描述。</strong></p><p>算法只是对问题求解方法的一种描述，它不依赖于任何一种语言，既可以用自然语言、程序设计语言（C、C++、Java、Python等）描述，也可以用流程图、框图来表示。一般为了更清楚地说明算法的本质，我们去除了计算机语言的语法规则和细节，采用“伪代码”来描述算法。“伪代码”介于自然语言和程序设计语言之间，它更符合人们的表达方式，容易理解，但不是严格的程序设计语言，如果要上机调试，需要转换成标准的计算机程序设计语言才能运行。</p><p>算法具有以下特性。</p><p>（1） <strong>有穷性</strong> ：算法是由若干条指令组成的有穷序列，总是在执行若干次后结束，不可能永不停止。</p><p>（2） <strong>确定性</strong> ：每条语句有确定的含义，无歧义。</p><p>（3） <strong>可行性</strong> ：算法在当前环境条件下可以通过有限次运算实现。</p><p>（4） <strong>输入输出</strong> ：有零个或多个输入，一个或多个输出。</p><blockquote><p>算法1-2的确算得挺快的，但如何知道我写的算法好不好呢？</p></blockquote><p><strong>“好”算法的标准如下。</strong></p><p>（1）正确性：正确性是指算法能够满足具体问题的需求，程序运行正常，无语法错误，能够通过典型的软件测试，达到预期的需求。</p><p>（2）易读性：算法遵循标识符命名规则，简洁易懂，注释语句恰当适量，方便自己和他人阅读，便于后期调试和修改。</p><p>（3）健壮性：算法对非法数据及操作有较好的反应和处理。例如，在学生信息管理系统中登记学生年龄时，若将21岁误输入为210岁，系统应该提示出错。</p><p>（4）高效性：高效性是指算法运行效率高，即算法运行所消耗的时间短。算法时间复杂度就是算法运行需要的时间。现代计算机一秒钟能计算数亿次，因此不能用秒来具体计算算法消耗的时间，由于相同配置的计算机进行一次基本运算的时间是一定的，我们可以用算法基本运算的执行次数来衡量算法的效率。因此，将算法基本运算的执行次数作为时间复杂度的衡量标准。</p><p>（5）低存储性：低存储性是指算法所需要的存储空间低。对于像手机、平板电脑这样的嵌入式设备，算法如果占用空间过大，则无法运行。算法占用的空间大小称为 <strong>空间复杂度</strong> 。</p><p>除了（1）～（3）中的基本标准外，我们对好的算法的评判标准就是 <strong>高效率</strong> 、 <strong>低存储</strong> 。</p><blockquote><p>（1）～（3）中的标准都好办，但时间复杂度怎么算呢？</p></blockquote><p><strong>时间复杂度</strong> ：算法运行需要的时间，一般将 <strong>算法的执行次数</strong> 作为时间复杂度的度量标准。</p><p>看算法1-3，并分析算法的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-3 </span></span><br><span class="line">sum=<span class="number">0</span>;                     <span class="comment">//运行1次</span></span><br><span class="line">total=<span class="number">0</span>;                   <span class="comment">//运行1次</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)        <span class="comment">//运行n次</span></span><br><span class="line">&#123;</span><br><span class="line">  sum=sum+i;               <span class="comment">//运行n次</span></span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">1</span>; j&lt;=n; j++)      <span class="comment">//运行n*n次</span></span><br><span class="line">    total=total+i*j;       <span class="comment">//运行n*n次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把算法的所有语句的运行次数加起来：1+1+n+n+n×n+n×n，可以用一个函数T(n)表达：</p><p>T(n)=2n<sup class="my_markdown">2</sup>+2n+2</p><p>当n足够大时，例如n=10<sup class="my_markdown">5</sup>时，T(n)=2×10<sup>10</sup>+2×10<sup class="my_markdown">5</sup>+2，我们可以看到算法运行时间主要取决于第一项，后面的甚至可以忽略不计。</p><p>用极限表示为：</p><p>，C为不等于0的常数</p><p><img src="https://source.drie.cn/qxsf-images/4.gif" alt="code"><br>如果用 <strong>时间复杂度的渐近上界</strong> 表示，如图1-1所示。</p><p>从图1-1中可以看出，当n≥n<sub class="my_markdown">0</sub>时，T(n)≤Cf (n)，当n足够大时，T(n)和f (n)近似相等。因此，我们用О(f (n))来表示时间复杂度渐近上界，通常用这种表示法衡量算法时间复杂度。算法1-3的时间复杂度渐近上界为О(f (n))＝О(n<sup class="my_markdown">2</sup>)，用极限表示为：</p><p><img src="https://source.drie.cn/qxsf-images/7.gif" alt="code"><br><img src="https://source.drie.cn/qxsf-images/8.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-1　渐近时间复杂度上界</b></center><p>还有 <strong>渐近下界</strong> 符号Ω(T(n)≥Cf (n))，如图1-2所示。</p><p><img src="https://source.drie.cn/qxsf-images/9.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-2　渐近时间复杂度下界</b></center><p>从图1-2可以看出，当n≥n<sub class="my_markdown">0</sub>时，T(n)≥Cf (n)，当n足够大时，T(n)和f (n)近似相等，因此，我们用Ω(f (n))来表示时间复杂度渐近下界。</p><p><strong>渐近精确界</strong> 符号Θ(C<sub class="my_markdown">1</sub>f (n)≤T(n)≤C<sub>2</sub>f (n))，如图1-3所示。</p><p>从图1-3中可以看出，当n≥n<sub class="my_markdown">0</sub>时，C<sub>1</sub>f (n)≤T(n)≤C<sub>2</sub>f (n)，当n足够大时，T(n)和f (n)近似相等。这种两边逼近的方式，更加精确近似，因此，用Θ (f (n))来表示时间复杂度渐近精确界。</p><p><img src="https://source.drie.cn/qxsf-images/10.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-3　渐进时间复杂度精确界</b></center><p>我们通常使用时间复杂度渐近上界О(f (n))来表示时间复杂度。</p><p>看算法1-4，并分析算法的时间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-4</span></span><br><span class="line">i=<span class="number">1</span>;              <span class="comment">//运行1次</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;=n)     <span class="comment">//可假设运行x次</span></span><br><span class="line">&#123;</span><br><span class="line">  i=i*<span class="number">2</span>;         <span class="comment">//可假设运行x次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察算法1-4，无法立即确定while 及i=i*2运行了多少次。这时可假设运行了x次，每次运算后i值为2，2<sup class="my_markdown">2</sup>，2<sup>3</sup>，…，2<sup>x</sup>，当i=n时结束，即2<sup>x</sup>＝n时结束，则x=log<sub class="my_markdown">2</sub>n，那么算法1-4的运算次数为1+2log<sub class="my_markdown">2</sub>n，时间复杂度渐近上界为О(f (n))＝О(log<sub class="my_markdown">2</sub>n)。</p><p>在算法分析中，渐近复杂度是对算法运行次数的粗略估计，大致反映问题规模增长趋势，而不必精确计算算法的运行时间。在计算渐近时间复杂度时，可以只考虑对算法运行时间贡献大的语句，而忽略那些运算次数少的语句，循环语句中处在循环内层的语句往往运行次数最多，即为对运行时间贡献最大的语句。例如在算法1-3中，total=total+i*j是对算法贡献最大的语句，只计算该语句的运行次数即可。</p><p><strong>注意：</strong> 不是每个算法都能直接计算运行次数。</p><p>例如算法1-5，在a[n]数组中顺序查找x，返回其下标i，如果没找到，则返回−1。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-5 </span></span><br><span class="line">findx(<span class="type">int</span> x)      <span class="comment">//在a[n]数组中顺序查找x</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)  </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (a[i]==x)  </span><br><span class="line">     <span class="keyword">return</span> i;    <span class="comment">//返回其下标i</span></span><br><span class="line">   ｝</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们很难计算算法1-5中的程序到底执行了多少次，因为运行次数依赖于x在数组中的位置，如果第一个元素就是x，则执行1次（最好情况）；如果最后一个元素是x，则执行n次（最坏情况）；如果分布概率均等，则平均执行次数为（n+1）/2。</p><p>有些算法，如排序、查找、插入等算法，可以分为 <strong>最好</strong> 、 <strong>最坏</strong> 和 <strong>平均</strong> 情况分别求算法渐近复杂度，但我们考查一个算法通常考查最坏的情况，而不是考查最好的情况， <strong>最坏情况对衡量算法的好坏具有实际的意义</strong> 。</p><blockquote><p>我明白了，那空间复杂度应该就是算法占了多大存储空间了？</p></blockquote><p><strong>空间复杂度</strong> ：算法占用的空间大小。一般将算法的 <strong>辅助空间</strong> 作为衡量空间复杂度的标准。</p><p>空间复杂度的本意是指算法在运行过程中占用了多少存储空间。算法占用的存储空间包括：</p><p>（1）输入/输出数据；</p><p>（2）算法本身；</p><p>（3）额外需要的辅助空间。</p><p>输入/输出数据占用的空间是必需的，算法本身占用的空间可以通过精简算法来缩减，但这个压缩的量是很小的，可以忽略不计。而在运行时使用的辅助变量所占用的空间，即辅助空间是衡量空间复杂度的关键因素。</p><p>看算法1-6，将两个数交换，并分析其空间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-6 </span></span><br><span class="line">swap(<span class="type">int</span> x,<span class="type">int</span> y)  <span class="comment">//x与y交换 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> temp;</span><br><span class="line">  temp=x;  <span class="comment">//temp为辅助空间 ①</span></span><br><span class="line">  x=y;   ②</span><br><span class="line">  y=temp; ③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两数的交换过程如图1-4所示。</p><p><img src="https://source.drie.cn/qxsf-images/11.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-4　两数交换过程</b></center><p>图1-4中的步骤标号与算法1-6中的语句标号一一对应，该算法使用了一个辅助空间temp，空间复杂度为О(1)。</p><p><strong>注意：</strong> 递归算法中，每一次递推需要一个栈空间来保存调用记录，因此，空间复杂度需要计算递归栈的辅助空间。</p><p>看算法1-7，计算n的阶乘，并分析其空间复杂度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-7 </span></span><br><span class="line">fac(<span class="type">int</span> n)  <span class="comment">//计算n的阶乘</span></span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">0</span>)   <span class="comment">//小于零的数无阶乘值</span></span><br><span class="line">  &#123;  </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;n&lt;0,data error!&quot;</span>); </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(n= =<span class="number">0</span> || n= =<span class="number">1</span>) </span><br><span class="line">           <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">         <span class="keyword">else</span> </span><br><span class="line">           <span class="keyword">return</span> n*fac(n<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>阶乘是典型的递归调用问题，递归包括递推和回归。递推是将原问题不断分解成子问题，直到达到结束条件，返回最近子问题的解；然后逆向逐一回归，最终到达递推开始的原问题，返回原问题的解。</p><p><strong>思考：</strong> 试求5的阶乘，程序将怎样计算呢？</p><p>5的阶乘的递推和回归过程如图1-5和图1-6所示。</p><p><img src="https://source.drie.cn/qxsf-images/12.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-5　5的阶乘递推过程</b></center><p><img src="https://source.drie.cn/qxsf-images/13.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-6　5的阶乘回归过程</b></center><p>图1-5和图1-6的递推、回归过程是我们从逻辑思维上推理，用图的方式形象地表达出来的，但计算机内部是怎样处理的呢？计算机使用一种称为“栈”的数据结构，它类似于一个放一摞盘子的容器，每次从顶端放进去一个，拿出来的时候只能从顶端拿一个，不允许从中间插入或抽取，因此称为“后进先出”（last in first out）。</p><p>5的阶乘进栈过程如图1-7所示。</p><p><img src="https://source.drie.cn/qxsf-images/14.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-7　5的阶乘进栈过程</b></center><p>5的阶乘出栈过程如图1-8所示。</p><p><img src="https://source.drie.cn/qxsf-images/15.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-8　5的阶乘出栈过程</b></center><p>从图1-7和图1-8的进栈、出栈过程中，我们可以很清晰地看到，首先把子问题一步步地压进栈，直到得到返回值，再一步步地出栈，最终得到递归结果。在运算过程中，使用了n个栈空间作为辅助空间，因此阶乘递归算法的空间复杂度为О(n)。在算法1-7中，时间复杂度也为О(n)，因为n的阶乘仅比n−1的阶乘多了一次乘法运算，fac(n)=n*fac(n−1)。如果用T(n)表示fac(n)的时间复杂度，可表示为：</p><p>T(n)= T(n−1)+1</p><p>= T(n−2)+1+1</p><p>……</p><p>= T(1)+…+1+1</p><p>=n</p><h3 id="1-3-美不胜收——魔鬼序列">1.3　美不胜收——魔鬼序列</h3><h4 id="趣味故事1-1：一棋盘的麦子">趣味故事1-1：一棋盘的麦子</h4><p>有一个古老的传说，有一位国王的女儿不幸落水，水中有很多鳄鱼，国王情急之下下令：“谁能把公主救上来，就把女儿嫁给他。”很多人纷纷退让，一个勇敢的小伙子挺身而出，冒着生命危险把公主救了上来，国王一看是个穷小子，想要反悔，说：“除了女儿，你要什么都可以。”小伙子说：“好吧，我只要一棋盘的麦子。您在第1个格子里放1粒麦子，在第2个格子里放2粒，在第3个格子里放4粒，在第4个格子里放8粒，以此类推，每一格子里的麦子粒数都是前一格的两倍。把这64个格子都放好了就行，我就要这么多。”国王听后哈哈大笑，觉得小伙子的要求很容易满足，满口答应。结果发现，把全国的麦子都拿来，也填不完这64格……国王无奈，只好把女儿嫁给了这个小伙子。</p><p><strong>解析</strong></p><p>棋盘上的64个格子究竟要放多少粒麦子？</p><p>把每一个放的麦子数加起来，总和为S，则：</p><p>S=1+2<sup class="my_markdown">1</sup>+2<sup>2</sup>+2<sup>3</sup>+…+2<sup>63</sup>　　 ①</p><p>我们把式①等号两边都乘以2，等式仍然成立：</p><p>2S=2<sup class="my_markdown">1</sup>+2<sup>2</sup>+2<sup>3</sup>+…+2<sup>63</sup>+2<sup>64</sup>　　 ②</p><p>式 ②减去式①，则：</p><p>S=2<sup class="my_markdown">64</sup>−1 ＝18 446 744 073 709 551 615</p><p>据专家统计，每个麦粒的平均重量约41.9毫克，那么这些麦粒的总重量是：</p><p>18 446 744 073 709 551 615×41.9＝772 918 576 688 430 212 668.5（毫克）</p><p>≈7729（亿吨）</p><p>全世界人口按60亿计算，每人可以分得128吨！</p><p>我们称这样的函数为 <strong>爆炸增量函数</strong> ，想一想，如果算法时间复杂度是О(2<sup class="my_markdown">n</sup>) 会怎样？随着n的增长，这个算法会不会“爆掉”？经常见到有些算法调试没问题，运行一段也没问题，但关键的时候宕机（shutdown）。例如，在线考试系统，50个人考试没问题，100人考试也没问题，如果全校1万人考试就可能出现宕机。</p><p><strong>注意：</strong> 宕机就是死机，指电脑不能正常工作了，包括一切原因导致的死机。计算机主机出现意外故障而死机，一些服务器（如数据库）死锁，服务器的某些服务停止运行都可以称为宕机。</p><p>常见的算法时间复杂度有以下几类。</p><p>（1）常数阶。</p><p>常数阶算法运行的次数是一个常数，如5、20、100。常数阶算法时间复杂度通常用О(1)表示，例如算法1-6，它的运行次数为4，就是常数阶，用О(1)表示。</p><p>（2）多项式阶。</p><p>很多算法时间复杂度是多项式，通常用О(n)、О(n<sup class="my_markdown">2</sup>)、О(n<sup>3</sup>)等表示。例如算法1-3就是多项式阶。</p><p>（3）指数阶。</p><p>指数阶时间复杂度运行效率极差，程序员往往像躲“恶魔”一样避开它。常见的有О(2<sup class="my_markdown">n</sup>)、О(n！)、О(n<sup class="my_markdown">n</sup>)等。使用这样的算法要慎重，例如趣味故事1-1。</p><p>（4）对数阶。</p><p>对数阶时间复杂度运行效率较高，常见的有О(logn)、О(nlogn)等，例如算法1-4。</p><p>常见时间复杂度函数曲线如图1-9所示。</p><p><img src="https://source.drie.cn/qxsf-images/16.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-9　常见函数增量曲线</b></center><p>从图1-9中可以看出，指数阶增量随着x的增加而急剧增加，而对数阶增加缓慢。它们之间的关系为：</p><p>О(1)&lt; О(logn)&lt; О(n)&lt; О(nlogn) &lt; О(n<sup class="my_markdown">2</sup>)&lt; О(n<sup class="my_markdown">3</sup>)&lt; О(2<sup class="my_markdown">n</sup>) &lt; О(n!)&lt; О(n<sup class="my_markdown">n</sup>)</p><p>我们在设计算法时要注意算法复杂度增量的问题，尽量避免爆炸级增量。</p><h4 id="趣味故事1-2：神奇兔子数列">趣味故事1-2：神奇兔子数列</h4><p>假设第1个月有1对刚诞生的兔子，第2个月进入成熟期，第3个月开始生育兔子，而1对成熟的兔子每月会生1对兔子，兔子永不死去……那么，由1对初生兔子开始，12个月后会有多少对兔子呢？</p><p>兔子数列即斐波那契数列，它的发明者是意大利数学家列昂纳多•斐波那契（Leonardo Fibonacci，1170—1250）。1202年，他撰写了《算盘全书》（《Liber Abaci》）一书，该书是一部较全面的初等数学著作。书中系统地介绍了印度—阿拉伯数码及其演算法则，介绍了中国的“盈不足术”；引入了负数，并研究了一些简单的一次同余式组。</p><p>（1）问题分析</p><p>我们不妨拿新出生的1对小兔子分析：</p><p>第1个月，小兔子①没有繁殖能力，所以还是1对。</p><p>第2个月，小兔子①进入成熟期，仍然是1对。</p><p>第3个月，兔子①生了1对小兔子②，于是这个月共有2（1+1=2）对兔子。</p><p>第4个月，兔子①又生了1对小兔子③。因此共有3（1+2=3）对兔子。</p><p>第5个月，兔子①又生了1对小兔子④，而在第3个月出生的兔子②也生下了1对小兔子⑤。共有5（2+3=5）对兔子。</p><p>第6个月，兔子①②③各生下了1对小兔子。新生3对兔子加上原有的5对兔子这个月共有8（3+5=8）对兔子。</p><p>……</p><p>为了表达得更清楚，我们用图示来分别表示新生兔子、成熟期兔子和生育期兔子，兔子的繁殖过程如图1-10所示。</p><p><img src="https://source.drie.cn/qxsf-images/17.png" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-10　兔子繁殖过程</b></center><p>这个数列有十分明显的特点，从第3个月开始， <strong>当月的兔子数</strong> = <strong>上月兔子数</strong> + <strong>当月新生兔子数</strong> ，而当月新生的兔子正好是 <strong>上上月的兔子数</strong> 。因此，前面相邻两项之和，构成了后一项，即：</p><p><strong>当月的兔子数</strong> = <strong>上月兔子数</strong> + <strong>上上月的兔子数</strong></p><p>斐波那契数列如下：</p><p>1，1，2，3，5，8，13，21，34，…</p><p>递归式表达式：</p><p><img src="https://source.drie.cn/qxsf-images/18.gif" alt="code"><br>那么我们该怎么设计算法呢？</p><blockquote><p>哈哈，这太简单了，用递归算法很快就算出来了！</p></blockquote><p>（2）算法设计</p><p>首先按照递归表达式设计一个递归算法，见算法1-8。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-8 </span></span><br><span class="line">Fib1(<span class="type">int</span> n) </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> Fib1(n<span class="number">-1</span>)+Fib1(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写得不错，那么算法设计完成后，我们有3个问题：</p><ul><li>算法是否正确？</li><li>算法复杂度如何？</li><li>能否改进算法？</li></ul><p>（3）算法验证分析</p><p>第一个问题毋庸置疑，因为算法1-8是完全按照递推公式写出来的，所以正确性没有问题。那么算法复杂度呢？假设T(n)表示计算Fib1(n)所需要的基本操作次数，那么：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="number">1</span>时，T(n)=<span class="number">1</span>；</span><br><span class="line">n=<span class="number">2</span>时，T(n)=<span class="number">1</span>；</span><br><span class="line">n=<span class="number">3</span>时，T(n)=<span class="number">3</span>；<span class="comment">//调用Fib1(2)、Fib1(1)和执行一次加法运算Fib1(2)+Fib1(1)</span></span><br></pre></td></tr></table></figure><p>因此，n&gt;2时要分别调用Fib1(n−1)、Fib1(n−2)和执行一次加法运算，即：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n&gt;<span class="number">2</span>时，T(n)= T(n<span class="number">-1</span>)+ T(n<span class="number">-2</span>)+<span class="number">1</span>；</span><br></pre></td></tr></table></figure><p>递归表达式和时间复杂度T(n)之间的关系如下：</p><p><img src="https://source.drie.cn/qxsf-images/19.gif" alt="code"><br>由此可得：。</p><p><img src="https://source.drie.cn/qxsf-images/20.gif" alt="code"><br>那么怎么计算F(n)呢？</p><p>有兴趣的读者可以看本书附录A中通项公式的求解方法，也可以看下文中的简略解释。</p><p>斐波那契数列通项为：</p><p><img src="https://source.drie.cn/qxsf-images/21.gif" alt="code"><br>当n趋近于无穷时，</p><p><img src="https://source.drie.cn/qxsf-images/22.gif" alt="code"><br>由于<img class="my_markdown" src="https://source.drie.cn/qxsf-images/20.gif" style="width:100px;  height: 18px; "/>，这是一个指数阶的算法！</p><p>如果我们今年计算出了F(100)，那么明年才能算出F(101)，多算一个斐波那契数需要一年的时间， <strong>爆炸增量函数</strong> 是算法设计的噩梦！算法1-8的时间复杂度属于 <strong>爆炸增量函数</strong> ，这在算法设计时是应当避开的，那么我们能不能改进它呢？</p><p>（4）算法改进</p><p>既然斐波那契数列中的每一项是前两项之和，如果记录前两项的值，只需要一次加法运算就可以得到当前项，时间复杂度会不会更低一些？我们用数组试试看，见算法1-9。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-9 </span></span><br><span class="line">Fib2(<span class="type">int</span> n) </span><br><span class="line">&#123;  </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="type">int</span> *a=new <span class="type">int</span>[n];<span class="comment">//定义一个数组</span></span><br><span class="line">  a[<span class="number">1</span>]=<span class="number">1</span>；</span><br><span class="line">  a[<span class="number">2</span>]=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>;i&lt;=n;i++)</span><br><span class="line">     a[i]=a[i<span class="number">-1</span>]+a[i<span class="number">-2</span>];</span><br><span class="line">  <span class="keyword">return</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，算法1-9的时间复杂度为О(n)。算法仍然是按照F(n)的定义，所以正确性没有问题，而 <strong>时间复杂度</strong> 却从算法1-8的 <strong>指数阶降到了多项式阶</strong> ，这是算法效率的一个巨大突破！</p><p>算法1-9使用了一个辅助数组记录中间结果，空间复杂度也为О(n)，其实我们只需要得到第n个斐波那契数，中间结果只是为了下一次使用，根本不需要记录。因此，我们可以采用 <strong>迭代法</strong> 进行算法设计，见算法1-10。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-10 </span></span><br><span class="line">Fib3(<span class="type">int</span> n) </span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i,s1,s2; </span><br><span class="line">  <span class="keyword">if</span>(n&lt;<span class="number">1</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span>(n==<span class="number">1</span>||n==<span class="number">2</span>)   </span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  s1=<span class="number">1</span>;</span><br><span class="line">  s2=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">3</span>; i&lt;=n; i++)</span><br><span class="line">  &#123;</span><br><span class="line">     s2=s1+s2; <span class="comment">//辗转相加法</span></span><br><span class="line">     s1=s2-s1; <span class="comment">//记录前一项</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代过程如下。</p><p>初始值：s<sub class="my_markdown">1</sub>=1；s<sub>2</sub>=1；</p><p>当前解　　　 记录前一项</p><p>i=3时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=2　　 s<sub>1</sub>=s<sub class="my_markdown">2</sub>−s<sub>1</sub>=1</p><p>i=4时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=3　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=2</p><p>i=5时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=5　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=3</p><p>i=6时　　 s<sub class="my_markdown">2</sub>= s<sub>1</sub>+s<sub class="my_markdown">2</sub>=8　　 s<sub>1</sub>= s<sub class="my_markdown">2</sub>−s<sub>1</sub>=5</p><p>……　　　　　 ……　　　　　 ……</p><p>算法1-10使用了若干个辅助变量，迭代辗转相加，每次记录前一项，时间复杂度为О(n)，但 <strong>空间复杂度</strong> 降到了О(1)。</p><p><strong>问题的进一步讨论</strong> ：我们能不能继续降阶，使算法时间复杂度更低呢？实质上，斐波那契数列时间复杂度还可以降到对数阶О(logn)，有兴趣的读者可以查阅相关资料。想想看，我们把一个算法从 <strong>指数阶</strong> 降到 <strong>多项式阶</strong> ，再降到 <strong>对数阶</strong> ，这是一件多么振奋人心的事！</p><p>（5）惊人大发现</p><p>科学家经研究在植物的叶、枝、茎等排列中发现了斐波那契数！例如，在树木的枝干上选一片叶子，记其为数1，然后依序点数叶子（假定没有折损），直到到达与那片叶子正对的位置，则其间的叶子数多半是斐波那契数。叶子从一个位置到达下一个正对的位置称为一个循回。叶子在一个循回中旋转的圈数也是斐波那契数。在一个循回中，叶子数与叶子旋转圈数的比称为叶序（源自希腊词，意即叶子的排列）比。多数植物的叶序比呈现为斐波那契数的比，例如，蓟的头部具有13条顺时针旋转和21条逆时针旋转的斐波那契螺旋，向日葵的种子的圈数与子数、菠萝的外部排列同样有着这样的特性，如图1-11所示。</p><p><img src="https://source.drie.cn/qxsf-images/23.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-11　斐波那契螺旋（图片来自网络）</b></center><p>观察延龄草、野玫瑰、南美血根草、大波斯菊、金凤花、耧斗菜、百合花、蝴蝶花的花瓣，可以发现它们的花瓣数目为斐波那契数：3，5，8，13，21，…。如图1-12所示。</p><p><img src="https://source.drie.cn/qxsf-images/24.jpg" alt="code"></p><center class="my_markdown"><b class="my_markdown">图1-12　植物花瓣（图片来自网络）</b></center><p>树木在生长过程中往往需要一段“休息”时间，供自身生长，而后才能萌发新枝。所以，一株树苗在一段间隔（例如一年）以后长出一条新枝；第二年新枝“休息”，老枝依旧萌发；此后，老枝与“休息”过一年的枝同时萌发，当年生的新枝则次年“休息”。这样，一株树木各个年份的枝桠数便构成斐波那契数列，这个规律就是生物学上著名的“鲁德维格定律”。</p><p>这些植物懂得斐波那契数列吗？应该并非如此，它们只是按照自然的规律才进化成这样的。这似乎是植物排列种子的“优化方式”，它能使所有种子具有相近的大小却又疏密得当，不至于在圆心处挤太多的种子而在圆周处却又很稀疏。叶子的生长方式也是如此，对于许多植物来说，每片叶子从中轴附近生长出来，为了在生长的过程中一直都能最佳地利用空间（要考虑到叶子是一片一片逐渐地生长出来，而不是一下子同时出现的），每片叶子和前一片叶子之间的角度应该是222.5°，这个角度称为“黄金角度”，因为它和整个圆周360°之比是黄金分割数0.618的倒数，而这种生长方式就导致了斐波那契螺旋的产生。向日葵的种子排列形成的斐波那契螺旋有时能达到89，甚至144。1992年，两位法国科学家通过对花瓣形成过程的计算机仿真实验，证实了在系统保持最低能量的状态下，花朵会以斐波那契数列的规律长出花瓣。</p><p>有趣的是：这样一个完全是自然数的数列，通项公式却是用无理数来表达的。而且当n趋向于无穷大时，斐波那契数列前一项与后一项的比值越来越逼近黄金分割比0.618：1÷1 = 1，1÷2 = 0.5，2÷3 = 0.666，…，3÷5 = 0.6，5÷8 = 0.625，…，55÷89 = 0.617977，…，144÷233 = 0.618025，…，46368÷75025 = 0.6180339886……</p><p>越到后面，这些比值越接近黄金分割比：</p><p><img src="https://source.drie.cn/qxsf-images/25.gif" alt="code"><br>斐波那契数列起源于兔子数列，这个现实中的例子让我们真切地感到数学源于生活，生活中我们需要不断地通过现象发现数学问题，而不是为了学习而学习。学习的目的是满足对世界的好奇心，如果我们怀着这样一颗好奇心，或许世界会因你而不同！斐波那契通过兔子繁殖来告诉我们这种数学问题的本质，随着数列项的增加，前一项与后一项之比越来越逼近黄金分割的数值0.618时，我彻底被震惊到了，因为数学可以表达美，这是令我们叹为观止的地方。当数学创造了更多的奇迹时，我们会发现数学本质上是可以回归到自然的，这样的事例让我们感受到数学的美，就像黄金分割、斐波那契数列，如同大自然中的一朵朵小花，散发着智慧的芳香……</p><h3 id="1-4-灵魂之交——马克思手稿中的数学题">1.4　灵魂之交——马克思手稿中的数学题</h3><p>有人抱怨：算法太枯燥、乏味了，看到公式就头晕，无法学下去了。你肯定选择了一条充满荆棘的路。选对方法，你会发现这里是一条充满鸟语花香和欢声笑语的幽径，在这里，你可以和高德纳聊聊，同爱因斯坦喝杯咖啡，与歌德巴赫和角谷谈谈想法，Dijkstra也不错。与世界顶级的大师进行灵魂之交，不问结果，这一过程已足够美妙！</p><p>如果这本书能让多一个人爱上算法，这就足够了！</p><h4 id="趣味故事1-3：马克思手稿中的数学题">趣味故事1-3：马克思手稿中的数学题</h4><p>马克思手稿中有一道趣味数学问题：有30个人，其中有男人、女人和小孩，这些人在一家饭馆吃饭花了50先令；每个男人花3先令，每个女人花2先令，每个小孩花1先令；问男人、女人和小孩各有几人？</p><p>（1）问题分析</p><p>设x、y、z分别代表男人、女人和小孩。按题目的要求，可得到下面的方程：</p><p>x+y+z=30　①</p><p>3x+2y+z=50 ②</p><p>两式相减，②−①得：</p><p>2x+y=20　③</p><p>从式③可以看出，因为x、y为正整数，x最大只能取9，所以x变化范围是1～9。那么我们可以让x从1到9变化，再找满足①②两个条件y、z值，找到后输入即可，答案可能不止一个。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-11。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-11</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> x,y,z,count=<span class="number">0</span>; <span class="comment">//记录可行解的个数</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot; Men，Women，Children&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;........................................&quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  <span class="keyword">for</span>(x=<span class="number">1</span>;x&lt;=<span class="number">9</span>;x++) </span><br><span class="line">  &#123; </span><br><span class="line">    y=<span class="number">20</span><span class="number">-2</span>*x;  <span class="comment">//固定x值然后根据式③求得y值 </span></span><br><span class="line">    z=<span class="number">30</span>-x-y;  <span class="comment">//由式①求得z值 </span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">3</span>*x+<span class="number">2</span>*y+z==<span class="number">50</span>)  <span class="comment">//判断当前得到的一组解是否满足式②</span></span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;++count&lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;x&lt;&lt;y&lt;&lt;z&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//打印出第几个解和解值x，y，z</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>算法完全按照题中方程设计，因此正确性毋庸置疑。那么算法复杂度怎样呢？从算法1-11中可以看出，对算法时间复杂度贡献最大的语句是for(x=1;x&lt;=9;x++)，该语句的执行次数是9，for循环中3条语句的执行次数也为9，其他语句执行次数为1，for语句一共执行36次基本运算，时间复杂度为О(1)。没有使用辅助空间，空间复杂度也为О(1)。</p><p>（4）问题的进一步讨论</p><p>为什么让x变化来确定y、z值？让y变化来确定x、z值会怎样呢？让z变化来确定x、y值行不行？有没有更好的算法降低时间复杂度？</p><h4 id="趣味故事1-4：爱因斯坦的阶梯">趣味故事1-4：爱因斯坦的阶梯</h4><p>爱因斯坦家里有一条长阶梯，若每步跨2阶，则最后剩1阶；若每步跨3阶，则最后剩2阶；若每步跨5阶，则最后剩4阶；若每步跨6阶，则最后剩5阶。只有每次跨7阶，最后才正好1阶不剩。请问这条阶梯共有多少阶？</p><p>（1）问题分析</p><p>根据题意，阶梯数n满足下面一组同余式：</p><p>n≡1(mod2)</p><p>n≡2(mod3)</p><p>n≡4(mod5)</p><p>n≡5(mod6)</p><p>n≡0(mod7)</p><p><strong>注意：</strong> 两个整数a、b，若它们除以整数m所得的余数相等，则称a、b对于模m同余，记作a≡b(mod m)，读作a同余于b模m，或读作a与b关于模m同余。那么只需要判断一个整数值是否满足这5个同余式即可。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-12。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-12</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> n=<span class="number">1</span>; <span class="comment">//n为所设的阶梯数 </span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>))) </span><br><span class="line">      n++;      <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Count the stairs= &quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出阶梯数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>算法的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count the stairs =<span class="number">119</span></span><br></pre></td></tr></table></figure><p>因为n从1开始，找到第一个满足条件的数就停止，所以算法1-12中的while语句运行了119次。有的算法从算法本身无法看出算法的运行次数，例如算法1-12，我们很难知道while语句执行了多少次，因为它是满足条件时停止，那么多少次才能满足条件呢？每个问题具体的次数是不同的，所以不能看到程序中有n，就简单地说它的时间复杂度为n。</p><blockquote><p>我们从1开始一个一个找结果的办法是不是太麻烦了？</p></blockquote><p>（4）算法改进</p><p>因为从上面的5个同余式来看，这个数一定是7的倍数n≡0(mod 7)，除以6余5，除以5余4，除以3余2，除以2余1，我们为什么不从7的倍数开始判断呢？算法改进见算法1-13。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-13</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> n=<span class="number">7</span>; <span class="comment">//n为所设的阶梯数 </span></span><br><span class="line">  <span class="keyword">while</span>(!((n%<span class="number">2</span>==<span class="number">1</span>)&amp;&amp;(n%<span class="number">3</span>==<span class="number">2</span>)&amp;&amp;(n%<span class="number">5</span>==<span class="number">4</span>)&amp;&amp;(n%<span class="number">6</span>==<span class="number">5</span>)&amp;&amp;(n%<span class="number">7</span>==<span class="number">0</span>))) </span><br><span class="line">  n=n+<span class="number">7</span>;      <span class="comment">//判别是否满足一组同余式</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;Count the stairs=&quot;</span>&lt;&lt;n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//输出阶梯数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>算法的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Count the stairs =<span class="number">119</span></span><br></pre></td></tr></table></figure><p>算法1-13中的while语句执行了119/7=17次，可见运行次数减少了不少呢！</p><p>（5）问题的进一步讨论</p><p>此题算法还可考虑求1、2、4、5的最小公倍数n，然后令t=n−1，判断t≡0(mod 7)是否成立，若不成立则t=t+n，再进行判别，直到选出满足条件的t为止。</p><p>1、2、4、5的最小公倍数n=20。</p><p>t=n-1=19，t≡0(mod 7)不成立；</p><p>t= t+n=39，t≡0(mod 7)不成立；</p><p>t= t+n=59，t≡0(mod 7)不成立；</p><p>t= t+n=79，t≡0(mod 7)不成立；</p><p>t= t+n=99，t≡0(mod 7)不成立；</p><p>t= t+n=119，t≡0(mod 7)成立。</p><p>我们可以看到这一算法判断6次即成功，但是，求多个数的最小公倍数需要多少时间复杂度，是不是比上面的算法更优呢？结果如何请大家动手试一试。</p><h4 id="趣味故事1-5：哥德巴赫猜想">趣味故事1-5：哥德巴赫猜想</h4><p>哥德巴赫猜想：任一大于2的偶数，都可表示成两个素数之和。</p><p>验证：2000以内大于2的偶数都能够分解为两个素数之和。</p><p>（1）问题分析</p><p>为了验证哥德巴赫猜想对2000以内大于2的偶数都是成立的，要将整数分解为两部分（两个整数之和），然后判断分解出的两个整数是否均为素数。若是，则满足题意；否则重新进行分解和判断。素数测试的算法可采用试除法，即用2，3，4，…，<img class="my_markdown" src="D:/%25E9%25A1%25B9%25E7%259B%25AE/MarkdownBooks-master/Algorithm/%25E8%25B6%25A3%25E5%25AD%25A6%25E7%25AE%2597%25E6%25B3%2595/images/26.gif" style="width:25px;  height: 19px; "/>去除n，如果能被整除则为合数，不能被整除则为素数。</p><p>（2）算法设计</p><p>按照上面的分析进行算法设计，见算法1-14。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//算法1-14</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;math.h&gt;</span> </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span> n)</span>; <span class="comment">//判断是否均为素数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> </span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> i,n; </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">4</span>;i&lt;=<span class="number">2000</span>;i+=<span class="number">2</span>) <span class="comment">//对2000大于2的偶数分解判断，从4开始，每次增2</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">2</span>;n&lt;i;n++)  <span class="comment">//将偶数i分解为两个整数，一个整数是n，一个是i-n</span></span><br><span class="line">      <span class="keyword">if</span>(prime(n))    <span class="comment">//判断第一个整数是否均为素数 </span></span><br><span class="line">         <span class="keyword">if</span>(prime(i-n))   <span class="comment">//判断第二个整数是否均为素数 </span></span><br><span class="line">         &#123; </span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt; i &lt;&lt;<span class="string">&quot;=&quot;</span> &lt;&lt; n &lt;&lt;<span class="string">&quot;+&quot;</span>&lt;&lt;i-n&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//若均是素数则输出 </span></span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">         &#125; </span><br><span class="line">     <span class="keyword">if</span>(n==i) </span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;error &quot;</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">prime</span><span class="params">(<span class="type">int</span> i)</span> <span class="comment">//判断是否为素数 </span></span><br><span class="line">&#123; </span><br><span class="line">  <span class="type">int</span> j; </span><br><span class="line">  <span class="keyword">if</span>(i&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">if</span>(i==<span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">for</span>(j=<span class="number">2</span>;j&lt;=(<span class="type">int</span>)(<span class="built_in">sqrt</span>((<span class="type">double</span>)i);j++) </span><br><span class="line">    <span class="keyword">if</span>(!(i%j)) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）算法分析</p><p>要验证哥德巴赫猜想对2000以内大于2的偶数都是成立的，我们首先要看看这个范围的偶数有多少个。1～2000中有1000个偶数，1000个奇数，那么大于2的偶数有999个，即i=4，6，8，…，2000。再看偶数分解和素数判断，这就要看最好情况和最坏情况了。最好的情况是一次分解，两次素数判断即可成功，最坏的情况要i−2次分解（即n=2，3，…，i−1的情况），每次分解分别执行2～sqrt(n)次、2～sqrt(i−n)次判断。</p><p>这个程序看似简单合理，但存在下面两个问题。</p><p>1）偶数分解存在重复。</p><ul><li>i=4：分解为（2，2），（3，1），从n=2，3，…，i−1分解，每次得到一组数（n，i−n）。</li><li>i=6：分解为（2，4），（3，3），（4，2），（5，1）。</li><li>i=8：分解为（2，6），（3，5），（4，4），（5，3），（6，2），（7，1）。</li></ul><p>除了最后一项外，每组分解都在i/2处对称分布。最后一组中有一个数为1，1既不是素数也不是合数，因此去掉最后一组，那么我们就可以从n=2，3，…，i/2进行分解，省掉了一半的多余判断。</p><p>2）素数判断存在重复。</p><ul><li>i=4：分解为（2，2），（3，1），要判断2是否为素数，然后判断第二个2是否为素数。判断成功，返回。</li><li>i=6：分解为（2，4），（3，3），（4，2），（5，1），要判断2是否为素数，然后判断4是否为素数，不是继续下一个分解。再判断3是否为素数，然后判断第二个3是否为素数。判断成功，返回。</li></ul><p>每次判断素数都要调用prime函数，那么可以先判断分解有可能得到的数是否为素数，然后把结果存储下来，下次判断时只需要调用上次的结果，不需要再重新判断是否为素数。例如（2，2），第一次判断结果2是素数，那第二个2就不用判断，直接调用这个结果，后面所有的分解，只要遇到这个数就直接认定为这个结果。</p><p>（4）算法改进</p><p>先判断所有分解可能得到的数是否为素数，然后把结果存储下来，有以下两种方法。</p><p>1）用布尔型数组 flag[2…1998]记录分解可能得到的数（2～1998）所有数是不是素数，分解后的值作为下标，调用该数组即可。时间复杂度减少，但空间复杂度增加。</p><p>2）用数值型数组data[302]记录2～1998中所有的素数（302个）。</p><ul><li>分解后的值，采用折半查找（素数数组为有序存储）的办法在素数数组中查找，找到就是素数，否则不是。</li><li>不分解，直接在素数数组中找两个素数之和是否为i，如果找到，验证成功。因为素数数组为有序存储，当两个数相加比i大时，不需要再判断后面的数。</li></ul><p>（5）问题的进一步讨论</p><p>上面的方法可以写出3个算法，大家可以尝试写一写，然后分析时间复杂度、空间复杂度如何？哪个算法更优一些？是不是还可以做到更好？</p><h3 id="1-5-算法学习瓶颈">1.5　算法学习瓶颈</h3><p>很多人感叹：算法为什么这么难！</p><p>一个原因是，算法本身具有一定的复杂性，还有一个原因：讲得不到位！</p><p>算法的教与学有两个困难。</p><p>（1）我们学习了那些经典的算法，在惊叹它们奇妙的同时，难免疑虑重重：这些算法是怎么被想到的？这可能是最费解的地方。高手讲，学算法要学它的来龙去脉，包括种种证明。但这对菜鸟来说，这简直比登天还难，很可能花费很多时间也无法搞清楚。对大多数人来说，这条路是行不通的，那怎么办呢？下功夫去记忆书上的算法？记住这些算法的效率？这样做看似学会了，其实两手空空，遇到一个新问题，仍然无从下手。可这偏偏又是极重要的，无论做研究还是实际工作，一个计算机专业人士最重要的能力就是解决问题——解决那些不断从实际应用中冒出来的新问题。</p><p>（2）算法作为一门学问，有两条几乎平行的线索。一个是 <strong>数据结构</strong> （数据对象）：数、矩阵、集合、串、排列、图、表达式、分布等。另一个是 <strong>算法策略</strong> ：贪心、分治、动态规划、线性规划、搜索等。这两条线索是相互独立的：同一个数据对象（如图）上有不同的问题（如单源最短路径和多源最短路径），就可以用到不同的算法策略（例如贪婪和动态规划）；而完全不同的数据对象上的问题（如排序和整数乘法），也许就会用到相同的算法策略（如分治）。</p><p>两条线索交织在一起，该如何表述？我们早已习惯在一章中完全讲排序，而在另一章中完全讲图论算法。还没有哪一本算法书很好地解决这两个困难，传统的算法书大多注重内容的收录，但却忽视思维过程的展示，因此我们学习了经典的算法，却费解于算法设计的过程。</p><p>本书从问题出发，根据实际问题分析、设计合适的算法策略，然后在数据结构上操作实现，巧妙地将数据结构和算法策略拧成了一条线。通过大量实例，充分展现算法设计的思维过程，让读者充分体会求解问题的思路，如何分析？使用什么算法策略？采用什么数据结构？算法的复杂性如何？是否有优化的可能？</p><p>这里，我们培养的是让读者怀着一颗好奇心去思考问题、解决问题。更重要的是——体会学习的乐趣，发现算法的美！</p><h3 id="1-6-你怕什么">1.6　你怕什么</h3><p>本章主要说明以下问题。</p><p>（1）将程序执行次数作为时间复杂度衡量标准。</p><p>（2）时间复杂度通常用渐近上界符号f(n)表示。</p><p>（3）衡量算法的好坏通常考查算法的最坏情况。</p><p>（4）空间复杂度只计算辅助空间。</p><p>（5）递归算法的空间复杂度要计算递归使用的栈空间。</p><p>（6）设计算法时尽量避免爆炸级增量复杂度。</p><p>通过本章的学习，我们对算法有了初步的认识，算法就在我们的生活中。任何一个算法都不是凭空造出来的，而是来源于实际中的某一个问题，由此推及一类、一系列问题，所以算法的本质是高效地解决实际问题。本章部分内容或许你不是很清楚，不必灰心，还记得我在前言中说的“ <strong>大视野</strong> ， <strong>不求甚解</strong> ”吗？例如斐波那契数列的通项公式推导，不懂没关系，只要知道斐波那契数列用递归算法，时间复杂度是指数阶，这就够了。就像一个面包师一边和面，一边详细讲做好面包要多少面粉、多少酵母、多大火候，如果你对如何做面包非常好奇，大可津津有味地听下去，如果你只是饿了，那么只管吃好了。</p><p>通过算法，你可以与世界顶级大师进行灵魂交流，体会算法的妙处。</p><p>Donald Ervin Knuth说：“程序就是蓝色的诗”。而这首诗的灵魂就是算法，走进算法，你会发现无与伦比的美！</p><p>持之以恒地学习，没有什么是学不会的。行动起来，没有什么不可以！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;第一章-算法之美&quot;&gt;第一章  算法之美&lt;/h3&gt;
&lt;p&gt;如果说数学是皇冠上的一颗明珠，那么算法就是这颗明珠上的光芒，算法让这颗明珠更加熠熠生辉，为科技进步和社会发展照亮了前进的路。数学是美学，算法是艺术。走进算法的人，才能体会它的魅力。&lt;/p&gt;
&lt;p&gt;多年来，我有</summary>
      
    
    
    
    <category term="算法" scheme="https://drie.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Markdown语法与外挂标签写法汇总</title>
    <link href="https://drie.cn/posts/2013454d.html"/>
    <id>https://drie.cn/posts/2013454d.html</id>
    <published>2024-06-30T16:00:00.000Z</published>
    <updated>2024-06-30T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1>1.Markdown语法自带格式</h1><div class="note info flat"><p>参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">Markdown语法图文全面详解(10分钟学会)</a></p></div><div class="note warning flat"><p>注意：此页面偶尔会存在CSS冲突问题!</p></div><h2 id="1-1-代码块">1.1 代码块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">\```shell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br><span class="line">\```</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VSCode终端</span></span><br><span class="line">hexo clean; hexo s</span><br><span class="line">hexo clean; hexo g; hexo d</span><br><span class="line">git add .; git commit -m &quot;npm publish&quot;; npm version patch; </span><br><span class="line">git push</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Cmder终端</span></span><br><span class="line">hexo clean &amp;&amp; hexo s</span><br><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br><span class="line">git add . &amp;&amp; git commit -m &quot;npm publish&quot; &amp;&amp; npm version patch</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-2-多级标题">1.2 多级标题</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># H1</span></span><br><span class="line"><span class="section">## H2</span></span><br><span class="line"><span class="section">### H3</span></span><br><span class="line"><span class="section">#### H4</span></span><br><span class="line"><span class="section">##### H5</span></span><br><span class="line"><span class="section">###### H6</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>见本文章标题!</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-3-文字样式">1.3 文字样式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>下划线演示<span class="language-xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">文字<span class="strong">**加粗**</span>演示</span><br><span class="line"></span><br><span class="line">文字<span class="emphasis">*斜体*</span>演示</span><br><span class="line"></span><br><span class="line">文本<span class="code">`高亮`</span>演示</span><br><span class="line"></span><br><span class="line">文本~~删除~~线演示</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span> = <span class="string">5</span>&gt;</span></span>5号字<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">&quot;黑体&quot;</span>&gt;</span></span>黑体<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">blue</span>&gt;</span></span>蓝色<span class="language-xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">MistyRose</span>&gt;</span></span>这里的背景色是：MistyRosen，此处输入任意想输入的内容<span class="language-xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p><u>下划线演示</u></p><p>文字<strong>加粗</strong>演示</p><p>文字<em>斜体</em>演示</p><p>文本<code>高亮</code>演示</p><p>文本<s>删除</s>线演示</p><p><font size = 5>5号字</font><br><font face="黑体">黑体</font><br><font color=blue>蓝色</font></p><table><tr><td bgcolor=MistyRose>这里的背景色是：MistyRosen，此处输入任意想输入的内容</td></tr></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><div class="note info flat"><p>上述要点可参考:<a href="https://blog.csdn.net/qq_43732429/article/details/108034518">【Markdown语法】字体颜色大小及文字底色设置</a></p></div><h2 id="1-4-引用">1.4 引用</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt;  Java</span></span><br><span class="line"><span class="quote">&gt; 二级引用演示</span></span><br><span class="line"><span class="quote">&gt; MySQL</span></span><br><span class="line"><span class="quote">&gt; &gt;外键</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;事务</span></span><br><span class="line"><span class="quote">&gt; &gt;</span></span><br><span class="line"><span class="quote">&gt; &gt;<span class="strong">**行级锁**</span>(引用内部一样可以用格式)</span></span><br><span class="line"><span class="quote">&gt; </span></span><br><span class="line"><span class="quote">&gt; ....</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><blockquote><p>Java<br>二级引用演示<br>MySQL</p><blockquote><p>外键</p><p>事务</p><p><strong>行级锁</strong>(引用内部一样可以用格式)</p></blockquote><p>…</p></blockquote><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-5-分割线">1.5 分割线</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><hr><hr><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-6-列表-跟空格都可以">1.6 列表(*,+,-跟空格都可以)</h2><h3 id="1-6-1-无序列表">1.6.1 无序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> Java</span><br><span class="line"><span class="bullet">*</span> Python</span><br><span class="line"><span class="bullet">*</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">+</span> Java</span><br><span class="line"><span class="bullet">+</span> Python</span><br><span class="line"><span class="bullet">+</span> ...</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> Java</span><br><span class="line"><span class="bullet">-</span> Python</span><br><span class="line"><span class="bullet">-</span> ...</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><ul><li>Java</li><li>Python</li><li>…</li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h3 id="1-6-2-有序列表">1.6.2 有序列表</h3><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 注意后面有空格</span></span><br><span class="line"><span class="bullet">1.</span> </span><br><span class="line"><span class="bullet">2.</span> </span><br><span class="line"><span class="bullet">3.</span> </span><br><span class="line"><span class="bullet">4.</span> </span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li></li><li></li><li></li><li></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-7-图片">1.7 图片</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 本地图片</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/assets/pusheencode.webp&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;示例图片&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:50%;&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="section"># 在线图片</span></span><br><span class="line">![<span class="string">code</span>](<span class="link">https://cdn.jsdelivr.net/gh/iflidrie/markdown_pic/img/code.png</span>)</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>本地图片:<br><img src="/assets/pusheencode.webp" alt="示例图片" style="zoom:50%;" /><br>在线图片:<br><img src="https://cdn.jsdelivr.net/gh/iflidrie/markdown_pic/img/code.png" alt="code"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-8-表格">1.8 表格</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目标号 | 资金     | 备注 |</span><br><span class="line">| -------- | -------- | ---- |</span><br><span class="line">| 1        | 100，000 | 无   |</span><br><span class="line">| 2        | 200，000 | 无   |</span><br><span class="line">| 3        | 300,600  | 重要 |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th>项目标号</th><th>资金</th><th>备注</th></tr></thead><tbody><tr><td>1</td><td>100，000</td><td>无</td></tr><tr><td>2</td><td>200，000</td><td>无</td></tr><tr><td>3</td><td>300,600</td><td>重要</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="1-9-公式">1.9 公式</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\Gamma(z)=\int<span class="emphasis">_0^\infty t^&#123;z-1&#125;e^&#123;-t&#125;dt.</span></span><br><span class="line"><span class="emphasis">$$</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>$$<br>\Gamma(z)=\int_0^\infty t^{z-1}e^{-t}dt.<br>$$</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h1>2.Butterfly外挂标签</h1><div class="note info flat"><p>这部分参考安知鱼:<a href="https://anzhiy.cn/posts/7d58.html">基于Butterfly的外挂标签引入</a></p></div><h2 id="2-1-行内文本样式-text">2.1 行内文本样式 text</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% u 文本内容 %&#125;</span><br><span class="line">&#123;% emp 文本内容 %&#125;</span><br><span class="line">&#123;% wavy 文本内容 %&#125;</span><br><span class="line">&#123;% del 文本内容 %&#125;</span><br><span class="line">&#123;% kbd 文本内容 %&#125;</span><br><span class="line">&#123;% psw 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 带 &#123;% u 下划线 %&#125; 的文本</span><br><span class="line"><span class="bullet">2.</span> 带 &#123;% emp 着重号 %&#125; 的文本</span><br><span class="line"><span class="bullet">3.</span> 带 &#123;% wavy 波浪线 %&#125; 的文本</span><br><span class="line"><span class="bullet">4.</span> 带 &#123;% del 删除线 %&#125; 的文本</span><br><span class="line"><span class="bullet">5.</span> 键盘样式的文本 &#123;% kbd command %&#125; + &#123;% kbd D %&#125;</span><br><span class="line"><span class="bullet">6.</span> 密码样式的文本：&#123;% psw 这里没有验证码 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-2-行内文本-span">2.2 行内文本 span</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% span 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% span red, 红色 %&#125;、&#123;% span yellow, 黄色 %&#125;、&#123;% span green, 绿色 %&#125;、&#123;% span cyan, 青色 %&#125;、&#123;% span blue, 蓝色 %&#125;、&#123;% span gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% span center logo large, Volantis %&#125;</span><br><span class="line">&#123;% span center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<span class='p red'>红色</span>、<span class='p yellow'>黄色</span>、<span class='p green'>绿色</span>、<span class='p cyan'>青色</span>、<span class='p blue'>蓝色</span>、<span class='p gray'>灰色</span>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。<br><span class='p center logo large'>Volantis</span><br><span class='p center small'>A Wonderful Theme for Hexo</span></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-3-段落文本-p">2.3 段落文本 p</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% p 样式参数(参数以空格划分), 文本内容 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>字体</code>: logo, code</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>大小</code>: small, h4, h3, h2, h1, large, huge, ultra</li><li><code>对齐方向</code>: left, center, right</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 彩色文字</span><br><span class="line">在一段话中方便插入各种颜色的标签，包括：&#123;% p red, 红色 %&#125;、&#123;% p yellow, 黄色 %&#125;、&#123;% p green, 绿色 %&#125;、&#123;% p cyan, 青色 %&#125;、&#123;% p blue, 蓝色 %&#125;、&#123;% p gray, 灰色 %&#125;。</span><br><span class="line"><span class="bullet">-</span> 超大号文字</span><br><span class="line">文档「开始」页面中的标题部分就是超大号文字。</span><br><span class="line">&#123;% p center logo large, Volantis %&#125;</span><br><span class="line">&#123;% p center small, A Wonderful Theme for Hexo %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><ul><li>彩色文字<br>在一段话中方便插入各种颜色的标签，包括：<p class='p red'>红色</p>、<p class='p yellow'>黄色</p>、<p class='p green'>绿色</p>、<p class='p cyan'>青色</p>、<p class='p blue'>蓝色</p>、<p class='p gray'>灰色</p>。</li><li>超大号文字<br>文档「开始」页面中的标题部分就是超大号文字。</li></ul><p class='p center logo large'>Volantis</p><p class='p center small'>A Wonderful Theme for Hexo</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-4-引用note">2.4 引用note</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">通用配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">语法格式</button></li><li class="tab"><button type="button" data-href="#分栏-3">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-4">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-5">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">note:</span><br><span class="line">  # Note tag style values:</span><br><span class="line">  #  - simple    bs-callout old alert style. Default.</span><br><span class="line">  #  - modern    bs-callout new (v2-v3) alert style.</span><br><span class="line">  #  - flat      flat callout style with background, like on Mozilla or StackOverflow.</span><br><span class="line">  #  - disabled  disable all CSS styles import of note tag.</span><br><span class="line">  style: simple</span><br><span class="line">  icons: false</span><br><span class="line">  border<span class="emphasis">_radius: 3</span></span><br><span class="line"><span class="emphasis">  # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).</span></span><br><span class="line"><span class="emphasis">  # Offset also applied to label tag variables. This option can work with disabled note tag.</span></span><br><span class="line"><span class="emphasis">  light_</span>bg<span class="emphasis">_offset: 0</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 自带icon</span></span><br><span class="line">&#123;% note [class] [no-icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"><span class="section"># 外部icon</span></span><br><span class="line">&#123;% note [color] [icon] [style] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.自带icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / primary / success / info / warning / danger ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】不显示 icon</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><p>2.外部icon</p><table><thead><tr><th>参数</th><th style="text-align:center">用法</th></tr></thead><tbody><tr><td>class</td><td style="text-align:center">【可选】标识，不同的标识有不同的配色 （ default / blue / pink / red / purple / orange / green ）</td></tr><tr><td>no-icon</td><td style="text-align:center">【可选】可配置自定义 icon (只支持 fontawesome 图标, 也可以配置 no-icon )</td></tr><tr><td>style</td><td style="text-align:center">【可选】可以覆盖配置中的 style （simple/modern/flat/disabled）</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note simple %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default simple %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary simple %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success simple %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info simple %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning simple %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger simple %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note modern %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default modern %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary modern %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success modern %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info modern %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning modern %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger modern %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note flat %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default flat %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary flat %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success flat %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info flat %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning flat %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger flat %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note disabled %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default disabled %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary disabled %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success disabled %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info disabled %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning disabled %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger disabled %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;默认 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note default no-icon %&#125;default 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary no-icon %&#125;primary 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success no-icon %&#125;success 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info no-icon %&#125;info 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning no-icon %&#125;warning 提示块标签&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger no-icon %&#125;danger 提示块标签&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; simple %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; simple %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; simple%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; simple %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; simple %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; simple %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>2.<code>modern</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; modern %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; modern%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; modern %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; modern %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; modern %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>3.<code>flat</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; flat %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; flat %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; flat%&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; flat %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; flat %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; flat %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>4.<code>disabled</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note &#x27;fab fa-cc-visa&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue &#x27;fas fa-bullhorn&#x27; disabled %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink &#x27;fas fa-car-crash&#x27; disabled %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red &#x27;fas fa-fan&#x27; disabled %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange &#x27;fas fa-battery-half&#x27; disabled %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple &#x27;far fa-hand-scissors&#x27; disabled %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green &#x27;fab fa-internet-explorer&#x27; disabled %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p>5.<code>no-icon</code>样式</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note blue no-icon %&#125;2021年快到了....&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note pink no-icon %&#125;小心开车 安全至上&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note red no-icon %&#125;这是三片呢？还是四片？&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note orange no-icon %&#125;你是刷 Visa 还是 UnionPay&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note purple no-icon %&#125;剪刀石头布&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note green no-icon %&#125;前端最讨厌的浏览器&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-5"><details class="folding-tag" blue><summary> 1.自带icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note simple"><p>默认 提示块标签</p></div><div class="note default simple"><p>default 提示块标签</p></div><div class="note primary simple"><p>primary 提示块标签</p></div><div class="note success simple"><p>success 提示块标签</p></div><div class="note info simple"><p>info 提示块标签</p></div><div class="note warning simple"><p>warning 提示块标签</p></div><div class="note danger simple"><p>danger 提示块标签</p></div>2.`modern`样式<div class="note modern"><p>默认 提示块标签</p></div><div class="note default modern"><p>default 提示块标签</p></div><div class="note primary modern"><p>primary 提示块标签</p></div><div class="note success modern"><p>success 提示块标签</p></div><div class="note info modern"><p>info 提示块标签</p></div><div class="note warning modern"><p>warning 提示块标签</p></div><div class="note danger modern"><p>danger 提示块标签</p></div><p>3.<code>flat</code>样式</p><div class="note flat"><p>默认 提示块标签</p></div><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><p>4.<code>disabled</code>样式</p><div class="note disabled"><p>默认 提示块标签</p></div><div class="note default disabled"><p>default 提示块标签</p></div><div class="note primary disabled"><p>primary 提示块标签</p></div><div class="note success disabled"><p>success 提示块标签</p></div><div class="note info disabled"><p>info 提示块标签</p></div><div class="note warning disabled"><p>warning 提示块标签</p></div><div class="note danger disabled"><p>danger 提示块标签</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>默认 提示块标签</p></div><div class="note default no-icon flat"><p>default 提示块标签</p></div><div class="note primary no-icon flat"><p>primary 提示块标签</p></div><div class="note success no-icon flat"><p>success 提示块标签</p></div><div class="note info no-icon flat"><p>info 提示块标签</p></div><div class="note warning no-icon flat"><p>warning 提示块标签</p></div><div class="note danger no-icon flat"><p>danger 提示块标签</p></div>              </div>            </details><details class="folding-tag" blue><summary> 2.外部icon </summary>              <div class='content'>              <p>1.<code>simple</code>样式</p><div class="note icon-padding simple"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding simple"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding simple"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding simple"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding simple"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding simple"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding simple"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>2.<code>modern</code>样式</p><div class="note icon-padding modern"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding modern"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding modern"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding modern"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding modern"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>3.<code>flat</code>样式</p><div class="note icon-padding flat"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding flat"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding flat"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding flat"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding flat"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding flat"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding flat"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>4.<code>disabled</code>样式</p><div class="note icon-padding disabled"><i class="note-icon fab fa-cc-visa"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue icon-padding disabled"><i class="note-icon fas fa-bullhorn"></i><p>2021年快到了…</p></div><div class="note pink icon-padding disabled"><i class="note-icon fas fa-car-crash"></i><p>小心开车 安全至上</p></div><div class="note red icon-padding disabled"><i class="note-icon fas fa-fan"></i><p>这是三片呢？还是四片？</p></div><div class="note orange icon-padding disabled"><i class="note-icon fas fa-battery-half"></i><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple icon-padding disabled"><i class="note-icon far fa-hand-scissors"></i><p>剪刀石头布</p></div><div class="note green icon-padding disabled"><i class="note-icon fab fa-internet-explorer"></i><p>前端最讨厌的浏览器</p></div><p>5.<code>no-icon</code>样式</p><div class="note no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note blue no-icon flat"><p>2021年快到了…</p></div><div class="note pink no-icon flat"><p>小心开车 安全至上</p></div><div class="note red no-icon flat"><p>这是三片呢？还是四片？</p></div><div class="note orange no-icon flat"><p>你是刷 Visa 还是 UnionPay</p></div><div class="note purple no-icon flat"><p>剪刀石头布</p></div><div class="note green no-icon flat"><p>前端最讨厌的浏览器</p></div>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-5-上标标签-tip">2.5 上标标签 tip</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: success,error,warning,bolt,ban,home,sync,cogs,key,bell</li><li><code>自定义图标</code>: 支持fontawesome。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip %&#125;default&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip info %&#125;info&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip success %&#125;success&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip error %&#125;error&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip warning %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bolt %&#125;bolt&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban %&#125;ban&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip home %&#125;home&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip sync %&#125;sync&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip cogs %&#125;cogs&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip key %&#125;key&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip bell %&#125;bell&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip fa-atom %&#125;自定义font awesome图标&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="tip "><p>default</p></div><div class="tip info"><p>info</p></div><div class="tip success"><p>success</p></div><div class="tip error"><p>error</p></div><div class="tip warning"><p>warning</p></div><div class="tip bolt"><p>bolt</p></div><div class="tip ban"><p>ban</p></div><div class="tip home"><p>home</p></div><div class="tip sync"><p>sync</p></div><div class="tip cogs"><p>cogs</p></div><div class="tip key"><p>key</p></div><div class="tip bell"><p>bell</p></div><div class="tip fa-atom"><p>自定义font awesome图标</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-6-动态标签-anima">2.6 动态标签 anima</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip [参数，可选] %&#125;文本内容&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><div class="note info flat"><ol><li>将所需的CSS类添加到图标（或DOM中的任何元素）。</li><li>对于父级悬停样式，需要给目标元素添加指定CSS类，同时还要给目标元素的父级元素添加CSS类<code>faa-parent animated-hover</code>。（详情见示例及示例源码）<br>You can regulate the speed of the animation by adding the CSS class or . faa-fastfaa-slow</li><li>可以通过给目标元素添加CSS类<code>faa-fast</code>或<code>faa-slow</code>来控制动画快慢。</li></ol></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.On DOM load（当页面加载时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>2.调整动画速度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated faa-fast %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated faa-slow %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>3.On hover（当鼠标悬停时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-horizontal animated-hover %&#125;warning&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-flash animated-hover %&#125;ban&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><p>4.On parent hover（当鼠标悬停在父级元素时显示动画）</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tip warning faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-horizontal&quot;</span>&gt;</span></span>warning<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br><span class="line">&#123;% tip ban faa-parent animated-hover %&#125;<span class="language-xml"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;faa-flash&quot;</span>&gt;</span></span>ban<span class="language-xml"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span>&#123;% endtip %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.On DOM load（当页面加载时显示动画）</p><div class="tip warning faa-horizontal animated"><p>warning</p></div><div class="tip ban faa-flash animated"><p>ban</p></div>2.调整动画速度<div class="tip warning faa-horizontal animated faa-fast"><p>warning</p></div><div class="tip ban faa-flash animated faa-slow"><p>ban</p></div>3.On hover（当鼠标悬停时显示动画）<div class="tip warning faa-horizontal animated-hover"><p>warning</p></div><div class="tip ban faa-flash animated-hover"><p>ban</p></div>4.On parent hover（当鼠标悬停在父级元素时显示动画）<div class="tip warning faa-parent animated-hover"><p class="faa-horizontal">warning</p></div><div class="tip ban faa-parent animated-hover"><p class="faa-flash">ban</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-7-复选列表-checkbox">2.7 复选列表 checkbox</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>样式</code>: plus, minus, times</li><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% checkbox 纯文本测试 %&#125;</span><br><span class="line">&#123;% checkbox checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% checkbox red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% checkbox green checked, 绿色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox yellow checked, 黄色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox cyan checked, 青色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox blue checked, 蓝色 + 默认选中 %&#125;</span><br><span class="line">&#123;% checkbox plus green checked, 增加 %&#125;</span><br><span class="line">&#123;% checkbox minus yellow checked, 减少 %&#125;</span><br><span class="line">&#123;% checkbox times red checked, 叉 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="checkbox" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="checkbox" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="checkbox" />            <p>支持自定义颜色</p>            </div><div class='checkbox green checked'><input type="checkbox" checked="checked"/>            <p>绿色 + 默认选中</p>            </div><div class='checkbox yellow checked'><input type="checkbox" checked="checked"/>            <p>黄色 + 默认选中</p>            </div><div class='checkbox cyan checked'><input type="checkbox" checked="checked"/>            <p>青色 + 默认选中</p>            </div><div class='checkbox blue checked'><input type="checkbox" checked="checked"/>            <p>蓝色 + 默认选中</p>            </div><div class='checkbox plus green checked'><input type="checkbox" checked="checked"/>            <p>增加</p>            </div><div class='checkbox minus yellow checked'><input type="checkbox" checked="checked"/>            <p>减少</p>            </div><div class='checkbox times red checked'><input type="checkbox" checked="checked"/>            <p>叉</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-8-单选列表-radio">2.8 单选列表 radio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 样式参数（可选）, 文本（支持简单md） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>颜色</code>: red,yellow,green,cyan,blue,gray</li><li><code>选中状态</code>: checked</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% radio 纯文本测试 %&#125;</span><br><span class="line">&#123;% radio checked, 支持简单的 [<span class="string">markdown</span>](<span class="link">https://guides.github.com/features/mastering-markdown/</span>) 语法 %&#125;</span><br><span class="line">&#123;% radio red, 支持自定义颜色 %&#125;</span><br><span class="line">&#123;% radio green, 绿色 %&#125;</span><br><span class="line">&#123;% radio yellow, 黄色 %&#125;</span><br><span class="line">&#123;% radio cyan, 青色 %&#125;</span><br><span class="line">&#123;% radio blue, 蓝色 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-9-时间轴-timeline">2.9 时间轴 timeline</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间线标题（可选）[,color] %&#125;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&lt;!-- timeline 时间节点（标题） --&gt;</span><br><span class="line">正文内容</span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>title</code>:标题/时间线</li><li><code>color</code>:<code>timeline</code>颜色:default(留空) / blue / pink / red / purple / orange / green</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;% timeline 时间轴样式,blue %&#125;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-07-24 [<span class="string">2.6.6 -&gt; 3.0</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 如果有 <span class="code">`hexo-lazyload-image`</span> 插件，需要删除并重新安装最新版本，设置 <span class="code">`lazyload.isSPA: true`</span>。</span><br><span class="line"><span class="bullet">2.</span> 2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <span class="code">`use_cdn: true`</span> 则需要删除。</span><br><span class="line"><span class="bullet">3.</span> 2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</span><br><span class="line"><span class="bullet">4.</span> 2.x 版本的置顶 <span class="code">`top: true`</span> 改为了 <span class="code">`pin: true`</span>，并且同样适用于 <span class="code">`layout: page`</span> 的页面。</span><br><span class="line"><span class="bullet">5.</span> 如果使用了 <span class="code">`hexo-offline`</span> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-05-15 [<span class="string">2.6.3 -&gt; 2.6.6</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6</span>) --&gt;</span><br><span class="line"></span><br><span class="line">不需要额外处理。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- timeline 2020-04-20 [<span class="string">2.6.2 -&gt; 2.6.3</span>](<span class="link">https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3</span>) --&gt;</span><br><span class="line"></span><br><span class="line"><span class="bullet">1.</span> 全局搜索 <span class="code">`seotitle`</span> 并替换为 <span class="code">`seo_title`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的索引规则有变，使用 group 组件的文章内，<span class="code">`group: group_name`</span> 对应的组件名必须是 <span class="code">`group_name`</span>。</span><br><span class="line"><span class="bullet">2.</span> group 组件的列表名优先显示文章的 <span class="code">`short_title`</span> 其次是 <span class="code">`title`</span>。</span><br><span class="line"></span><br><span class="line">&lt;!-- endtimeline --&gt;</span><br><span class="line"></span><br><span class="line">&#123;% endtimeline %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="timeline blue"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>时间轴样式</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-07-24 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases">2.6.6 -&gt; 3.0</a></p></div></div><div class='timeline-item-content'><ol><li>如果有 <code>hexo-lazyload-image</code> 插件，需要删除并重新安装最新版本，设置 <code>lazyload.isSPA: true</code>。</li><li>2.x 版本的 css 和 js 不适用于 3.x 版本，如果使用了 <code>use_cdn: true</code> 则需要删除。</li><li>2.x 版本的 fancybox 标签在 3.x 版本中被重命名为 gallery 。</li><li>2.x 版本的置顶 <code>top: true</code> 改为了 <code>pin: true</code>，并且同样适用于 <code>layout: page</code> 的页面。</li><li>如果使用了 <code>hexo-offline</code> 插件，建议卸载，3.0 版本默认开启了 pjax 服务。</li></ol></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-05-15 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.6">2.6.3 -&gt; 2.6.6</a></p></div></div><div class='timeline-item-content'><p>不需要额外处理。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>2020-04-20 <a href="https://github.com/volantis-x/hexo-theme-volantis/releases/tag/2.6.3">2.6.2 -&gt; 2.6.3</a></p></div></div><div class='timeline-item-content'><ol><li>全局搜索 <code>seotitle</code> 并替换为 <code>seo_title</code>。</li><li>group 组件的索引规则有变，使用 group 组件的文章内，<code>group: group_name</code> 对应的组件名必须是 <code>group_name</code>。</li><li>group 组件的列表名优先显示文章的 <code>short_title</code> 其次是 <code>title</code>。</li></ol></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-10-链接卡片-link">2.10 链接卡片 link</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 标题, 链接, 图片链接（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link 糖果屋教程贴, https://akilar.top/posts/615e2dec/, https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="https://cdn.cbd.int/akilar-candyassets@1.0.36/image/siteicon/favicon.ico"/></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-11-按钮-btns">2.11 按钮 btns</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns 样式参数 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% cell 标题, 链接, 图片或者图标 %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>圆角样式：rounded, circle</li><li>增加文字样式：可以在容器内增加 <code>&lt;b&gt;</code>标题<code>&lt;/b&gt;</code>和<code>&lt;p&gt;</code>描述文字<code>&lt;/p&gt;</code></li><li>布局方式：<br>默认为自动宽度，适合视野内只有一两个的情况。</li></ol><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>wide</td><td>宽一点的按钮</td></tr><tr><td>fill</td><td>填充布局，自动铺满至少一行，多了会换行</td></tr><tr><td>center</td><td>居中，按钮之间是固定间距</td></tr><tr><td>around</td><td>居中分散</td></tr><tr><td>grid2</td><td>等宽最多2列，屏幕变窄会适当减少列数</td></tr><tr><td>grid3</td><td>等宽最多3列，屏幕变窄会适当减少列数</td></tr><tr><td>grid4</td><td>等宽最多4列，屏幕变窄会适当减少列数</td></tr><tr><td>grid5</td><td>等宽最多5列，屏幕变窄会适当减少列数</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle grid5 %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% cell ifli, https://ifli.cn, https://source.drie.cn/img/avatar.png %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>2.或者含有图标的按钮</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns rounded grid5 %&#125;</span><br><span class="line">&#123;% cell 下载源码, /, fas fa-download %&#125;</span><br><span class="line">&#123;% cell 查看文档, /, fas fa-book-open %&#125;</span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><p>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btns circle center grid5 %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p red, 专业版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/avatar.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1&#x27;</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">&#x27;fab fa-apple&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>心率管家<span class="language-xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span></span><br><span class="line">  &#123;% p green, 免费版 %&#125;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/avatar.png&#x27;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line">&#123;% endbtns %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.如果需要显示类似「团队成员」之类的一组含有头像的链接</p><div class="btns circle grid5">            <a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a><a class="button" href='https://ifli.cn' title='ifli'><img src='https://source.drie.cn/img/avatar.png'>ifli</a>          </div>2.或者含有图标的按钮<div class="btns rounded grid5">            <a class="button" href='/' title='下载源码'><i class='fas fa-download'></i>下载源码</a><a class="button" href='/' title='查看文档'><i class='fas fa-book-open'></i>查看文档</a>          </div>3.圆形图标 + 标题 + 描述 + 图片 + 网格5列 + 居中<div class="btns circle center grid5">            <a href='https://apps.apple.com/cn/app/heart-mate-pro-hrm-utility/id1463348922?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p red'>专业版</p>  <img src='https://source.drie.cn/img/avatar.png'></a><a href='https://apps.apple.com/cn/app/heart-mate-lite-hrm-utility/id1475747930?ls=1'>  <i class='fab fa-apple'></i>  <b>心率管家</b>  <p class='p green'>免费版</p>  <img src='https://source.drie.cn/img/avatar.png'></a>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-12-github卡片-ghcard">2.12 github卡片 ghcard</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% ghcard 用户名, 其它参数（可选） %&#125;</span><br><span class="line">&#123;% ghcard 用户名/仓库, 其它参数（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><p>使用<code>,</code>分割各个参数。写法为：<code>参数名=参数值</code><br>以下只写几个常用参数值。</p><table><thead><tr><th><strong>参数名</strong></th><th>取值</th><th>释义</th></tr></thead><tbody><tr><td>hide</td><td>stars,commits,prs,issues,contribs</td><td>隐藏指定统计</td></tr><tr><td>count_private</td><td>true</td><td>将私人项目贡献添加到总提交计数中</td></tr><tr><td>show_icons</td><td>true</td><td>显示图标</td></tr><tr><td>theme</td><td>查阅:<a href="https://github.com/anuraghazra/github-readme-stats/blob/master/themes/README.md">Available Themes</a></td><td>主题</td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.用户信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard iflidrie %&#125; | &#123;% ghcard iflidrie, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=buefy %&#125; | &#123;% ghcard iflidrie, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=onedark %&#125; | &#123;% ghcard iflidrie, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard iflidrie, theme=algolia %&#125; | &#123;% ghcard iflidrie, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><p>2.仓库信息卡片</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=vue %&#125; |</span><br><span class="line">| -- | -- |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=buefy %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-light %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=onedark %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=solarized-dark %&#125; |</span><br><span class="line">| &#123;% ghcard volantis-x/hexo-theme-volantis, theme=algolia %&#125; | &#123;% ghcard volantis-x/hexo-theme-volantis, theme=calm %&#125; |</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.用户信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/iflidrie"><img src="https://github-readme-stats.vercel.app/api/?username=iflidrie&theme=calm&show_owner=true"/></a></td></tr></tbody></table><p>2.仓库信息卡片</p><table><thead><tr><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&show_owner=true"/></a></th><th><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=vue&show_owner=true"/></a></th></tr></thead><tbody><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=buefy&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-light&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=onedark&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=solarized-dark&show_owner=true"/></a></td></tr><tr><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=algolia&show_owner=true"/></a></td><td><a class="ghcard" rel="external nofollow noopener noreferrer" href="https://github.com/volantis-x/hexo-theme-volantis"><img src="https://github-readme-stats.vercel.app/api/pin/?username=volantis-x&repo=hexo-theme-volantis&theme=calm&show_owner=true"/></a></td></tr></tbody></table><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-13-github徽标-ghbdage">2.13 github徽标 ghbdage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage [right],[left],[logo]||[color],[link],[title]||[option] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>left</code>：徽标左边的信息，必选参数。</li><li><code>right</code>: 徽标右边的信息，必选参数，</li><li><code>logo</code>：徽标图标，图标名称详见<a href="https://simpleicons.org/">simpleicons</a>，可选参数。</li><li><code>color</code>：徽标右边的颜色，可选参数。</li><li><code>link</code>：指向的链接，可选参数。</li><li><code>title</code>：徽标的额外信息，可选参数。主要用于优化SEO，但<code>object</code>标签不会像<code>a</code>标签一样在鼠标悬停显示<code>title</code>信息。</li><li><code>option</code>：自定义参数，支持<a href="https://shields.io/">shields.io</a>的全部API参数支持，具体参数可以参看上文中的拓展写法示例。形式为<code>name1=value2&amp;name2=value2</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.基本参数,定义徽标左右文字和图标</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Theme,Butterfly %&#125;</span><br><span class="line">&#123;% bdage Frame,Hexo,hexo %&#125;</span><br></pre></td></tr></table></figure><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage CDN,JsDelivr,jsDelivr||abcdef,https://metroui.org.ua/index.html,本站使用JsDelivr为静态资源提供CDN加速 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割</span><br><span class="line">&#123;% bdage Source,GitHub,GitHub||,https://github.com/ %&#125;</span><br></pre></td></tr></table></figure><p>3.拓展参数，支持shields的API的全部参数内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bdage Hosted,Vercel,Vercel||brightgreen,https://vercel.com/,本站采用双线部署，默认线路托管于Vercel||style=social&amp;logoWidth=20 %&#125;</span><br><span class="line">//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割</span><br><span class="line">&#123;% bdage Hosted,Vercel,Vercel||||style=social&amp;logoWidth=20&amp;logoColor=violet %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.基本参数,定义徽标左右文字和图标</p><p><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Butterfly-Theme-orange?logo=&color=orange&link=&"></object><br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Hexo-Frame-orange?logo=hexo&color=orange&link=&"></object></p><p>2.信息参数，定义徽标右侧内容背景色，指向链接</p><p><object class="ghbdage" style="margin-inline:5px" title="本站使用JsDelivr为静态资源提供CDN加速" standby="loading..." data="https://img.shields.io/badge/JsDelivr-CDN-orange?logo=jsDelivr&color=abcdef&link=https://metroui.org.ua/index.html&"></object><br>//如果是跨顺序省略可选参数，仍然需要写个逗号,用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/GitHub-Source-orange?logo=GitHub&color=orange&link=https://github.com/&"></object></p><p>3.拓展参数，支持shields的API的全部参数内容</p><p><object class="ghbdage" style="margin-inline:5px" title="本站采用双线部署，默认线路托管于Vercel" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=brightgreen&link=https://vercel.com/&style=social&logoWidth=20"></object><br>//如果是跨顺序省略可选参数组，仍然需要写双竖线||用作分割<br><object class="ghbdage" style="margin-inline:5px" title="" standby="loading..." data="https://img.shields.io/badge/Vercel-Hosted-orange?logo=Vercel&color=orange&link=&style=social&logoWidth=20&logoColor=violet"></object></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-14-网站卡片-sites">2.14 网站卡片 sites</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% site 标题, url=链接, screenshot=截图链接, avatar=头像链接（可选）, description=描述（可选） %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% sitegroup %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=简约风格 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% site ifli, url=https://ifli.cn, screenshot=https://source.drie.cn/siteshot/ifli.cn.jpg, avatar=https://source.drie.cn/img/avatar.png, description=这是一段关于这个网站的描述文字 %&#125;</span><br><span class="line">&#123;% endsitegroup %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="site-card-group"><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">简约风格</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a><a class="site-card" href="https://ifli.cn"><div class="img"><img src="https://source.drie.cn/siteshot/ifli.cn.jpg"/></div><div class="info"><img src="https://source.drie.cn/img/avatar.png"/><span class="title">ifli</span><span class="desc">这是一段关于这个网站的描述文字</span></div></a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-15-行内图片-inlineimage">2.15 行内图片 inlineimage</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% inlineimage 图片链接, height=高度（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>高度</code>：height=20px</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是 &#123;% inlineimage https://source.drie.cn/img/avatar.gif %&#125; 一段话。</span><br><span class="line"></span><br><span class="line">这又是 &#123;% inlineimage https://source.drie.cn/img/avatar.gif, height=40px %&#125; 一段话。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>这是 <img no-lazy class="inline" src="https://source.drie.cn/img/avatar.gif" style="height:1.5em"/> 一段话。</p><p>这又是 <img no-lazy class="inline" src="https://source.drie.cn/img/avatar.gif" style="height:40px;"/> 一段话。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-16-单张图片-image">2.16 单张图片 image</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image 链接, width=宽度（可选）, height=高度（可选）, alt=描述（可选）, bg=占位颜色（可选） %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>图片宽度高度：width=300px, height=32px</li><li>图片描述：alt=图片描述（butterfly需要在主题配置文件中开启图片描述）</li><li>占位背景色：bg=#f2f2f2</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>2.指定宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px %&#125;</span><br></pre></td></tr></table></figure><p>3.指定宽度并添加描述：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px, alt=每天下课回宿舍的路，没有什么故事。 %&#125;</span><br></pre></td></tr></table></figure><p>4.设置占位背景色：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% image https://source.drie.cn/siteshot/ifli.cn.jpg, width=400px, bg=#1D0C04, alt=优化不同宽度浏览的观感 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.添加描述：</p><div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="每天下课回宿舍的路，没有什么故事。"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>2..指定宽度<div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" style="width:400px;"/></div></div>3.指定宽度并添加描述：<div class="img-wrap"><div class="img-bg"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="每天下课回宿舍的路，没有什么故事。" style="width:400px;"/></div><span class="image-caption">每天下课回宿舍的路，没有什么故事。</span></div>4.设置占位背景色：<div class="img-wrap"><div class="img-bg" style="background:#1D0C04"><img class="img" src="https://source.drie.cn/siteshot/ifli.cn.jpg" alt="优化不同宽度浏览的观感" style="width:400px;"/></div><span class="image-caption">优化不同宽度浏览的观感</span></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-17-音频-audio">2.17 音频 audio</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio 音频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% audio https://source.drie.cn/badge/Lumia1020.mp3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class="audio"><audio controls preload><source src='https://source.drie.cn/badge/Lumia1020.mp3' type='audio/mp3'>Your browser does not support the audio tag.</audio></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-18-视频-video">2.18 视频 video</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video 视频链接 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>对齐方向</code>：left, center, right</li><li><code>列数</code>：逗号后面直接写列数，支持 1 ～ 4 列。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.100%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br></pre></td></tr></table></figure><p>2.50%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 2 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><p>3.25%宽度</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% videos, 4 %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG<span class="emphasis">_0341.mov %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% video https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_</span>0341.mov %&#125;</span><br><span class="line">&#123;% endvideos %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.100%宽度</p><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div>2.50%宽度<div class="videos" col='2'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div>3.25%宽度<div class="videos" col='4'><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div><div class="video"><video controls preload><source src='https://github.com/volantis-x/volantis-docs/releases/download/assets/IMG_0341.mov' type='video/mp4'>Your browser does not support the video tag.</video></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-19-相册-gallery">2.19 相册 gallery</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 圖片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ul><li>gallerygroup 相册图库</li></ul><table><thead><tr><th>参数名</th><th>释义</th></tr></thead><tbody><tr><td>name</td><td>图库名字</td></tr><tr><td>description</td><td>图库描述</td></tr><tr><td>link</td><td>链接到对应相册的地址</td></tr><tr><td>img-url</td><td>图库封面</td></tr></tbody></table><ul><li><p>gallery 相册</p><p>区别于旧版的Gallery相册,新的Gallery相册会自动根据图片长度进行排版，书写也更加方便，与markdown格式一样。可根据需要插入到相应的md。无需再自己配置长宽。<strong>建议在粘贴时故意使用长短、大小、横竖不一的图片</strong>，会有更好的效果。（尺寸完全相同的图片只会平铺输出，效果很糟糕）</p></li></ul><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup 风景1 春意盎然 &#x27;/gallery/风景1/&#x27; https://source.drie.cn/img/default<span class="emphasis">_cover_</span>1.webp %&#125;</span><br><span class="line">&#123;% galleryGroup 风景2 秋高气爽 &#x27;/gallery/风景2/&#x27; https://source.drie.cn/img/dark<span class="emphasis">_mode.webp %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% galleryGroup 卡通人物 漫画人物 &#x27;/gallery/卡通人物/&#x27; https://source.drie.cn/img/default_</span>cover<span class="emphasis">_209.webp %&#125;</span></span><br><span class="line"><span class="emphasis"><span class="language-xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br></pre></td></tr></table></figure><p>2.gallery 相册</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg</span>)</span><br><span class="line">![](<span class="link">https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg</span>)</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.gallerygroup 相册图库</p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/default_cover_1.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">风景1</div>  <p>春意盎然</p>  <a href='/gallery/%E9%A3%8E%E6%99%AF1/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/dark_mode.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">风景2</div>  <p>秋高气爽</p>  <a href='/gallery/%E9%A3%8E%E6%99%AF2/'></a>  </figcaption>  </figure>  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://source.drie.cn/img/default_cover_209.webp' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">卡通人物</div>  <p>漫画人物</p>  <a href='/gallery/%E5%8D%A1%E9%80%9A%E4%BA%BA%E7%89%A9/'></a>  </figcaption>  </figure></div>2.gallery 相册<div class="fj-gallery"><p><img src="https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg" alt=""><br><img src="https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg" alt=""></p>          </div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-20-折叠框-folding">2.20 折叠框 folding</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><p>1.gallerygroup 相册图库</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 参数（可选）, 标题 %&#125;</span><br><span class="line">![](<span class="link">https://source.drie.cn/img/default_cover_177.webp</span>)</span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><!-- tab 参数配置 --><ol><li><p><code>颜色</code>：blue, cyan, green, yellow, red</p></li><li><p><code>状态</code>：状态填写 open 代表默认打开。</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#123;% folding 查看图片测试 %&#125;</span><br><span class="line"></span><br><span class="line">![](<span class="link">https://source.drie.cn/img/default_cover_177.webp</span>)</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding cyan open, 查看默认打开的折叠框 %&#125;</span><br><span class="line"></span><br><span class="line">这是一个默认打开的折叠框。</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding green, 查看代码测试 %&#125;</span><br><span class="line">假装这里有代码块（代码块没法嵌套代码块）</span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding yellow, 查看列表测试 %&#125;</span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> haha</span><br><span class="line"><span class="bullet">-</span> hehe</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding red, 查看嵌套测试 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding blue, 查看嵌套测试2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% folding 查看嵌套测试3 %&#125;</span><br><span class="line"></span><br><span class="line">hahaha <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#x27;https://source.drie.cn/img/cat.png&#x27;</span> <span class="attr">style</span>=<span class="string">&#x27;height:24px&#x27;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% endfolding %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><details class="folding-tag" ><summary> 查看图片测试 </summary>              <div class='content'>              <p><img src="https://source.drie.cn/img/default_cover_177.webp" alt=""></p>              </div>            </details><details class="folding-tag" cyan open><summary> 查看默认打开的折叠框 </summary>              <div class='content'>              <p>这是一个默认打开的折叠框。</p>              </div>            </details><details class="folding-tag" green><summary> 查看代码测试 </summary>              <div class='content'>              <p>假装这里有代码块（代码块没法嵌套代码块）</p>              </div>            </details><details class="folding-tag" yellow><summary> 查看列表测试 </summary>              <div class='content'>              <ul><li>haha</li><li>hehe</li></ul>              </div>            </details><details class="folding-tag" red><summary> 查看嵌套测试 </summary>              <div class='content'>              <details class="folding-tag" blue><summary> 查看嵌套测试2 </summary>              <div class='content'>              <details class="folding-tag" ><summary> 查看嵌套测试3 </summary>              <div class='content'>              <p>hahaha <span><img src='https://source.drie.cn/img/cat.png' style='height:24px'></span></p>              </div>            </details>              </div>            </details>              </div>            </details><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-21-分栏-tab">2.21 分栏 tab</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">配置参数</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs Unique name, [index] %&#125;</span><br><span class="line">&lt;!-- tab [Tab caption] [@icon] --&gt;</span><br><span class="line">Any content (support inline tags too).</span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>Unique name :</p><ul><li><p>选项卡块标签的唯一名称，不带逗号。</p></li><li><p>将在#id中用作每个标签及其索引号的前缀。</p></li><li><p>如果名称中包含空格，则对于生成#id，所有空格将由破折号代替。</p></li><li><p>仅当前帖子/页面的URL必须是唯一的！</p></li></ul></li><li><p>[index]:</p><ul><li><p>活动选项卡的索引号。</p></li><li><p>如果未指定，将选择第一个标签（1）。</p></li><li><p>如果index为-1，则不会选择任何选项卡。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[Tab caption]:</p><ul><li><p>当前选项卡的标题。</p></li><li><p>如果未指定标题，则带有制表符索引后缀的唯一名称将用作制表符的标题。</p></li><li><p>如果未指定标题，但指定了图标，则标题将为空。</p></li><li><p>可选参数。</p></li></ul></li><li><p>[@icon]:</p><ul><li><p>FontAwesome图标名称（全名，看起来像“ fas fa-font”）</p></li><li><p>可以指定带空格或不带空格；</p></li><li><p>例如’Tab caption @icon’ 和 ‘Tab caption@icon’.</p></li><li><p>可选参数。</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.Demo 1 - 预设选择第一个【默认】</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>2.Demo 2 - 预设选择tabs</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test2, 3 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>3.Demo 3 - 没有预设值</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test3, -1 %&#125;</span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 1.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 2.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab --&gt;</span><br><span class="line"><span class="strong">**This is Tab 3.**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;% tabs test4 %&#125;</span><br><span class="line">&lt;!-- tab 第一个Tab --&gt;</span><br><span class="line"><span class="strong">**tab名字为第一个Tab**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab @fab fa-apple-pay --&gt;</span><br><span class="line"><span class="strong">**只有图标 没有Tab名字**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- tab 炸弹@fas fa-bomb --&gt;</span><br><span class="line"><span class="strong">**名字+icon**</span></span><br><span class="line">&lt;!-- endtab --&gt;</span><br><span class="line">&#123;% endtabs %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.Demo 1 - 预设选择第一个【默认】</p><div class="tabs" id="test1"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test1-1">test1 1</button></li><li class="tab"><button type="button" data-href="#test1-2">test1 2</button></li><li class="tab"><button type="button" data-href="#test1-3">test1 3</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test1-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test1-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>2.Demo 2 - 预设选择tabs</p><div class="tabs" id="test2"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test2-1">test2 1</button></li><li class="tab"><button type="button" data-href="#test2-2">test2 2</button></li><li class="tab active"><button type="button" data-href="#test2-3">test2 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test2-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test2-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content active" id="test2-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>3.Demo 3 - 没有预设值</p><div class="tabs" id="test3"><ul class="nav-tabs"><li class="tab"><button type="button" data-href="#test3-1">test3 1</button></li><li class="tab"><button type="button" data-href="#test3-2">test3 2</button></li><li class="tab"><button type="button" data-href="#test3-3">test3 3</button></li></ul><div class="tab-contents"><div class="tab-item-content" id="test3-1"><p><strong>This is Tab 1.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-2"><p><strong>This is Tab 2.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test3-3"><p><strong>This is Tab 3.</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><p>4.Demo 4 - 自定义Tab名 + 只有icon + icon和Tab名</p><div class="tabs" id="test4"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#test4-1">第一个Tab</button></li><li class="tab"><button type="button" data-href="#test4-2"><i class="fab fa-apple-pay" style="text-align: center;"></i></button></li><li class="tab"><button type="button" data-href="#test4-3"><i class="fas fa-bomb"></i>炸弹</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="test4-1"><p><strong>tab名字为第一个Tab</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-2"><p><strong>只有图标 没有Tab名字</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="test4-3"><p><strong>名字+icon</strong></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-22-诗词标签-poem">2.22 诗词标签 poem</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-3">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><ol><li><code>title</code>：诗词标题</li><li><code>author</code>：作者，可以不写</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% poem 水调歌头,苏轼 %&#125;</span><br><span class="line">丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。</span><br><span class="line">明月几时有？把酒问青天。</span><br><span class="line">不知天上宫阙，今夕是何年？</span><br><span class="line">我欲乘风归去，又恐琼楼玉宇，高处不胜寒。</span><br><span class="line">起舞弄清影，何似在人间？</span><br><span class="line"></span><br><span class="line">转朱阁，低绮户，照无眠。</span><br><span class="line">不应有恨，何事长向别时圆？</span><br><span class="line">人有悲欢离合，月有阴晴圆缺，此事古难全。</span><br><span class="line">但愿人长久，千里共婵娟。</span><br><span class="line">&#123;% endpoem %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><div class='poem'><div class='poem-title'>水调歌头</div><div class='poem-author'>苏轼</div><p>丙辰中秋，欢饮达旦，大醉，作此篇，兼怀子由。<br>明月几时有？把酒问青天。<br>不知天上宫阙，今夕是何年？<br>我欲乘风归去，又恐琼楼玉宇，高处不胜寒。<br>起舞弄清影，何似在人间？</p><p>转朱阁，低绮户，照无眠。<br>不应有恨，何事长向别时圆？<br>人有悲欢离合，月有阴晴圆缺，此事古难全。<br>但愿人长久，千里共婵娟。</p></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-23-阿里图标-icon">2.23 阿里图标 icon</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon [icon-xxxx],[font-size] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>icon-xxxx</code>：表示图标<code>font-class</code>,可以在自己的阿里矢量图标库项目的<code>font-class</code>引用方案内查询并复制。</li><li><code>font-size</code>：表示图标大小，直接填写数字即可，单位为<code>em</code>。图标大小默认值为<code>1em</code>。</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% icon icon-rat<span class="emphasis">_zi %&#125;&#123;% icon icon-rat,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-ox_</span>chou,3 %&#125;&#123;% icon icon-ox,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-tiger<span class="emphasis">_yin,5 %&#125;&#123;% icon icon-tiger,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rabbit_</span>mao,1 %&#125;&#123;% icon icon-rabbit,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dragon<span class="emphasis">_chen,3 %&#125;&#123;% icon icon-dragon,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-snake_</span>si,5 %&#125;&#123;% icon icon-snake,6 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-horse<span class="emphasis">_wu %&#125;&#123;% icon icon-horse,2 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-goat_</span>wei,3 %&#125;&#123;% icon icon-goat,4 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-monkey<span class="emphasis">_shen,5 %&#125;&#123;% icon icon-monkey,6 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-rooster_</span>you %&#125;&#123;% icon icon-rooster,2 %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% icon icon-dog<span class="emphasis">_xu,3 %&#125;&#123;% icon icon-dog,4 %&#125;</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">&#123;% icon icon-boar_</span>hai,5 %&#125;&#123;% icon icon-boar,6 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rat_zi"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rat"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-ox_chou"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-ox"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-tiger_yin"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-tiger"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rabbit_mao"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rabbit"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dragon_chen"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dragon"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-snake_si"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-snake"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-horse_wu"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-horse"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-goat_wei"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-goat"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-monkey_shen"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-monkey"></use></svg></p><p><svg class="icon" style="width:1em; height:1em" aria-hidden="true"><use xlink:href="#icon-rooster_you"></use></svg><svg class="icon" style="width:2em; height:2em" aria-hidden="true"><use xlink:href="#icon-rooster"></use></svg></p><p><svg class="icon" style="width:3em; height:3em" aria-hidden="true"><use xlink:href="#icon-dog_xu"></use></svg><svg class="icon" style="width:4em; height:4em" aria-hidden="true"><use xlink:href="#icon-dog"></use></svg></p><p><svg class="icon" style="width:5em; height:5em" aria-hidden="true"><use xlink:href="#icon-boar_hai"></use></svg><svg class="icon" style="width:6em; height:6em" aria-hidden="true"><use xlink:href="#icon-boar"></use></svg></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-24-特效标签wow">2.24 特效标签wow</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-2">渲染演示</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow [animete],[duration],[delay],[offset],[iteration] %&#125;</span><br><span class="line">内容</span><br><span class="line">&#123;% endwow %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>animate</code>: 动画样式，效果详见<a href="https://animate.style/">animate.css参考文档</a></li><li><code>duration</code>: 选填项，动画持续时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>delay</code>: 选填项，动画开始的延迟时间，单位可以是<code>ms</code>也可以是<code>s</code>。例如<code>3s</code>，<code>700ms</code>。</li><li><code>offset</code>: 选填项，开始动画的距离（相对浏览器底部）</li><li><code>iteration</code>: 选填项，动画重复的次数</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><p>1.flip动画效果。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__zoomIn,5s,5s,100,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note blue &#x27;fas fa-bullhorn&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`zoomIn`动画效果，持续`5s`，延时`5s`，离底部`100`距离时启动，重复`10`次</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>3.slideInRight动画效果，持续5s，延时5s</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__slideInRight,5s,5s %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note orange &#x27;fas fa-car&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`slideInRight`动画效果，持续`5s`，延时`5s`。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% wow animate<span class="strong">__heartBeat,,5s,,10 %&#125;</span></span><br><span class="line"><span class="strong">&#123;% note red &#x27;fas fa-battery-half&#x27; modern%&#125;</span></span><br><span class="line"><span class="strong">`heartBeat`动画效果，延时`5s`，重复`10`次。</span></span><br><span class="line"><span class="strong">&#123;% endnote %&#125;</span></span><br><span class="line"><span class="strong">&#123;% endwow %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>1.flip动画效果。</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>2.zoomIn动画效果，持续5s，延时5s，离底部100距离时启动，重复10次</p><div class='wow animate__zoomIn' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset='100'  data-wow-iteration='10' ><div class="note blue icon-padding modern"><i class="note-icon fas fa-bullhorn"></i><p><code>zoomIn</code>动画效果，持续<code>5s</code>，延时<code>5s</code>，离底部<code>100</code>距离时启动，重复<code>10</code>次</p></div></div><p>3.slideInRight动画效果，持续5s，延时5s</p><div class='wow animate__slideInRight' data-wow-duration='5s' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='' ><div class="note orange icon-padding modern"><i class="note-icon fas fa-car"></i><p><code>slideInRight</code>动画效果，持续<code>5s</code>，延时<code>5s</code>。</p></div></div><p>4.heartBeat动画效果，延时5s，重复10次。此处注意不用的参数位置要留空，用逗号间隔。</p><div class='wow animate__heartBeat' data-wow-duration='' data-wow-delay='5s' data-wow-offset=''  data-wow-iteration='10' ><div class="note red icon-padding modern"><i class="note-icon fas fa-battery-half"></i><p><code>heartBeat</code>动画效果，延时<code>5s</code>，重复<code>10</code>次。</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-25-进度条-progress">2.25  进度条 progress</h2><div class="note info flat"><p>进度条标签参考<a href="https://rongbuqiu.com/jdt.html">沂佰孜猫-给HEXO文章添加彩色进度条</a>。<br>源样式提取自<a href="https://zwying0814.gitbook.io/cuteen/">Cuteen</a>主题。</p></div><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-2">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress [width] [color] [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>width</code>: 0到100的阿拉伯数字</li><li><code>color</code>: 颜色，取值有red,yellow,green,cyan,blue,gray</li><li><code>text</code>:进度条上的文字内容</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;% progress 10 red 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 30 yellow 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 50 green 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 70 cyan 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 90 blue 进度条样式预览 %&#125;</span><br><span class="line">&#123;% progress 100 gray 进度条样式预览 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-red"  style="width: 10%" aria-valuenow="10" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-yellow"  style="width: 30%" aria-valuenow="30" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-green"  style="width: 50%" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-cyan"  style="width: 70%" aria-valuenow="70" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-blue"  style="width: 90%" aria-valuenow="90" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><div class="progress"><div class="progress-bar-animated progress-bar progress-bar-striped bg-gray"  style="width: 100%" aria-valuenow="100" aria-valuemin="0" aria-valuemax="100"><p>进度条样式预览</p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-26-注释-notation">2.26 注释 notation</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota [label] , [text] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p><code>label</code>: 注释词汇</p></li><li><p><code>text</code>: 悬停显示的注解内容</p></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% nota 把鼠标移动到我上面试试 ,可以看到注解内容出现在顶栏 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p><span class='nota' data-nota='可以看到注解内容出现在顶栏'>把鼠标移动到我上面试试</span></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-27-气泡注释-bubble">2.27 气泡注释 bubble</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% bubble [content] , [notation] ,[background-color] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>content</code>: 注释词汇</li><li><code>notation</code>: 悬停显示的注解内容</li><li><code>background-color</code>: 可选，气泡背景色。默认为“#71a4e3”</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的&#123;% bubble 兄弟相邻选择器,&quot;例如 h1 + p &#123;margin-top:50px;&#125;&quot; %&#125;，&#123;% bubble flex布局,&quot;Flex 是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;,&quot;#ec5830&quot; %&#125;，&#123;% bubble transform变换,&quot;transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。&quot;,&quot;#1db675&quot; %&#125;，animation的&#123;% bubble 贝塞尔速度曲线,&quot;贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋&quot;,&quot;#de4489&quot; %&#125;写法，还有今天刚看到的&#123;% bubble clip-path,&quot;clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。&quot;,&quot;#868fd7&quot; %&#125;属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>最近我学到了不少新玩意儿（虽然对很多大佬来说这些已经是旧技术了），比如CSS的<span class="bubble-content">兄弟相邻选择器</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#71a4e3;">例如 h1 + p {margin-top:50px;}</span></span>，<span class="bubble-content">flex布局</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#ec5830;">Flex 是 Flexible Box 的缩写，意为弹性布局&quot;，用来为盒状模型提供最大的灵活性&quot;</span></span>，<span class="bubble-content">transform变换</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#1db675;">transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转、缩放、移动或倾斜。</span></span>，animation的<span class="bubble-content">贝塞尔速度曲线</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#de4489;">贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋</span></span>写法，还有今天刚看到的<span class="bubble-content">clip-path</span><span class="bubble-notation"><span class="bubble-item" style="background-color:#868fd7;">clip-path属性使用裁剪方式创建元素的可显示区域。区域内的部分显示，区域外的隐藏。</span></span>属性。这些对我来说很新颖的概念狠狠的冲击着我以前积累起来的设计思路。</p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-28-引用文献-reference">2.28 引用文献 reference</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% referto [id] , [literature] %&#125;</span><br><span class="line">&#123;% referfrom [id] , [literature] , [url] %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><p>referto 引用上标</p><ul><li><p><code>id</code>: 上标序号内容，需与referfrom标签的id对应才能实现跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li></ul></li><li><p>referfrom 引用出处</p><ul><li><p><code>id</code>: 序号内容，需与referto标签的id对应才能实现 跳转</p></li><li><p><code>literature</code>: 引用的参考文献名称</p></li><li><p><code>url</code>: 引用的参考文献链接，可省略</p></li></ul></li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Akilarの糖果屋(akilar.top)是一个私人性质的博客&#123;% referto &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27; %&#125;，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架&#123;% referto &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27; %&#125;，Butterfly主题&#123;% referto &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">本项目参考了Volantis&#123;% referto &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27; %&#125;的标签样式。引入<span class="code">`[tag].js`</span>，并针对<span class="code">`butterfly`</span>主题修改了相应的<span class="code">`[tag].styl`</span>。在此鸣谢<span class="code">`Volantis`</span>主题众开发者。</span><br><span class="line">主要参考内容包括各个volantis的内置标签插件文档&#123;% referto &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27; %&#125;</span><br><span class="line">Butterfly主题的各个衍生魔改&#123;% referto &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27; %&#125;&#123;% referto &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27; %&#125;&#123;% referto &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27; %&#125;&#123;% referto &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27; %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% referfrom &#x27;[1]&#x27;,&#x27;Akilarの糖果屋群聊简介&#x27;,&#x27;https://jq.qq.com/?<span class="emphasis">_wv=1027&amp;k=pGLB2C0N&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[2]&#x27;,&#x27;Hexo中文文档&#x27;,&#x27;https://hexo.io/zh-cn/docs/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[3]&#x27;,&#x27;Butterfly 安装文档(一) 快速开始&#x27;,&#x27;https://butterfly.js.org/posts/21cfbf15/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[4]&#x27;,&#x27;hexo-theme-volantis 标签插件&#x27;,&#x27;https://volantis.js.org/v5/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[5]&#x27;,&#x27;Volantis文档:内置标签插件&#x27;,&#x27;https://volantis.js.org/tag-plugins/&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[6]&#x27;,&#x27;Butterfly 安装文档:标签外挂（Tag Plugins&#x27;,&#x27;https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[7]&#x27;,&#x27;小弋の生活馆全样式预览&#x27;,&#x27;https://lovelijunyi.gitee.io/posts/c898.html&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[8]&#x27;,&#x27;l-lin-font-awesome-animation&#x27;,&#x27;https://github.com/l-lin/font-awesome-animation&#x27; %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% referfrom &#x27;[9]&#x27;,&#x27;小康的butterfly主题使用文档&#x27;,&#x27;https://www.antmoe.com/posts/3b43914f/&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>Akilarの糖果屋(akilar.top)是一个私人性质的博客<span class="hidden-anchor" id="referto_[1]"></span><sup class="reference"><a href="#referfrom_[1]">[1]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Akilarの糖果屋群聊简介</span><span class="reference-title">参考资料</span></span></span>，从各类教程至生活点滴，无话不谈。建群的目的是提供一个闲聊的场所。博客采用Hexo框架<span class="hidden-anchor" id="referto_[2]"></span><sup class="reference"><a href="#referfrom_[2]">[2]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Hexo中文文档</span><span class="reference-title">参考资料</span></span></span>，Butterfly主题<span class="hidden-anchor" id="referto_[3]"></span><sup class="reference"><a href="#referfrom_[3]">[3]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档(一) 快速开始</span><span class="reference-title">参考资料</span></span></span></p><p>本项目参考了Volantis<span class="hidden-anchor" id="referto_[4]"></span><sup class="reference"><a href="#referfrom_[4]">[4]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">hexo-theme-volantis 标签插件</span><span class="reference-title">参考资料</span></span></span>的标签样式。引入<code>[tag].js</code>，并针对<code>butterfly</code>主题修改了相应的<code>[tag].styl</code>。在此鸣谢<code>Volantis</code>主题众开发者。<br>主要参考内容包括各个volantis的内置标签插件文档<span class="hidden-anchor" id="referto_[5]"></span><sup class="reference"><a href="#referfrom_[5]">[5]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Volantis文档:内置标签插件</span><span class="reference-title">参考资料</span></span></span><br>Butterfly主题的各个衍生魔改<span class="hidden-anchor" id="referto_[6]"></span><sup class="reference"><a href="#referfrom_[6]">[6]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">Butterfly 安装文档:标签外挂（Tag Plugins</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[7]"></span><sup class="reference"><a href="#referfrom_[7]">[7]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小弋の生活馆全样式预览</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[8]"></span><sup class="reference"><a href="#referfrom_[8]">[8]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">l-lin-font-awesome-animation</span><span class="reference-title">参考资料</span></span></span><span class="hidden-anchor" id="referto_[9]"></span><sup class="reference"><a href="#referfrom_[9]">[9]</a></sup><span class="reference-bubble"><span class="reference-item"><span class="reference-literature">小康的butterfly主题使用文档</span><span class="reference-title">参考资料</span></span></span></p><div class="reference-source"><span class="hidden-anchor" id="referfrom_[1]"></span><a class="reference-anchor" href="#referto_[1]">[1]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://jq.qq.com/?_wv=1027&k=pGLB2C0N">Akilarの糖果屋群聊简介</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[2]"></span><a class="reference-anchor" href="#referto_[2]">[2]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://hexo.io/zh-cn/docs/">Hexo中文文档</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[3]"></span><a class="reference-anchor" href="#referto_[3]">[3]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/21cfbf15/">Butterfly 安装文档(一) 快速开始</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[4]"></span><a class="reference-anchor" href="#referto_[4]">[4]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/v5/tag-plugins/">hexo-theme-volantis 标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[5]"></span><a class="reference-anchor" href="#referto_[5]">[5]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://volantis.js.org/tag-plugins/">Volantis文档:内置标签插件</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[6]"></span><a class="reference-anchor" href="#referto_[6]">[6]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://butterfly.js.org/posts/4aa8abbe/#%E6%A8%99%E7%B1%A4%E5%A4%96%E6%8E%9B%EF%BC%88Tag-Plugins%EF%BC%89">Butterfly 安装文档:标签外挂（Tag Plugins</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[7]"></span><a class="reference-anchor" href="#referto_[7]">[7]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://lovelijunyi.gitee.io/posts/c898.html">小弋の生活馆全样式预览</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[8]"></span><a class="reference-anchor" href="#referto_[8]">[8]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://github.com/l-lin/font-awesome-animation">l-lin-font-awesome-animation</a></div><div class="reference-source"><span class="hidden-anchor" id="referfrom_[9]"></span><a class="reference-anchor" href="#referto_[9]">[9]<div class="reference-anchor-up fa-solid fa-angles-up"></div></a><a class="reference-link" href="https://www.antmoe.com/posts/3b43914f/">小康的butterfly主题使用文档</a></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-29-PDF展示">2.29 PDF展示</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pdf 文件路径 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li><code>文件路径</code>: 可以是相对路径或者是在线链接</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 1.本地文件:在md文件路径下创建一个同名文件夹，其内放pdf文件名为xxx.pdf的文件</span></span><br><span class="line">&#123;% pdf xxx.pdf %&#125;</span><br><span class="line"><span class="section"># 2.在线链接</span></span><br><span class="line">&#123;% pdf https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><p>2.在线链接(要放到最外层才能起作用)</p><pre><code>&lt;div class=&quot;row&quot;&gt;&lt;embed src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/pdf/小作文讲义.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pdf&quot;&gt;&lt;/div&gt;</code></pre><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-30-Hexo-tag-map-插件">2.30 Hexo-tag-map 插件</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% + 标签值 + 经度 + 纬度 + 文本 + 缩放等级 + 宽 + 高 + 默认图层 + %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><table><thead><tr><th style="text-align:center">地图名</th><th style="text-align:center">标签值 &lt;必填&gt;</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">缩放等级 (默认 14)</th><th style="text-align:center">宽 (默认 100%) / 高 (默认 360px)</th><th style="text-align:center">默认图层 (默认 1)</th></tr></thead><tbody><tr><td style="text-align:center">混合地图</td><td style="text-align:center">map</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~7</td></tr><tr><td style="text-align:center">谷歌地图</td><td style="text-align:center">googleMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~20</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">高德地图</td><td style="text-align:center">gaodeMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 3~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~3</td></tr><tr><td style="text-align:center">百度地图</td><td style="text-align:center">baiduMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 4~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~2</td></tr><tr><td style="text-align:center">Geoq 地图</td><td style="text-align:center">geoqMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~5</td></tr><tr><td style="text-align:center">openstreet 地图</td><td style="text-align:center">openstreetMap</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">取值 1~18</td><td style="text-align:center">百分数或具体值 (100% 或 360px)</td><td style="text-align:center">不支持此参数</td></tr></tbody></table><ol><li>参数之间，用英文逗号相隔</li><li>参数必须按上述事例顺序输入，不得为空</li><li>同一个页面，同一组经纬度值，只能插入一个相同标签值的地图 (若有需要，可以将第二个地图上，经度或纬度末尾删除一两个数)</li><li>参数取值必须在上述范围内</li><li>默认图层：即地图叠加层的值，默认常规地图还是卫星地图，可按地图显示顺序取值</li><li>缩放等级，数字越大，地图比例尺越小，显示的越精细</li><li>除标签值外，其他参数选填，但 每个参数的左边的参数必填</li><li>谷歌地图需要外网才能加载查看</li></ol><p>坐标获取：<a href="https://lbs.amap.com/tools/picker">高德地图坐标拾取系统</a> 、<a href="https://api.map.baidu.com/lbsapi/getpoint/index.html">百度地图坐标拾取系统</a></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% map 120.101101,30.239119 %&#125;</span><br><span class="line">&#123;% googleMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！ %&#125;</span><br><span class="line">&#123;% geoqMap 120.101101,30.239119, 这里是西湖灵隐寺，据说求姻缘很灵验哦！, 13, 90%, 320px, 3 %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div class="map-box" style="margin: 0.8rem 0 1.6rem 0;"><div id="map-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div></div><script type="text/javascript">var normalm=L.tileLayer.chinaProvider('GaoDe.Normal.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imgm=L.tileLayer.chinaProvider('GaoDe.Satellite.Map',{maxZoom:20,minZoom:1,attribution:'高德地图'});var imga=L.tileLayer.chinaProvider('GaoDe.Satellite.Annotion',{maxZoom:20,minZoom:1,attribution:'高德地图'});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:20,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'});routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1});var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:21,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:21,minZoom:1,attribution:'Google Maps'});var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:21,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm]),image=L.layerGroup([imgm,imga]);var baseLayers={"高德地图":normal,"智图地图":normalm1,"谷歌地图":normalMap,"高德卫星地图":imgm,"谷歌卫星地图":satelliteMap,"高德卫星标注":image,"谷歌卫星标注":routeMap};var mymap=L.map('map-120.101101-30.239119',{center:[30.239119,120.101101],zoom:14,layers:[normal],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="googleMap-120.101101-30.239119" style="max-width:100%; height:360px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalMap=L.tileLayer.chinaProvider('Google.Normal.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),satelliteMap=L.tileLayer.chinaProvider('Google.Satellite.Map',{maxZoom:22,minZoom:1,attribution:'Google Maps'}),routeMap=L.tileLayer.chinaProvider('Google.Satellite.Annotion',{maxZoom:22,minZoom:1,attribution:'Google Maps'});var baseLayers={"谷歌地图":normalMap,"谷歌卫星图":satelliteMap,"谷歌卫星标注": routeMap};var overlayLayers={};var mymap=L.map("googleMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:14,layers:[normalMap],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><link rel="stylesheet" href="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.css"><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet@1.7.1.js"></script><script data-pjax src="//unpkg.com/hexo-tag-map/lib/leaflet.ChineseTmsProviders@1.0.4.js"></script><div id="geoqMap-120.101101-30.239119" style="max-width:90%; height:320px;display: block;margin:0 auto;z-index:1;border-radius: 5px;"></div><script type="text/javascript">var normalm1=L.tileLayer.chinaProvider('Geoq.Normal.Map',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm2=L.tileLayer.chinaProvider('Geoq.Normal.PurplishBlue',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm3=L.tileLayer.chinaProvider('Geoq.Normal.Gray',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm4=L.tileLayer.chinaProvider('Geoq.Normal.Warm',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normalm5=L.tileLayer.chinaProvider('Geoq.Theme.Hydro',{maxZoom:20,minZoom:1,attribution:'GeoQ'});var normal=L.layerGroup([normalm1,normalm2,normalm3,normalm4,normalm5]);var baseLayers={"智图地图":normalm1,"午夜蓝":normalm2,"灰色":normalm3,"暖色":normalm4,"水系":normalm5};var mymap=L.map("geoqMap-120.101101-30.239119",{center:[30.239119,120.101101],zoom:13,layers:[normalm3],zoomControl:false});L.control.layers(baseLayers,null).addTo(mymap);L.control.zoom({zoomInTitle:'放大',zoomOutTitle:'缩小'}).addTo(mymap);var marker = L.marker(['30.239119','120.101101']).addTo(mymap);marker.bindPopup("这里是西湖灵隐寺，据说求姻缘很灵验哦！").openPopup();</script><br><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><h2 id="2-31-隐藏块">2.31 隐藏块</h2><div class="tabs" id="分栏"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#分栏-1">标签语法</button></li><li class="tab"><button type="button" data-href="#分栏-2">参数配置</button></li><li class="tab"><button type="button" data-href="#分栏-3">示例源码</button></li><li class="tab"><button type="button" data-href="#分栏-4">渲染演示</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="分栏-1"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-2"><ol><li>content：要隐藏的内容</li><li>display：展示前按钮显示的文字（可选）</li><li>bg：按钮的背景颜色（可选）</li><li>color：按钮显示的文字的颜色（可选）</li></ol><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-3"><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 点我预览, blue %&#125;</span><br><span class="line">这里有张图片：</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;image (1)&quot;</span> <span class="attr">style</span>=<span class="string">&quot;zoom:67%;&quot;</span> /&gt;</span></span></span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="分栏-4"><div class="hide-block"><button type="button" class="hide-button" style="background-color:  blue;">点我预览    </button><div class="hide-content"><p>这里有张图片：<br><img src="https://s1.vika.cn/space/2022/10/30/b35fce448bc9404a8d65c3ce1e6e46eb" alt="image (1)" style="zoom:67%;" /></p></div></div><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div>]]></content>
    
    
    <summary type="html">🥧本文汇总Markdown格式以及外挂标签在网页端的渲染效果，可作为文档进行查询</summary>
    
    
    
    <category term="演示" scheme="https://drie.cn/categories/%E6%BC%94%E7%A4%BA/"/>
    
    
    <category term="Markdown" scheme="https://drie.cn/tags/Markdown/"/>
    
    <category term="外挂标签" scheme="https://drie.cn/tags/%E5%A4%96%E6%8C%82%E6%A0%87%E7%AD%BE/"/>
    
  </entry>
  
</feed>
